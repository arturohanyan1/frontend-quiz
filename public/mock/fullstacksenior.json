[
  {
    "position": "senior",
    "topic": "general",
    "questions": [
      {
        "id": 1,
        "question": "Расскажите о функциональном программировании.",
        "answer": "Функциональное программирование (ФП) — это парадигма программирования, основанная на использовании функций как основных строительных блоков и ограничении изменяемого состояния и мутабельных данных. Основные концепции ФП включают чистые функции (pure functions), неизменяемость данных, рекурсию, функции высших порядков и использование функциональных комбинаторов. ФП способствует написанию более декларативного и чистого кода, облегчает тестирование и повышает параллелизм. Основные языки функционального программирования включают Haskell, Clojure, Erlang, Scala и другие."
      },
      {
        "id": 2,
        "question": "Что такое TDD (Test Driven Development) / BDD (Behavior Driven Development)?",
        "answer": "TDD (Test Driven Development) — методология разработки программного обеспечения, основанная на написании тестов перед написанием самого кода. Цель TDD заключается в создании четко определенных тестов, которые проверяют функциональность кода, до того как код будет написан. BDD (Behavior Driven Development) — это дальнейшее развитие TDD, с акцентом на описании поведения системы на естественном языке (например, на языке Gherkin), который легко читать и понимать стейкхолдерам. BDD специализируется на тестировании поведения и взаимодействия компонентов системы."
      },
      {
        "id": 3,
        "question": "Расскажите подробно о работе HTTPS.",
        "answer": "HTTPS (HyperText Transfer Protocol Secure) — это защищенная версия HTTP, использующая протокол TLS (Transport Layer Security) или его предшественника SSL (Secure Sockets Layer) для обеспечения безопасности передачи данных между клиентом и сервером. Работа HTTPS начинается с установления защищенного соединения между клиентом и сервером с использованием SSL/TLS протоколов. Этот процесс включает в себя шифрование данных, аутентификацию сторон, целостность данных и защиту от повторной передачи (replay protection). HTTPS обеспечивает конфиденциальность, целостность и аутентичность данных, передаваемых через интернет."
      },
      {
        "id": 4,
        "question": "Какой стек технологий можно выбрать для реализации клона какого-нибудь известного проекта и почему?",
        "answer": "Выбор стека технологий для клона известного проекта зависит от множества факторов, включая требования проекта, сроки, опыт команды разработчиков и цели проекта. Например, для создания клона Twitter можно выбрать Node.js для серверной части, React для фронтенда, MongoDB для хранения данных (например, твитов и пользователей), и Redis для кэширования и обработки в реальном времени. Этот стек технологий выбран из-за своей популярности, производительности и гибкости."
      },
      {
        "id": 5,
        "question": "Имеется проект на старых технологиях, необходимо в него вносить изменения. Как это сделать лучше всего?",
        "answer": "При внесении изменений в проект на старых технологиях лучше всего следовать принципу gradual upgrade — постепенного обновления. Это означает постепенное внедрение новых технологий, без полного переписывания проекта с нуля. Важно начать с анализа текущей архитектуры проекта и определения узких мест или устаревших компонентов. Затем выбрать части проекта, которые наиболее подходят для обновления, и начать с них. Постепенное обновление позволяет минимизировать риски и обеспечивает более плавный переход к современным технологиям."
      },
      {
        "id": 6,
        "question": "Если у кандидата есть опыт работы с несколькими фреймворками: какой будете использовать для следующего проекта? Какие факторы будут влиять на выбор?",
        "answer": "Выбор фреймворка для следующего проекта зависит от конкретных требований проекта, опыта команды разработчиков, экосистемы фреймворка, его поддержки и стабильности. Например, для проекта, требующего высокой производительности и масштабируемости, можно выбрать фреймворк Express.js для Node.js. Если требуется создание интерактивного пользовательского интерфейса, React может быть хорошим выбором благодаря своей гибкости и большому сообществу разработчиков."
      },
      {
        "id": 7,
        "question": "Что такое V8 Engine?",
        "answer": "V8 Engine — это открытая реализация JavaScript движка, разработанная компанией Google для использования в своих продуктах, включая браузер Chrome и серверную среду Node.js. V8 обеспечивает интерпретацию и компиляцию JavaScript в машинный код, оптимизацию производительности, управление памятью и другие функции. Он известен своей скоростью выполнения JavaScript кода и активно развивается для поддержки новых стандартов ECMAScript и оптимизации производительности."
      }
    ]
  },
  {
    "position": "senior",
    "topic": "jsCore",
    "questions": [
      {
        "id": 8,
        "question": "Реализация паттерна Class Free OOP (HTTPs://observablehq.com/@bratter/class-free-oop).",
        "answer": "Паттерн Class Free OOP представляет собой способ организации объектно-ориентированного программирования (ООП), в котором избегается использование классов в пользу функций и объектов. Основная идея заключается в том, чтобы использовать функции для создания объектов и оперировать данными как состоянием функций. Вместо классов используются функциональные конструкции, замыкания и прототипы для организации кода. Этот подход позволяет создавать более гибкие и легко тестируемые программы, а также упрощает кодирование в функциональном стиле."
      },
      {
        "id": 9,
        "question": "Паттерн async disposer (HTTPs://advancedweb.hu/what-is-the-async-disposer-pattern-in-javascript).",
        "answer": "Паттерн async disposer — это паттерн проектирования, который помогает управлять ресурсами или выполнением асинхронных операций с помощью специального объекта-диспозера. Основная идея заключается в том, чтобы асинхронно освобождать ресурсы после завершения выполнения определенных операций. Это особенно полезно в асинхронном JavaScript, где нужно корректно обрабатывать завершение операций и очистку ресурсов. Паттерн async disposer способствует улучшению управления памятью и ресурсами, предотвращает утечки ресурсов и делает код более надежным."
      },
      {
        "id": 10,
        "question": "Использование регулярных выражений. Когда приемлемо / неприемлемо? Как они работают? Как можно сделать читабельный код?",
        "answer": "Регулярные выражения (RegExp) используются для поиска и манипуляций текстовыми данными в строках. Они могут быть полезны при необходимости выполнения сложных операций поиска, замены и проверки шаблонов в строках. Однако использование регулярных выражений не всегда приемлемо из-за их сложности и трудности в понимании. Регулярные выражения обрабатывают текст, сопоставляя его с заданным шаблоном, что может привести к неожиданным результатам при неправильном использовании или плохо спроектированных шаблонах. Для улучшения читабельности кода с использованием регулярных выражений следует следовать следующим рекомендациям: документируйте регулярное выражение, используйте именованные группы для ясности, разделяйте сложные выражения на более простые части и добавляйте комментарии, если это необходимо."
      }
    ]
  },
  {
    "position": "senior",
    "topic": "frontend",
    "questions": [
      {
        "id": 11,
        "question": "Как браузер определяет, можем ли мы общаться между вкладками?",
        "answer": "Браузер определяет возможность общения между вкладками на основе политики безопасности Same-Origin Policy (SOP). Эта политика ограничивает доступ к данным между веб-страницами, загруженными из разных источников. Для взаимодействия между вкладками используются механизмы, такие как Local Storage, Session Storage, Cookies, PostMessage API и Broadcast Channel API, которые позволяют передавать данные между различными источниками или вкладками в пределах одного источника."
      },
      {
        "id": 12,
        "question": "Что такое Content Security Policy?",
        "answer": "Content Security Policy (CSP) — это механизм безопасности веб-приложений, который позволяет контролировать и ограничивать ресурсы, которые браузер может загружать и выполнить на веб-странице. CSP позволяет указать список источников ресурсов, с которыми страница может взаимодействовать (например, скрипты, стили, изображения, шрифты), что помогает предотвратить атаки XSS (межсайтовый скриптинг) и снизить риски утечек данных."
      },
      {
        "id": 13,
        "question": "Как избежать загрузки кэшированных файлов скриптов и стилей?",
        "answer": "Для избежания загрузки кэшированных файлов скриптов и стилей можно использовать различные методы: изменение URL ресурсов (например, добавление версионного номера к URL), установка заголовков Cache-Control или Expires для указания браузеру на необходимость перезагрузки ресурсов при каждом запросе, использование механизмов контроля кэша на сервере (например, настройка nginx или Apache), а также использование специфических HTTP заголовков (например, Cache-Control: no-cache) при загрузке ресурсов."
      },
      {
        "id": 14,
        "question": "Что такое requestAnimationFrame?",
        "answer": "requestAnimationFrame (RAF) — это API браузера, предназначенное для планирования анимаций и других задач, требующих обновления экрана в определенные моменты времени, с учетом частоты обновления экрана устройства пользователя. RAF предлагает браузеру анимационный цикл, который синхронизируется с обновлением экрана и позволяет создавать плавные и эффективные анимации на веб-странице."
      },
      {
        "id": 15,
        "question": "Расскажите о микросервисной архитектуре Front-end App.",
        "answer": "Микросервисная архитектура Front-end App подразумевает разделение фронтенд-приложения на отдельные модули или сервисы, каждый из которых отвечает за определенную функциональность или компонент приложения. Эти микросервисы могут быть развернуты независимо друг от друга, использовать различные технологии и иметь свою собственную базу кода. Такой подход упрощает масштабирование, разработку и тестирование приложения, а также позволяет лучше организовать командную работу и управление проектом."
      },
      {
        "id": 16,
        "question": "Что такое Shadow DOM?",
        "answer": "Shadow DOM (DOM с тенью) — это механизм веб-стандартов, позволяющий создавать изолированные DOM-деревья и скрывать внутренние реализации компонентов от внешнего DOM-дерева страницы. Shadow DOM позволяет инкапсулировать стили и функциональность компонентов, что предотвращает конфликты стилей и имен и обеспечивает изоляцию от внешних стилей и скриптов страницы."
      },
      {
        "id": 17,
        "question": "Сравните nextElementSibling и nextSibling.",
        "answer": "nextElementSibling и nextSibling — это свойства DOM-элемента, которые позволяют получить следующий элемент на том же уровне иерархии DOM. Основное различие между ними заключается в том, что nextElementSibling возвращает следующий элемент-узел, который является элементом (HTMLElement), в то время как nextSibling может вернуть любой следующий узел (не обязательно элемент). Поэтому при работе с DOM стоит учитывать тип возвращаемого элемента при использовании этих свойств."
      },
      {
        "id": 18,
        "question": "Какие знаете метрики веб-сайта?",
        "answer": "Существует множество метрик для оценки производительности и пользовательского опыта веб-сайта. Некоторые из них включают: Time to First Byte (TTFB), First Contentful Paint (FCP), Largest Contentful Paint (LCP), First Input Delay (FID), Cumulative Layout Shift (CLS), Total Blocking Time (TBT), Time to Interactive (TTI), Page Load Time, Page Size, и другие. Эти метрики помогают разработчикам и владельцам веб-сайтов оценить производительность, скорость загрузки страницы и пользовательский опыт, что важно для улучшения работы сайта и удовлетворения пользовательских потребностей."
      }
    ]
  },
  {
    "position": "senior",
    "topic": "angular",
    "questions": [
      {
        "id": 19,
        "question": "Как проводится конфигурация NgZone-модуля? Когда это необходимо?",
        "answer": "Конфигурация NgZone в Angular обычно проводится через опции при создании приложения или компонента. Необходимость конфигурации может возникнуть, когда требуется управление зоной выполнения Angular, например, для оптимизации производительности приложения. Это может включать создание кастомного NgZone или настройку опций NgZone для управления поведением обновления представления."
      },
      {
        "id": 20,
        "question": "Что раздражает в фреймворке? Что бы вы изменили?",
        "answer": "В разных фреймворках могут раздражать разные аспекты, такие как сложность настройки, избыточность API, неинтуитивные сообщения об ошибках и другие. Для улучшения фреймворка можно было бы упростить процесс настройки, предоставить более понятные и дружественные сообщения об ошибках, улучшить поддержку инструментов для разработчиков и документацию."
      },
      {
        "id": 21,
        "question": "Если бы вы решали, что добавить в следующем релизе фреймворка, какая фича это была бы?",
        "answer": "В следующем релизе фреймворка полезно было бы добавить поддержку динамической загрузки компонентов. Эта фича позволила бы загружать компоненты по требованию, улучшая производительность и масштабируемость приложений, особенно больших и сложных."
      },
      {
        "id": 22,
        "question": "Писали ли вы кастомные декораторы? Если да, то зачем?",
        "answer": "Да, кастомные декораторы часто используются для добавления дополнительной функциональности к классам, методам или свойствам в JavaScript и TypeScript. Они позволяют улучшить читаемость и модульность кода, а также добавить различные аспекты поведения, такие как логирование, кэширование, аутентификация и авторизация, метаданные и другие аспекты приложения."
      }
    ]
  },
  {
    "position": "senior",
    "topic": "backend",
    "questions": [
      {
        "id": 25,
        "question": "Сравните Common.js с AMD Modules и ES6 Imports.",
        "answer": "Common.js, AMD Modules и ES6 Imports - это различные спецификации для организации модульной системы в JavaScript.\n\n1. **Common.js**: Это формат модулей, используемый в Node.js. Модули Common.js загружаются синхронно и подходят для серверной разработки. Они используют `require()` для импорта и `module.exports` для экспорта.\n\n2. **AMD (Asynchronous Module Definition)**: AMD разработан для браузерной среды и поддерживает асинхронную загрузку модулей. Он использует функции `define()` для определения модулей и `require()` для их загрузки. AMD полезен для модульной системы с динамической загрузкой.\n\n3. **ES6 Imports (ES Modules)**: Это стандартная модульная система ECMAScript 6, поддерживаемая браузерами и Node.js. Она предоставляет синтаксис `import` для импорта модулей и `export` для их экспорта. ES6 Imports поддерживает статический анализ и декларативную зависимость, что улучшает производительность и обеспечивает надежность приложений."
      },
      {
        "id": 26,
        "question": "Какой фреймворк выбрали бы для бэкенда, почему?",
        "answer": "Выбор фреймворка для бэкенда зависит от требований проекта, команды разработчиков, опыта использования и других факторов. В качестве примера:\n\n- **Express.js**: Легкий и гибкий, подходит для небольших и средних проектов.\n- **Koa.js**: Более современный и использующий асинхронный подход с промисами.\n- **Spring Boot**: Для Java-разработки, предоставляющий множество интеграций и удобств в разработке.\n- **Django**: Используется в Python для быстрой разработки и мощных функций.\n\nВыбор фреймворка зависит также от экосистемы, сообщества поддержки, производительности, безопасности и специфических требований проекта."
      },
      {
        "id": 27,
        "question": "Опишите своими словами, как работает OAuth v2.",
        "answer": "OAuth 2.0 - это протокол авторизации, используемый для предоставления доступа к защищенным ресурсам от имени пользователя без необходимости передачи его учетных данных.\n\n1. **Авторизация**: Пользователь перенаправляется на сервер авторизации (Identity Provider) с запросом на доступ к ресурсу.\n\n2. **Подтверждение доступа**: Пользователь входит на сайте, указывает свое согласие на предоставление доступа требуемому приложению.\n\n3. **Выдача токена**: Авторизационный сервер генерирует токен доступа (Access Token) и, если необходимо, обновляет токен обновления (Refresh Token).\n\n4. **Доступ к ресурсу**: Приложение использует Access Token для доступа к защищенным ресурсам от имени пользователя.\n\nOAuth 2.0 обеспечивает гибкость и безопасность при работе с API и разделении доступа."
      },
      {
        "id": 28,
        "question": "Есть проект с источниками памяти, как их обнаружить, устранить и предотвратить это в будущем?",
        "answer": "Источники утечек памяти могут включать утечки обработчиков событий, утечки DOM-элементов, утечки замыканий или циклические ссылки на объекты. Для обнаружения и устранения утечек памяти:\n\n1. **Использование инструментов разработчика**: Профилирование кода с помощью инструментов, таких как Chrome DevTools, для анализа памяти и обнаружения утечек.\n\n2. **Очистка ресурсов**: Вручную освобождать ресурсы, такие как обработчики событий, подписки на события, ненужные DOM-элементы.\n\n3. **Использование слабых ссылок**: В JS можно использовать слабые ссылки для предотвращения циклических ссылок, что может привести к утечкам.\n\n4. **Тестирование и мониторинг**: Регулярное тестирование производительности и мониторинг работы приложения на предмет утечек памяти.\n\nДля предотвращения утечек памяти в будущем, важно следить за жизненным циклом объектов, минимизировать использование глобальных переменных и правильно управлять ресурсами."
      },
      {
        "id": 29,
        "question": "Есть проект с performance issues, как их обнаружить, устранить и предотвратить в будущем?",
        "answer": "Для обнаружения и устранения проблем с производительностью в проекте:\n\n1. **Профилирование кода**: Использование инструментов профилирования, таких как Chrome DevTools или специализированные инструменты, для идентификации узких мест в коде.\n\n2. **Оптимизация алгоритмов и структур данных**: Пересмотр алгоритмов на предмет оптимизации времени выполнения и использование эффективных структур данных.\n\n3. **Кэширование и оптимизация сетевых запросов**: Использование кэширования, минимизация запросов, оптимизация передачи данных.\n\n4. **Оптимизация загрузки ресурсов**: Минимизация и объединение файлов, использование сжатия и CDN для улучшения скорости загрузки.\n\n5. **Мониторинг и тестирование производительности**: Регулярное мониторинг производительности, создание профилей производительности и тестирование на масштабируемость.\n\nПредотвращение будущих проблем с производительностью включает в себя улучшение процесса разработки, регулярные аудиты производительности и внедрение мониторинга производительности в процесс разработки."
      }
    ]
  },
  {
    "position": "senior",
    "topic": "database",
    "questions": [
      {
        "id": 30,
        "question": "Какие альтернативные виды баз данных используете?",
        "answer": "В качестве альтернативных видов баз данных можно использовать:\n\n- **NoSQL базы данных** (например, MongoDB, Cassandra, Redis): Предназначены для работы с большими объемами неструктурированных данных и обеспечивают гибкость и масштабируемость.\n\n- **Графовые базы данных** (например, Neo4j, Amazon Neptune): Оптимизированы для работы с сильно связанными данными, такими как социальные сети или графы зависимостей.\n\n- **In-Memory базы данных** (например, Redis, Memcached): Хранят данные в оперативной памяти для быстрого доступа и обработки.\n\n- **Time-Series базы данных** (например, InfluxDB, Prometheus): Предназначены для хранения и анализа временных рядов данных, таких как метрики и логи времени выполнения.\n\n- **Wide-Column базы данных** (например, Apache Cassandra, ScyllaDB): Подходят для хранения и обработки больших объемов структурированных данных с высокой доступностью и масштабируемостью."
      },
      {
        "id": 31,
        "question": "Что такое RDS и почему он иногда не подходит?",
        "answer": "Amazon Relational Database Service (RDS) - это управляемый сервис баз данных от Amazon Web Services (AWS), который облегчает настройку, управление и масштабирование реляционных баз данных в облаке.\n\nОднако RDS может не подходить в следующих случаях:\n\n- **Высокие требования к масштабируемости**: RDS имеет ограничения по масштабируемости, особенно если требуется горизонтальное масштабирование или управление большими объемами данных.\n\n- **Сложные запросы и операции**: В некоторых случаях, особенно при сложных SQL-запросах или требованиях к производительности, может потребоваться более гибкий подход, чем предоставляемый RDS.\n\n- **Высокие затраты**: Использование RDS может быть дорогим в случае больших объемов данных или необходимости постоянного масштабирования и высокой доступности.\n\nВ таких ситуациях разработчики могут рассматривать альтернативные решения, такие как использование собственных серверов баз данных или переход к другим управляемым сервисам с большей гибкостью."
      },
      {
        "id": 32,
        "question": "Что такое SQL Injections и как их избежать?",
        "answer": "SQL Injection (SQLI) - это атака на безопасность, при которой злоумышленник вводит вредоносный SQL-код через входные данные приложения, что может привести к выполнению нежелательных SQL-запросов на сервере базы данных.\n\nДля предотвращения SQL Injections можно использовать следующие методы:\n\n- **Использование параметризованных запросов (Prepared Statements)**: Используйте параметры в SQL-запросах, которые передаются отдельно от запроса, а не включаются непосредственно в SQL-код.\n\n- **Использование ORM (Object-Relational Mapping)**: ORM фреймворки, такие как Sequelize для Node.js или Hibernate для Java, автоматически параметризируют SQL-запросы, что помогает избежать SQL Injections.\n\n- **Валидация и фильтрация входных данных**: Проверяйте и фильтруйте входные данные, чтобы исключить нежелательные символы и конструкции SQL.\n\n- **Минимизация прав доступа**: Ограничьте права доступа к базе данных на минимально необходимый уровень для предотвращения возможности выполнения вредоносных операций."
      },
      {
        "id": 33,
        "question": "Почему для запросов в БД надо использовать плейсхолдеры?",
        "answer": "Использование плейсхолдеров (placeholders) в SQL-запросах важно для безопасности и предотвращения SQL Injections. Плейсхолдеры позволяют отделить данные от кода SQL-запроса, что делает невозможным внедрение вредоносного SQL-кода через входные данные приложения.\n\nПреимущества использования плейсхолдеров:\n\n- **Безопасность**: Плейсхолдеры защищают от SQL Injections, поскольку данные передаются отдельно от SQL-кода и не интерпретируются как часть запроса.\n\n- **Производительность**: Некоторые СУБД могут кэшировать параметризованные запросы, что улучшает производительность за счет меньшей нагрузки на компиляцию и оптимизацию запросов.\n\n- **Читаемость и поддержка кода**: Параметризованные запросы обычно более читаемы и легче поддерживаются, так как они отделяют данные от логики запроса и делают код более ясным."
      },
      {
        "id": 34,
        "question": "Как спроектировать кластер на MongoDB?",
        "answer": "Проектирование кластера на MongoDB зависит от требований к производительности, доступности и масштабируемости приложения. Вот основные шаги по проектированию кластера:\n\n1. **Определение ролей узлов**: Выберите типы узлов (Primary, Secondary, Arbiters) в зависимости от требований к доступности и нагрузке.\n\n2. **Конфигурация репликационных наборов (Replica Sets)**: Создайте репликационные наборы для обеспечения отказоустойчивости и репликации данных.\n\n3. **Шардинг (Sharding)**: Разделите данные на шарды для равномерного распределения нагрузки и увеличения производительности. Учитывайте ключи шардирования и особенности доступа к данным.\n\n4. **Настройка мониторинга и бэкапов**: Установите системы мониторинга для отслеживания состояния кластера и настройте регулярные бэкапы для обеспечения безопасности данных.\n\n5. **Оптимизация запросов и индексов**: Создайте необходимые индексы для оптимизации запросов и обеспечения быстрого доступа к данным.\n\nПроектирование кластера MongoDB требует глубокого понимания архитектуры приложения и требований к его работе."
      },
      {
        "id": 35,
        "question": "Для чего используют MongoDB Aggregation framework?",
        "answer": "MongoDB Aggregation Framework предоставляет мощные инструменты для анализа, обработки и агрегации данных в MongoDB. Основные цели использования Aggregation Framework включают:\n\n- **Агрегация данных**: Выполнение сложных операций агрегации, таких как группировка, фильтрация, сортировка и вычисление статистических данных на основе множества документов.\n\n- **Преобразование данных**: Трансформация и обработка данных в MongoDB, включая добавление новых полей, преобразование типов данных и вычисление выражений.\n\n- **Вычисление выражений и функций**: Использование встроенных и пользовательских функций для выполнения сложных вычислений и операций над данными.\n\n- **Аналитика и отчетность**: Подготовка данных для аналитики, отчетности и представления информации в удобном формате.\n\nMongoDB Aggregation Framework позволяет эффективно обрабатывать данные на стороне базы данных, что способствует улучшению производительности и производительности приложений."
      },
      {
        "id": 36,
        "question": "Расскажите о GraphQL.",
        "answer": "GraphQL - это язык запросов для API, разработанный Facebook для работы с клиентскими приложениями. Основные особенности GraphQL:\n\n- **Гибкость запросов**: Клиенты могут запрашивать только необходимые данные с помощью одного запроса, что уменьшает количество обращений к серверу и улучшает производительность.\n\n- **Типизированная система**: GraphQL определяет схему данных с типами и возможными запросами, что облегчает разработку и документирование API.\n\n- **Разрешение запросов (Resolvers)**: GraphQL использует разрешители для определения логики получения данных из различных источников, таких как базы данных или внешние API.\n\n- **Оптимизация сетевого трафика**: Поскольку GraphQL позволяет клиентам выбирать поля в запросах, это минимизирует передачу лишних данных по сети.\n\n- **Инструменты разработчика**: GraphQL предоставляет инструменты для анализа запросов, проверки схемы и управления версиями API.\n\nGraphQL стал популярным инструментом для разработки API благодаря его гибкости и возможности точно задавать данные, необходимые клиентским приложениям."
      }
    ]
  },
  {
    "position": "senior",
    "topic": "tools",
    "questions": [
      {
        "id": 37,
        "question": "Можете ли вы описать суть методологии git flow в двух словах?",
        "answer": "Git flow - это методология ветвления для работы с Git, которая предлагает строгие правила использования веток для разработки, релизов и исправлений."
      },
      {
        "id": 38,
        "question": "Что означает требование делать squash commits во время rebase?",
        "answer": "Squash commits во время rebase означает объединение нескольких коммитов в один для улучшения читаемости истории коммитов. Это помогает сохранять чистоту истории перед интеграцией изменений в основную ветку."
      },
      {
        "id": 39,
        "question": "Каково ваше мнение об альтернативных системы контроля версий (Version Control System)?",
        "answer": "Альтернативные системы контроля версий, такие как Mercurial, SVN (Subversion), Perforce, имеют свои особенности и применение в различных сценариях разработки. Выбор между ними зависит от требований проекта, командных предпочтений и интеграции с другими инструментами."
      },
      {
        "id": 40,
        "question": "Какие конвенции знаете и используете для git?",
        "answer": "Для работы с Git используются различные конвенции, такие как:\n\n- **Комментарии к коммитам**: Использование осмысленных и информативных сообщений коммитов в формате, понятном всей команде.\n\n- **Именование веток**: Использование понятных имен веток, соответствующих их назначению (например, feature/my-feature, bugfix/issue-123).\n\n- **Использование тегов**: Добавление аннотированных тегов к релизным коммитам для обозначения версий приложения.\n\n- **Управление ветвлением**: Соблюдение методологий ветвления, таких как Git Flow или GitHub Flow, для эффективного управления разработкой и релизами."
      },
      {
        "id": 41,
        "question": "Расскажите о своем опыте использования / внедрения CI / CD.",
        "answer": "Мой опыт включает использование и внедрение CI/CD для автоматизации процессов разработки и доставки программного обеспечения. Это включает настройку средств непрерывной интеграции (CI), таких как Jenkins, GitLab CI, GitHub Actions, и настройку непрерывной доставки (CD) для автоматической поставки изменений в продакшн или тестовые среды."
      },
      {
        "id": 42,
        "question": "Необходимо настроить деплой проекту на несколько сред. Расскажите, как бы вы построили процесс? Какие инструменты использовали бы?",
        "answer": "Для настройки деплоя проекта на несколько сред (например, разработка, тестирование, продакшн) я бы построил следующий процесс:\n\n1. **Выбор инструментов CI/CD**: Использование платформы для непрерывной интеграции и доставки, такой как Jenkins, GitLab CI/CD, или GitHub Actions, в зависимости от требований проекта.\n\n2. **Настройка пайплайнов CI/CD**: Создание пайплайнов для автоматизации сборки, тестирования и деплоя приложения на различные среды.\n\n3. **Конфигурация окружений**: Настройка окружений (development, staging, production) с учетом специфики каждой среды, включая параметры конфигурации и доступа к ресурсам.\n\n4. **Управление версиями и релизами**: Использование инструментов для управления версиями и релизами приложения, таких как Git тегирование или специализированные системы управления версиями.\n\n5. **Мониторинг и отчетность**: Настройка системы мониторинга для отслеживания состояния приложения после каждого деплоя и создание отчетов о процессах CI/CD.\n\nЭтот процесс позволит автоматизировать доставку изменений в различные среды, ускорить развертывание и улучшить качество разработки."
      }
    ]
  },
  {
    "position": "senior",
    "topic": "practical",
    "questions": [
      {
        "id": 43,
        "question": "Реализуйте асинхронный метод filter для Array (должны работать await).",
        "answer": "Для реализации асинхронного метода filter для Array можно воспользоваться функцией, которая будет фильтровать элементы массива асинхронно. Вот пример реализации:\n\n```javascript\nArray.prototype.asyncFilter = async function(callback) {\n  const filtered = [];\n  for (let i = 0; i < this.length; i++) {\n    const result = await callback(this[i], i, this);\n    if (result) {\n      filtered.push(this[i]);\n    }\n  }\n  return filtered;\n};\n\n// Пример использования\nconst filteredArray = await [1, 2, 3, 4].asyncFilter(async (item) => {\n  // Асинхронная проверка условия\n  return item % 2 === 0;\n});\nconsole.log(filteredArray); // Выведет [2, 4]\n```\n\nЭтот метод позволяет асинхронно фильтровать массив, используя await для ожидания выполнения каждой асинхронной операции."
      },
      {
        "id": 44,
        "question": "Реализуйте функцию reduce при помощи рекурсии.",
        "answer": "Функция reduce, реализованная с помощью рекурсии, может выглядеть следующим образом:\n\n```javascript\nfunction recursiveReduce(arr, callback, initialValue) {\n  function reduceHelper(arr, callback, accumulator, currentIndex) {\n    if (currentIndex >= arr.length) {\n      return accumulator;\n    }\n    const currentValue = arr[currentIndex];\n    accumulator = callback(accumulator, currentValue, currentIndex, arr);\n    return reduceHelper(arr, callback, accumulator, currentIndex + 1);\n  }\n  return reduceHelper(arr, callback, initialValue, 0);\n}\n\n// Пример использования\nconst sum = recursiveReduce([1, 2, 3, 4], (acc, curr) => acc + curr, 0);\nconsole.log(sum); // Выведет 10\n```\n\nЭта функция реализует рекурсивный подход к методу reduce, который последовательно применяет функцию callback к элементам массива, начиная с initialValue."
      },
      {
        "id": 45,
        "question": "Как можно было бы сделать toggle-компонент, как в iPhone, без использования JS?",
        "answer": "Для создания toggle-компонента, как в iPhone, без использования JavaScript, можно воспользоваться HTML и CSS. Вот пример такого компонента:\n\n```html\n<input type=\"checkbox\" id=\"toggle\" />\n<label for=\"toggle\"></label>\n```\n\n```css\ninput[type=\"checkbox\"] {\n  display: none;\n}\n\nlabel {\n  display: block;\n  width: 50px;\n  height: 30px;\n  background-color: gray;\n  border-radius: 15px;\n  position: relative;\n  cursor: pointer;\n}\n\ninput[type=\"checkbox\"]:checked + label {\n  background-color: blue;\n}\n\nlabel::before {\n  content: '';\n  position: absolute;\n  top: 3px;\n  left: 3px;\n  width: 24px;\n  height: 24px;\n  background-color: white;\n  border-radius: 50%;\n  transition: transform 0.3s ease;\n}\n\ninput[type=\"checkbox\"]:checked + label::before {\n  transform: translateX(20px);\n}\n```\n\nЭтот код создает toggle-компонент с использованием чекбокса и метки, стилизованный CSS. При клике на метку чекбокс переключается, что позволяет изменять визуальное состояние компонента без использования JavaScript."
      }
    ]
  }
]