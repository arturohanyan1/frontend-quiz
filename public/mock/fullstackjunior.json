[
  {
    "position": "junior",
    "topic": "general",
    "questions": [
      {
        "id": 1,
        "question": "Какие методы HTTP-запросов вы знаете?",
        "answer": "GET: для получения данных, POST: для отправки данных, PUT: для обновления данных, DELETE: для удаления данных, PATCH: для частичного обновления данных, OPTIONS: для получения поддерживаемых методов, HEAD: для получения заголовков ответа без тела."
      },
      {
        "id": 2,
        "question": "Какие версии HTTP-протокола вам известны?",
        "answer": "HTTP/1.0: начальная версия HTTP, HTTP/1.1: улучшенная версия с поддержкой персистентных соединений и кэширования, HTTP/2: версия с улучшенной производительностью и параллелизмом, HTTP/3: версия на основе протокола QUIC с улучшенной безопасностью и скоростью."
      },
      {
        "id": 3,
        "question": "Какие знаете коды ответа (состояния) HTTP?",
        "answer": "200 OK: успешный запрос, 301 Moved Permanently: ресурс перемещен на новый URL, 302 Found: временное перемещение ресурса, 400 Bad Request: неправильный запрос, 401 Unauthorized: требуется аутентификация, 403 Forbidden: доступ запрещен, 404 Not Found: ресурс не найден, 500 Internal Server Error: внутренняя ошибка сервера."
      },
      {
        "id": 4,
        "question": "Что такое Cross-Origin Resource Sharing? Как устранить проблемы с CORS?",
        "answer": "CORS (Cross-Origin Resource Sharing) — это механизм, позволяющий веб-приложениям запрашивать ресурсы с другого домена. Проблемы с CORS можно устранить, настроив сервер для отправки правильных заголовков, таких как Access-Control-Allow-Origin, и используя прокси-серверы."
      },
      {
        "id": 5,
        "question": "Что такое cookie?",
        "answer": "Cookie — это небольшой фрагмент данных, отправляемый сервером и хранящийся на стороне клиента. Он используется для сохранения состояния пользователя и управления сессиями."
      },
      {
        "id": 6,
        "question": "Какой максимальный размер cookie?",
        "answer": "Максимальный размер одного cookie составляет примерно 4096 байт, но это может зависеть от конкретного браузера и его версии."
      },
      {
        "id": 7,
        "question": "Что означает директива use strict?",
        "answer": "'use strict' — это директива, которая вводит строгий режим в JavaScript. Она помогает выявлять потенциальные ошибки и улучшать производительность кода, запрещая использование небезопасных функций и синтаксиса."
      },
      {
        "id": 8,
        "question": "Чем JS отличается при работе на front-end и back-end?",
        "answer": "На фронтенде JavaScript используется для создания интерактивных пользовательских интерфейсов и динамических веб-страниц. На бэкенде (например, с использованием Node.js) JavaScript используется для создания серверных приложений, обработки запросов и управления базами данных."
      },
      {
        "id": 9,
        "question": "Что такое статическая и динамическая типизации?",
        "answer": "Статическая типизация означает, что типы данных определяются на этапе компиляции (например, в языках Java или C++). Динамическая типизация означает, что типы данных определяются во время выполнения программы (например, в JavaScript или Python)."
      },
      {
        "id": 10,
        "question": "Как клиент взаимодействует с сервером?",
        "answer": "Клиент взаимодействует с сервером через HTTP-запросы. Клиент отправляет запросы (GET, POST, и т.д.) на сервер, а сервер обрабатывает эти запросы и отправляет ответы обратно клиенту."
      },
      {
        "id": 11,
        "question": "Что такое REST?",
        "answer": "REST (Representational State Transfer) — это архитектурный стиль для создания веб-сервисов. Он использует стандартные HTTP-методы (GET, POST, PUT, DELETE) и принципы, такие как статeless взаимодействие и использование ресурсов через URL."
      },
      {
        "id": 12,
        "question": "Объяснить понятие мутабельность/иммутабельность? Какие типы являются мутабельными и наоборот?",
        "answer": "Мутабельность означает возможность изменения объекта после его создания. В JavaScript объекты и массивы являются мутабельными. Иммутабельность означает невозможность изменения объекта после его создания. Примитивные типы данных (например, строки, числа) в JavaScript являются иммутабельными."
      },
      {
        "id": 13,
        "question": "Как искать ошибки в коде? Используете ли вы дебаггер?",
        "answer": "Ошибки в коде можно искать с помощью консольных сообщений (console.log), использования отладочных инструментов в браузере (debugger), написания тестов и применения статических анализаторов кода (например, ESLint)."
      },
      {
        "id": 14,
        "question": "Каких известных людей из мира JS знаете?",
        "answer": "Брендан Эйх (создатель JavaScript), Дуглас Крокфорд (разработчик JSON и автор 'JavaScript: The Good Parts'), Райан Дал (создатель Node.js), Джон Резиг (создатель jQuery)."
      }
    ]
  },
  {
    "position": "junior",
    "topic": "jsCore",
    "questions": [
      {
        "id": 15,
        "question": "Какие существуют типы данных в JS?",
        "answer": "Примитивные типы: String, Number, Boolean, Null, Undefined, Symbol, BigInt. Ссылочные типы: Object, Array, Function, Date, RegExp, Map, Set, WeakMap, WeakSet."
      },
      {
        "id": 16,
        "question": "Как проверить, является ли объект массивом?",
        "answer": "Используйте метод Array.isArray(obj)."
      },
      {
        "id": 17,
        "question": "Как проверить, является ли число конечным?",
        "answer": "Используйте метод Number.isFinite(value)."
      },
      {
        "id": 18,
        "question": "Как проверить, что переменная равна NaN?",
        "answer": "Используйте метод Number.isNaN(value)."
      },
      {
        "id": 19,
        "question": "Чем отличается поведение isNaN() и Number.isNaN()?",
        "answer": "isNaN() преобразует аргумент к числу перед проверкой, что может привести к ложноположительным результатам. Number.isNaN() не преобразует аргумент и проверяет только значения типа Number."
      },
      {
        "id": 20,
        "question": "Сравните ключевые слова var, let, const.",
        "answer": "var: глобальная или функциональная область видимости, может быть переназначена и повторно объявлена; let: блочная область видимости, может быть переназначена, но не повторно объявлена; const: блочная область видимости, не может быть переназначена или повторно объявлена."
      },
      {
        "id": 21,
        "question": "Что такое область видимости?",
        "answer": "Область видимости — это контекст, в котором переменные и функции доступны. В JavaScript существует глобальная, функциональная и блочная области видимости."
      },
      {
        "id": 22,
        "question": "Что такое деструктуризация?",
        "answer": "Деструктуризация — это синтаксис, который позволяет распаковывать значения из массивов или свойства из объектов в отдельные переменные."
      },
      {
        "id": 23,
        "question": "Для чего предназначены методы setTimeout и setInterval?",
        "answer": "setTimeout: вызывает функцию один раз через определенное время. setInterval: вызывает функцию повторно через заданные промежутки времени."
      },
      {
        "id": 24,
        "question": "Сравните подходы работы с асинхронным кодом: сallbacks vs promises vs async / await.",
        "answer": "Callbacks: функции, переданные в другие функции в качестве аргументов для выполнения после завершения операции. Promises: объекты, представляющие завершение или неудачу асинхронной операции, более удобные и читаемые чем callbacks. async/await: синтаксический сахар для работы с промисами, позволяющий писать асинхронный код в синхронном стиле."
      },
      {
        "id": 25,
        "question": "Можно ли записывать новые свойства / функции в прототипы стандартных классов (Array, Object и т. д.)? Почему нет? В каких случаях это делать можно? Как обезопасить себя, если нужно расширить прототип?",
        "answer": "Записывать новые свойства в прототипы стандартных классов можно, но это может привести к конфликтам и поломкам в коде, особенно при использовании сторонних библиотек. Делать это можно только в крайних случаях, при этом следует использовать Object.defineProperty() с установкой enumerable в false, чтобы минимизировать риски."
      },
      {
        "id": 26,
        "question": "Назовите методы массивов, какие помните, и скажите, для чего они нужны.",
        "answer": "push: добавляет элемент в конец массива; pop: удаляет последний элемент из массива; shift: удаляет первый элемент из массива; unshift: добавляет элемент в начало массива; map: создаёт новый массив, вызывая функцию для каждого элемента; filter: создаёт новый массив с элементами, прошедшими проверку функции; reduce: применяет функцию к аккумулятору и каждому элементу массива (слева направо) и сводит к одному значению; forEach: выполняет функцию для каждого элемента массива."
      },
      {
        "id": 27,
        "question": "Какие методы перебора массива знаете? В чем их отличие?",
        "answer": "forEach: выполняет функцию для каждого элемента массива, не возвращает новый массив; map: создаёт новый массив, вызывая функцию для каждого элемента; filter: создаёт новый массив с элементами, прошедшими проверку функции; reduce: применяет функцию к аккумулятору и каждому элементу массива и сводит к одному значению."
      },
      {
        "id": 28,
        "question": "Как работают операторы присваивания / сравнения / строчные / арифметические / битовые и т. д.?",
        "answer": "Операторы присваивания ( =, +=, -=, и т.д.): присваивают значение переменной; операторы сравнения (==, ===, !=, !==, >, <, и т.д.): сравнивают два значения и возвращают true или false; строчные операторы (+): объединяют строки; арифметические операторы (+, -, *, /, %): выполняют математические операции; битовые операторы (&, |, ^, ~, <<, >>, >>>): выполняют операции над битами чисел."
      },
      {
        "id": 29,
        "question": "Опишите назначение и принципы работы с коллекциями Map и Set.",
        "answer": "Map: коллекция, хранящая пары ключ-значение, где ключи могут быть любого типа. Методы: set, get, delete, has, clear. Set: коллекция уникальных значений, где каждое значение может появляться только один раз. Методы: add, delete, has, clear."
      },
      {
        "id": 30,
        "question": "Что означает глубокая (deep) и поверхностная (shallow) копия объекта? Как сделать каждую из них?",
        "answer": "Поверхностная копия: копирует только верхний уровень объекта, вложенные объекты остаются ссылками (Object.assign, spread оператор). Глубокая копия: копирует весь объект вместе со всеми вложенными объектами (рекурсивный метод, JSON.parse(JSON.stringify(obj)), библиотеки, такие как lodash)."
      }
    ]
  },
  {
    "position": "junior",
    "topic": "functions",
    "questions": [
      {
        "id": 31,
        "question": "Какая разница между декларацией функции (function declaration) и функциональным выражением (function expression)?",
        "answer": "Function declaration (декларация функции) объявляется с ключевым словом function и может быть вызвана до своего объявления благодаря hoisting. Function expression (функциональное выражение) создаётся внутри выражения (например, присваивания переменной) и не поднимается (не подвергается hoisting), поэтому может быть вызвано только после своего объявления."
      },
      {
        "id": 32,
        "question": "Что такое анонимная функция?",
        "answer": "Анонимная функция — это функция без имени. Она часто используется как аргумент при вызове других функций или как значение переменной. Например, function() { return 'Hello, world!'; }."
      },
      {
        "id": 33,
        "question": "Расскажите о стрелочных функциях (arrow function). В чем заключаются отличия стрелочных функций от обычных?",
        "answer": "Стрелочные функции — это сокращенный синтаксис для создания функций. Основные отличия: не имеют своего контекста (this), не имеют arguments объекта, не могут быть использованы как конструкторы (нельзя использовать с new). Пример: const add = (a, b) => a + b."
      },
      {
        "id": 34,
        "question": "Что такое и для чего используют IIFE (Immediately Invoked Function Expression)?",
        "answer": "IIFE (Immediately Invoked Function Expression) — это функция, которая вызывается сразу после своего создания. Используется для создания локальной области видимости, чтобы избежать загрязнения глобальной области. Пример: (function() { console.log('IIFE'); })();"
      },
      {
        "id": 35,
        "question": "Что такое hoisting, как он работает для переменных и функций?",
        "answer": "Hoisting (поднятие) — это поведение JavaScript, при котором объявления переменных и функций поднимаются в начало их области видимости. Функции (function declarations) поднимаются полностью, а объявления переменных (var) поднимаются без их инициализации. let и const также поднимаются, но не инициализируются."
      },
      {
        "id": 36,
        "question": "Что такое замыкание (closure) и какие сценарии его использования?",
        "answer": "Замыкание — это функция, которая имеет доступ к переменным из своей внешней (содержащей) функции даже после того, как эта внешняя функция завершила выполнение. Замыкания часто используются для создания приватных переменных и функций, а также для реализации функций с состоянием."
      },
      {
        "id": 37,
        "question": "Как вы понимаете замыкания? Что будет выведено в консоли в этом случае?\n\nvar f = function() {\n\n  console.log(1);\n\n}\n\nvar execute = function(f) {\n\n  setTimeout(f, 1000);\n\n}\n\nexecute(f); // что выведет в консоль и почему\n\nf = function() {\n\n  console.log(2);\n\n}",
        "answer": "В данном случае в консоли будет выведено 2. Когда функция передается в setTimeout, она сохраняет ссылку на переменную f. На момент выполнения функции по таймеру переменная f уже будет указывать на новую функцию, которая выводит 2."
      },
      {
        "id": 38,
        "question": "Что такое рекурсия?",
        "answer": "Рекурсия — это способ определения функции, при котором функция вызывает саму себя. Рекурсия часто используется для решения задач, которые можно разбить на более мелкие однотипные подзадачи. Важно иметь базовый случай, чтобы избежать бесконечной рекурсии."
      },
      {
        "id": 39,
        "question": "Что означает ключевое слово this?",
        "answer": "this — это ключевое слово в JavaScript, которое указывает на текущий контекст выполнения. В глобальной области видимости this ссылается на глобальный объект (window в браузере), внутри методов объекта this ссылается на объект, внутри функции — зависит от способа вызова функции (обычно undefined в строгом режиме)."
      },
      {
        "id": 40,
        "question": "Что такое потеря контекста, когда происходит и как ее предотвратить?",
        "answer": "Потеря контекста происходит, когда значение this изменяется непреднамеренно. Это может случиться при передаче метода объекта в качестве колбэка или при использовании функций высшего порядка. Предотвратить потерю контекста можно с помощью методов bind, call, apply или стрелочных функций, которые сохраняют контекст родительской функции."
      },
      {
        "id": 41,
        "question": "Методы функций bind / call / apply - зачем и в чем разница?",
        "answer": "call и apply вызывают функцию с указанным this и переданными аргументами. Разница в том, что call принимает аргументы через запятую, а apply — в виде массива. bind возвращает новую функцию с указанным this и фиксированными аргументами, но не вызывает её сразу."
      }
    ]
  },
  {
    "position": "junior",
    "topic": "frontend",
    "questions": [
      {
        "id": 42,
        "question": "Что такое DOM?",
        "answer": "DOM (Document Object Model) — это объектная модель документа, которая представляет структуру HTML или XML документа в виде дерева. Каждый элемент документа представлен как объект (узел), который можно программно изменять, добавлять или удалять. DOM позволяет взаимодействовать с содержимым веб-страницы через JavaScript."
      },
      {
        "id": 43,
        "question": "Сравните атрибуты подключения скрипта async и defer в HTML-документе.",
        "answer": "Атрибут async загружает скрипт асинхронно и выполняет его сразу после загрузки, не дожидаясь загрузки всей страницы. Атрибут defer также загружает скрипт асинхронно, но выполняет его только после полной загрузки и парсинга HTML-документа. Оба атрибута используются для улучшения производительности загрузки страницы."
      },
      {
        "id": 44,
        "question": "Какая разница между свойствами HTML-элементов innerHTML и innerText?",
        "answer": "innerHTML возвращает или устанавливает HTML-содержимое элемента, включая HTML-теги. innerText возвращает или устанавливает текстовое содержимое элемента, исключая HTML-теги и учитывая стили (например, скрытые элементы не будут включены в innerText)."
      },
      {
        "id": 45,
        "question": "Опишите процесс всплытия (bubbling) событий в DOM.",
        "answer": "Всплытие событий (event bubbling) — это процесс, при котором событие сначала обрабатывается на самом вложенном элементе (target), а затем последовательно всплывает вверх по дереву DOM к родительским элементам, вызывая обработчики событий на каждом уровне. Это позволяет обрабатывать события на родительских элементах."
      },
      {
        "id": 46,
        "question": "Как остановить всплытие (bubbling) события?",
        "answer": "Для остановки всплытия события используется метод stopPropagation() объекта Event. Вызов этого метода в обработчике события предотвращает дальнейшее распространение события вверх по дереву DOM."
      },
      {
        "id": 47,
        "question": "Как остановить дефолтную обработку события?",
        "answer": "Для остановки дефолтной обработки события используется метод preventDefault() объекта Event. Этот метод предотвращает выполнение стандартного действия, ассоциированного с событием (например, переход по ссылке при клике)."
      },
      {
        "id": 48,
        "question": "Чему равен this в обработчике событий (event handler)?",
        "answer": "В обработчике событий this ссылается на элемент, на котором было вызвано событие. Например, если событие клика привязано к кнопке, this будет ссылаться на эту кнопку."
      },
      {
        "id": 49,
        "question": "Что такое LocalStorage и SessionStorage? Какой максимальный размер LocalStorage?",
        "answer": "LocalStorage и SessionStorage — это веб-хранилища, которые позволяют сохранять данные в браузере. LocalStorage сохраняет данные без срока действия (пока пользователь не очистит хранилище вручную), а SessionStorage сохраняет данные только на время текущей сессии (до закрытия вкладки). Максимальный размер LocalStorage составляет примерно 5 МБ на домен."
      },
      {
        "id": 50,
        "question": "Как получить высоту блока? Его положение относительно границ документа?",
        "answer": "Для получения высоты блока можно использовать свойства clientHeight, offsetHeight или getBoundingClientRect().height. Для получения положения блока относительно границ документа можно использовать метод getBoundingClientRect(), который возвращает объект с координатами элемента относительно окна, и затем добавить значение scrollY и scrollX для получения координат относительно документа."
      },
      {
        "id": 51,
        "question": "Что такое webpack?",
        "answer": "Webpack — это популярный модульный сборщик для JavaScript приложений. Он позволяет объединять различные модули в единый бандл, поддерживает обработку и транспиляцию файлов (например, CSS, изображений, TypeScript), а также обеспечивает оптимизацию кода (минификация, tree shaking) для повышения производительности."
      },
      {
        "id": 52,
        "question": "Чем отличается dev-сборник от prod?",
        "answer": "Dev-сборник (development build) предназначен для разработки. Он включает исходные карты (source maps) для отладки, более подробные сообщения об ошибках и не минифицирует код для удобства чтения. Prod-сборник (production build) предназначен для развёртывания на боевых серверах. Он минифицирован, оптимизирован и не включает исходные карты для уменьшения размера и повышения производительности."
      }
    ]
  },
  {
    "position": "junior",
    "topic": "css",
    "questions": [
      {
        "id": 53,
        "question": "Что такое блочная модель CSS?",
        "answer": "Блочная модель CSS описывает как HTML элементы отображаются и взаимодействуют в браузере. Каждый элемент представлен как прямоугольник, состоящий из четырех частей: контент, внутренний отступ (padding), граница (border) и внешний отступ (margin)."
      },
      {
        "id": 54,
        "question": "Какие способы центрирования блочного контента по горизонтали и вертикали знаете?",
        "answer": "Горизонтальное центрирование: margin: 0 auto; text-align: center; использование flexbox: justify-content: center. Вертикальное центрирование: использование flexbox: align-items: center; использование CSS Grid: align-items: center; использование позиционирования и трансформации: position: absolute; top: 50%; transform: translateY(-50%)."
      },
      {
        "id": 55,
        "question": "Какие подходы в верстке вам известны (float, flex, grid, etc.)?",
        "answer": "Существуют несколько подходов в верстке: float — старый метод создания макетов, с плавающими элементами; flexbox — современный метод, обеспечивающий гибкое расположение элементов в одном измерении (горизонтально или вертикально); CSS Grid — мощный инструмент для создания макетов в двух измерениях (по горизонтали и вертикали); inline-block — метод, позволяющий размещать блоки в строку, как текстовые элементы; таблицы (table) — устаревший метод для создания макетов, используется в основном для табличных данных."
      },
      {
        "id": 56,
        "question": "Как сделать приложение responsive?",
        "answer": "Для создания responsive (адаптивного) приложения используются медиа-запросы (media queries) для изменения стилей в зависимости от размера экрана; flexbox и CSS Grid для создания гибких и адаптивных макетов; относительные единицы измерения (проценты, em, rem) вместо абсолютных (px); использование viewport units (vw, vh); адаптивные изображения (srcset, sizes); mobile-first подход — сначала создаются стили для мобильных устройств, затем для более крупных экранов."
      },
      {
        "id": 57,
        "question": "Какие есть принципы семантической верстки?",
        "answer": "Семантическая верстка использует HTML-теги, которые точно описывают содержание и структуру документа. Принципы включают: использование правильных тегов (article, section, header, footer, nav, aside и т.д.) для описания структуры; использование тегов заголовков (h1, h2, и т.д.) для организации содержимого; использование тегов для цитат (blockquote, q), списков (ul, ol, li), таблиц (table, th, tr, td); атрибуты aria для улучшения доступности контента."
      },
      {
        "id": 58,
        "question": "Зачем нужны префиксы для некоторых CSS-свойств (-webkit-, -moz- и т. д.)?",
        "answer": "Префиксы используются для обеспечения совместимости новых CSS-свойств в разных браузерах до их окончательной стандартизации. Они позволяют разработчикам использовать новые возможности CSS, даже если они ещё не полностью поддерживаются всеми браузерами."
      },
      {
        "id": 59,
        "question": "Как упростить написание кросс-браузерных стилей?",
        "answer": "Для упрощения написания кросс-браузерных стилей можно использовать CSS препроцессоры (Sass, LESS); CSS автопрефиксер (Autoprefixer) для автоматического добавления префиксов; normalize.css или reset.css для сброса или нормализации стилей по умолчанию; современные фреймворки и библиотеки (Bootstrap, Foundation); тестирование стилей в разных браузерах и на разных устройствах; использование feature queries (@supports) для проверки поддержки CSS-свойств."
      },
      {
        "id": 60,
        "question": "Практические задачи: прокомментировать и исправить пример плохого CSS или HTML.",
        "answer": "Пример плохого CSS:\n```css\n.bad-style {\n  font-size: 18px;\n  color: blue;\n  margin: 10px;\n  padding: 5px;\n  border: 1px solid black;\n  background-color: yellow;\n}\n```\n\nКомментарий и исправление:\n\n1. Не использованы семантические имена классов.\n2. Нет комментариев для объяснения назначения стилей.\n3. Стили не организованы.\n\nИсправленный CSS:\n```css\n.primary-button {\n  font-size: 1rem;\n  color: #007bff;\n  margin: 0.625rem;\n  padding: 0.3125rem;\n  border: 1px solid #000;\n  background-color: #ff0;\n}\n```\n\nИспользование относительных единиц и семантических имен улучшает код."
      },
      {
        "id": 61,
        "question": "Что такое CSS-препроцессоры? С какими работали? Что нового они приносят в стандартный CSS?",
        "answer": "CSS-препроцессоры (Sass, LESS, Stylus) добавляют дополнительные возможности к стандартному CSS, такие как переменные, вложенные правила, миксины, функции и операции. Они упрощают написание и поддержку CSS, делая код более модульным и удобочитаемым. Препроцессоры компилируются в обычный CSS, который понимают браузеры."
      }
    ]
  },
  {
    "position": "junior",
    "topic": "angular",
    "questions": [
      {
        "id": 62,
        "question": "Перечислите основные компоненты фреймворка (модуль, роут, директива и т .п.).",
        "answer": "Основные компоненты фреймворка включают: модули (modules) для организации кода и функциональности; компоненты (components) для создания пользовательских интерфейсов; директивы (directives) для изменения поведения элементов DOM; маршруты (routes) для навигации между страницами; сервисы (services) для выполнения бизнес-логики и взаимодействия с API; пайпы (pipes) для преобразования данных в шаблонах."
      },
      {
        "id": 63,
        "question": "В чем разница между компонентом и директивой?",
        "answer": "Компонент — это директива с шаблоном, который определяет пользовательский интерфейс. Директива — это класс, который изменяет поведение или внешний вид элементов DOM, но не обязательно имеет шаблон."
      },
      {
        "id": 64,
        "question": "Расскажите о жизненном цикле компонента.",
        "answer": "Жизненный цикл компонента включает этапы создания, изменения и уничтожения. Основные этапы: инициализация (ngOnInit), изменение данных входных параметров (ngOnChanges), проверка изменений (ngDoCheck), завершение обновления представления (ngAfterContentInit, ngAfterContentChecked, ngAfterViewInit, ngAfterViewChecked), уничтожение (ngOnDestroy)."
      },
      {
        "id": 65,
        "question": "Перечислите часто используемые хуки жизненного цикла компонента и расскажите, для чего они нужны?",
        "answer": "ngOnInit — выполняется один раз после инициализации компонента; ngOnChanges — вызывается при изменении входных данных; ngDoCheck — вызывается при проверке изменений; ngAfterContentInit — вызывается после вставки контента в представление; ngAfterContentChecked — вызывается после каждой проверки контента; ngAfterViewInit — вызывается после инициализации представления; ngAfterViewChecked — вызывается после каждой проверки представления; ngOnDestroy — вызывается перед уничтожением компонента."
      },
      {
        "id": 66,
        "question": "В чем разница между конструктором и ngOnInit-хуком?",
        "answer": "Конструктор используется для инициализации зависимостей и создания экземпляра класса компонента. ngOnInit используется для выполнения логики инициализации, которая требует завершения создания компонента и его зависимостей."
      },
      {
        "id": 67,
        "question": "Как защитить роут от несанкционированного доступа? Какие механизмы предоставляет для этого фреймворк?",
        "answer": "Для защиты маршрутов используются Guards (CanActivate, CanDeactivate, CanLoad, CanActivateChild), которые проверяют условия доступа к маршрутам. Эти Guards могут выполнять проверку аутентификации, авторизации или других условий перед разрешением перехода к маршруту."
      },
      {
        "id": 68,
        "question": "Что такое Lazy loading, как и для чего используется?",
        "answer": "Lazy loading — это отложенная загрузка модулей или компонентов, которая происходит только при необходимости (например, при переходе к определенному маршруту). Это улучшает производительность приложения, уменьшая начальный размер бандла и ускоряя загрузку страниц."
      },
      {
        "id": 69,
        "question": "Какое назначение RouterOutlet?",
        "answer": "RouterOutlet — это директива, которая указывает Angular, где отображать компоненты, соответствующие активным маршрутам. Это точка вставки для компонентов, отображаемых при навигации по приложению."
      },
      {
        "id": 70,
        "question": "Как компоненты могут взаимодействовать друг с другом?",
        "answer": "Компоненты могут взаимодействовать через: входные (@Input) и выходные (@Output) параметры; общие сервисы для обмена данными; использование родительских и дочерних компонентов для передачи данных и вызова методов; использование RxJS Subjects для обмена данными и событий."
      },
      {
        "id": 71,
        "question": "Как создать two-way binding свойство для компонента?",
        "answer": "Для создания two-way binding свойства используется комбинация @Input и @Output параметров. @Input параметр используется для получения значения, а @Output с EventEmitter для отправки изменений обратно. Декоратор @Input декорирует свойство компонента, принимающее значение, а @Output — метод, который генерирует событие с новым значением."
      },
      {
        "id": 72,
        "question": "Какие типы форм у фреймворка? В каких случаях и что лучше использовать?",
        "answer": "Фреймворк предоставляет два типа форм: Template-driven forms, которые используют директивы в шаблонах для создания форм (подходящи для простых форм и быстрой разработки); Reactive forms, которые используют реактивные объекты и классы для создания форм (подходящи для сложных форм, требующих высокой гибкости и тестируемости)."
      },
      {
        "id": 73,
        "question": "Какие состояния у формы и как это можно применить?",
        "answer": "Состояния формы включают: pristine (форма не изменена), dirty (форма изменена), valid (форма валидна), invalid (форма невалидна), touched (элемент формы был посещен), untouched (элемент формы не был посещен). Эти состояния используются для валидации, отображения сообщений об ошибках и управления состоянием кнопок."
      },
      {
        "id": 74,
        "question": "Зачем нужны сервисы? Как с ними работать?",
        "answer": "Сервисы используются для инкапсуляции бизнес-логики и взаимодействия с API, а также для обмена данными между компонентами. Они регистрируются в инжекторе и могут быть внедрены в компоненты через конструктор с помощью механизма Dependency Injection."
      },
      {
        "id": 75,
        "question": "Что такое singleton-сервисы? Каково их назначение? Способ создания?",
        "answer": "Singleton-сервисы — это сервисы, которые существуют в единственном экземпляре в течение всего времени работы приложения. Они создаются и управляются Angular Dependency Injection и регистрируются в корневом модуле (providers: [ServiceName]) или с помощью декоратора @Injectable({ providedIn: 'root' })."
      },
      {
        "id": 76,
        "question": "Какие есть способы объявления сервисов?",
        "answer": "Сервисы могут быть объявлены: в секции providers модуля; в секции providers компонента; с использованием декоратора @Injectable({ providedIn: 'root' }) для автоматической регистрации в корневом модуле."
      },
      {
        "id": 77,
        "question": "Для чего нужны модули? Сколько их должно быть в проекте?",
        "answer": "Модули (NgModules) организуют код и функциональность приложения, делая его структурированным и модульным. Они позволяют разбивать приложение на логические части и повторно использовать их. Количество модулей зависит от размера и сложности проекта; рекомендуется создавать отдельные модули для функциональных областей и общих ресурсов."
      },
      {
        "id": 78,
        "question": "Зачем нужны общие модули (shared)?",
        "answer": "Общие модули (shared modules) содержат компоненты, директивы и пайпы, которые используются в нескольких местах приложения. Это позволяет избежать дублирования кода и облегчить его поддержку, обеспечивая централизованное место для общих ресурсов."
      },
      {
        "id": 79,
        "question": "Какие преимущества типизации в TypeScript?",
        "answer": "Типизация в TypeScript обеспечивает: обнаружение ошибок на этапе компиляции; улучшенную поддержку редакторов кода и автодополнения; явную документацию кода через типы; улучшенную читаемость и поддерживаемость кода; возможность использования интерфейсов и типовых параметров для создания более гибких и безопасных программных конструкций."
      },
      {
        "id": 80,
        "question": "Какие возможности TypeScript можно использовать для типизации (здесь имеются в виду интерфейсы, типы, enum и т. д.)?",
        "answer": "TypeScript предоставляет различные возможности для типизации: интерфейсы (interface) для определения контрактов объектов; типы (type) для создания алиасов типов и объединений; перечисления (enum) для определения наборов связанных значений; типовые параметры (generic) для создания обобщенных классов, функций и интерфейсов; модули (namespace) для организации кода и предотвращения конфликтов имен."
      },
      {
        "id": 81,
        "question": "Какая разница между интерфейсом и классом?",
        "answer": "Интерфейс описывает структуру объекта, определяя его свойства и методы, но не содержит реализации. Класс определяет как структуру, так и реализацию объекта, включая методы и свойства. Класс может реализовывать один или несколько интерфейсов."
      },
      {
        "id": 82,
        "question": "В чем разница между интерфейсом и абстрактным классом?",
        "answer": "Интерфейс определяет только сигнатуры методов и свойств без реализации. Абстрактный класс может содержать как абстрактные методы (без реализации), так и методы с реализацией. Классы могут наследоваться от одного абстрактного класса, но могут реализовывать несколько интерфейсов."
      },
      {
        "id": 83,
        "question": "Какая разница между интерфейсом и типом?",
        "answer": "Интерфейсы используются для определения структуры объектов, тогда как типы (type) могут использоваться для создания алиасов любых типов, включая объединения (union) и пересечения (intersection). Типы более гибкие и могут описывать более сложные конструкции, чем интерфейсы."
      },
      {
        "id": 84,
        "question": "Что такое RxJS? Как он используется во фреймворке? Какие компоненты фреймворка тесно связаны с ним?",
        "answer": "RxJS (Reactive Extensions for JavaScript) — библиотека для работы с асинхронными данными с использованием Observable-паттерна. В Angular RxJS используется для управления асинхронными операциями, такими как HTTP-запросы и события. RxJS тесно связан с HttpClient и FormControl, а также используется в сервисах и компонентах для обработки потоков данных."
      },
      {
        "id": 85,
        "question": "Чем отличаются Observable и Promise?",
        "answer": "Observable — это поток данных, который может генерировать несколько значений во времени и может быть отменен. Promise — это единичное значение, которое асинхронно возвращается и не может быть отменено. Observable предоставляет больше возможностей для управления асинхронными операциями и реактивного программирования."
      },
      {
        "id": 86,
        "question": "Для чего нужны Subjects? Какие типы Subjects существуют?",
        "answer": "Subjects в RxJS — это специальные Observable, которые позволяют мультикастинг (отправку данных нескольким подписчикам). Существуют разные типы Subjects: Subject, BehaviorSubject, ReplaySubject и AsyncSubject. BehaviorSubject хранит текущее значение и отправляет его новым подписчикам; ReplaySubject сохраняет историю значений и отправляет её новым подписчикам; AsyncSubject отправляет последнее значение только после завершения выполнения."
      },
      {
        "id": 87,
        "question": "Как сделать несколько последовательных запросов к API с помощью HTTP-сервиса и RxJS?",
        "answer": "Для выполнения нескольких последовательных запросов к API используются операторы RxJS, такие как concatMap, switchMap или mergeMap. Они позволяют управлять потоком данных и выполнять запросы последовательно, сохраняя порядок выполнения и обработки ответов."
      },
      {
        "id": 88,
        "question": "Какая разница между switchMap, concatMap, mergeMap?",
        "answer": "switchMap отменяет предыдущий запрос при получении нового значения; concatMap выполняет запросы последовательно, сохраняя порядок; mergeMap выполняет запросы параллельно, объединяя результаты."
      },
      {
        "id": 89,
        "question": "Как можно конфигурировать Angular-приложение?",
        "answer": "Angular-приложение можно конфигурировать с помощью environment-файлов для разных сред (development, production), использование injection tokens для настройки зависимостей, настройка роутинга и модулей через декораторы и параметры."
      },
      {
        "id": 90,
        "question": "Зачем нужны environment-файлы? Когда их лучше не использовать?",
        "answer": "Environment-файлы используются для хранения конфигурации приложения для разных сред (например, URL-адреса API, ключи и флаги). Их лучше не использовать для хранения чувствительной информации, такой как пароли или ключи безопасности, которые должны быть защищены другими методами."
      },
      {
        "id": 91,
        "question": "В чем разница между «умным» (smart) и «глупым» (dumb) компонентами? В каких случаях применяется каждый из них?",
        "answer": "«Умные» компоненты (smart) управляют состоянием приложения и бизнес-логикой, взаимодействуют с сервисами и API. «Глупые» компоненты (dumb) отвечают только за отображение данных и пользовательский интерфейс, получая данные через входные параметры. Использование «умных» компонентов позволяет разделить логику приложения и UI, улучшая модульность и тестируемость."
      },
      {
        "id": 92,
        "question": "В чем разница между NgForm, FormGroup и FormControl и как их применяют для построения форм?",
        "answer": "NgForm используется для создания шаблонных форм; FormGroup объединяет несколько FormControl в логическую группу; FormControl представляет отдельное поле формы. В реативных формах используется FormGroup и FormControl для построения и управления состоянием формы и её валидацией."
      },
      {
        "id": 93,
        "question": "Зачем нужен и как работает async pipe?",
        "answer": "Async pipe используется для автоматического подписывания и отписывания от Observable или Promise в шаблонах. Он упрощает управление асинхронными данными, автоматически обновляя шаблон при получении новых данных и освобождая ресурсы при уничтожении компонента."
      },
      {
        "id": 94,
        "question": "Как следить за развитием фреймворка? Каких известных людей, связанных с Angular, знаете / читаете?",
        "answer": "Следить за развитием фреймворка можно через официальные блоги, репозитории на GitHub, конференции и сообщества. Известные люди в сообществе Angular: Мишко Хевери (Misko Hevery), Брэд Грин (Brad Green), Виктор Савкин (Victor Savkin), Стивен Флюин (Stephen Fluin), Джон Папа (John Papa)."
      }
    ]
  },
  {
    "position": "junior",
    "topic": "react",
    "questions": [
      {
        "id": 95,
        "question": "Работали ли вы с классовыми компонентами? В чем их особенность?",
        "answer": "Да, классовые компоненты в React используют классы ES6 для определения компонентов. Основные особенности классовых компонентов включают использование жизненного цикла React (componentDidMount, componentDidUpdate и т. д.), возможность использования состояния (state), их способность хранить внутреннее состояние и использование метода render() для возвращения JSX."
      },
      {
        "id": 96,
        "question": "Какие данные лучше хранить в состоянии компонента, а какие передавать через пропсы?",
        "answer": "В состоянии компонента лучше хранить данные, которые могут изменяться в процессе работы компонента и влияют на его внутреннее состояние или отображение. Примеры включают данные, введенные пользователем в форме или текущее состояние загрузки данных. Пропсы (props) следует использовать для передачи данных от родительского компонента к дочернему. Это может быть информация о конфигурации, которая не меняется внутри компонента, или функции обратного вызова, которые компонент может вызывать при определенных событиях."
      },
      {
        "id": 97,
        "question": "Ознакомлены ли вы с хуками? В чем их преимущества? Приходилось ли делать свои и с какой целью?",
        "answer": "Да, хуки (hooks) в React представляют собой функции, позволяющие использовать состояние и другие возможности React без написания классов. Их преимущества включают улучшенную читаемость и повторное использование кода, более простую организацию логики компонента и возможность использования функциональных возможностей React в функциональных компонентах. Я использовал стандартные хуки, такие как useState и useEffect, и создавал свои хуки для абстрагирования логики, которая может повторно использоваться в разных компонентах."
      },
      {
        "id": 98,
        "question": "Знакомы ли вы с фрагментами и порталами? Зачем они нужны?",
        "answer": "Да, фрагменты (fragments) позволяют группировать дочерние элементы без добавления лишних узлов в DOM. Они полезны для возврата нескольких элементов из компонента без оборачивания их в дополнительный узел. Порталы (portals) используются для рендеринга дочерних элементов в DOM-узлы, которые находятся вне иерархии DOM-дерева родительского компонента. Это позволяет контролировать местоположение дочерних элементов и решать проблемы z-index приложений."
      },
      {
        "id": 99,
        "question": "Когда и для чего используют рефы?",
        "answer": "Рефы (refs) используются для получения ссылки на DOM-узел или экземпляр компонента в React. Они полезны в случаях, когда требуется изменить фокус, измерить размер элемента, анимировать компонент или интегрировать сторонние библиотеки, несовместимые с React. Рефы также используются для вызова методов компонента напрямую или для работы с внешними DOM-элементами, такими как формы или анимации."
      },
      {
        "id": 100,
        "question": "Какие вы знаете методы жизненного цикла компонента?",
        "answer": "Основные методы жизненного цикла компонента в React включают: componentDidMount, componentDidUpdate, componentWillUnmount, shouldComponentUpdate, getDerivedStateFromProps, componentDidCatch. Каждый из этих методов выполняет определенные действия в процессе жизненного цикла компонента, такие как инициализация, обновление, удаление и обработка ошибок."
      },
      {
        "id": 101,
        "question": "В каком методе жизненного цикла компонента лучше делать запросы на сервер? Почему?",
        "answer": "Лучше всего делать запросы на сервер в методе componentDidMount. Этот метод вызывается после монтирования компонента в DOM, что делает его подходящим местом для инициализации загрузки данных с сервера. Вызов метода в этом жизненном цикле также предотвращает избыточные запросы на сервер при обновлении компонента."
      },
      {
        "id": 102,
        "question": "В каком методе жизненного цикла компонента лучше делать подписку и отписку от листенера? Почему? Зачем отписываться?",
        "answer": "Подписку на листенеры лучше всего выполнять в методе componentDidMount, а отписку — в componentWillUnmount. Это связано с тем, что componentDidMount вызывается после того, как компонент отрендерен в DOM, и является подходящим местом для инициализации слушателей событий. Отписка в componentWillUnmount важна для предотвращения утечек памяти и избыточного использования ресурсов браузера при удалении компонента из DOM."
      },
      {
        "id": 103,
        "question": "Был ли опыт работы с контекстом? Когда его стоит использовать?",
        "answer": "Да, контекст в React используется для передачи данных через дерево компонентов без необходимости передачи пропсов через каждый уровень. Он стоит использовать, когда данные должны быть доступны множеству компонентов на разных уровнях вложенности, например, информация о текущем пользователе или тема приложения."
      },
      {
        "id": 104,
        "question": "В чем особенность PureComponent?",
        "answer": "PureComponent — это классовый компонент в React, который реализует метод shouldComponentUpdate с поверхностным сравнением пропсов и состояния перед рендерингом. Это позволяет избежать лишних перерисовок компонента, если его пропсы и состояние не изменились. PureComponent следует использовать вместо обычного компонента, если он рендерит одни и те же результаты при одних и тех же пропсах и состояниях, чтобы оптимизировать производительность."
      },
      {
        "id": 105,
        "question": "Работали ли вы с мемоизоваными селекторами (memoized selectors)? Для чего их используют и какой принцип работы?",
        "answer": "Да, мемоизированные селекторы используются для кэширования результатов вычислений, основанных на входных данных. Они помогают избежать повторных вычислений в компонентах React и повышают производительность, сохраняя результаты предыдущих вычислений для одинаковых входных данных. Принцип работы заключается в том, что селектор запоминает аргументы и возвращает закэшированное значение, если аргументы не изменились, или вычисляет новое значение, если аргументы изменились."
      },
      {
        "id": 106,
        "question": "В чем видите преимущества библиотеки React?",
        "answer": "React предлагает множество преимуществ, включая декларативный подход к созданию пользовательского интерфейса, компонентную архитектуру для повторного использования кода, виртуальный DOM для оптимизации производительности, поддержку серверного рендеринга, широкую экосистему библиотек и инструментов, а также активное сообщество разработчиков."
      },
      {
        "id": 107,
        "question": "Почему библиотека React быстрая? Что такое Virtual DOM и Shadow DOM?",
        "answer": "React достигает высокой производительности благодаря виртуальному DOM (Virtual DOM). Виртуальный DOM — это внутреннее представление DOM-структуры приложения, которое React использует для эффективного сравнения и обновления реального DOM. Он позволяет минимизировать количество манипуляций с DOM и повышает скорость рендеринга. Shadow DOM — это часть стандарта веб-компонентов, который позволяет изолировать структуру DOM и стили компонента от внешнего контента страницы."
      },
      {
        "id": 108,
        "question": "Зачем в списках ключи? Можно ли делать ключами индексы элементов массива? Когда это оправдано?",
        "answer": "Ключи (keys) в списках React помогают идентифицировать каждый элемент списка во время рендеринга. Это позволяет React эффективно обновлять только измененные элементы, а не перерисовывать весь список. Использование индексов элементов массива в качестве ключей не рекомендуется, так как это может привести к проблемам при изменении порядка или удалении элементов списка. Оправдано использование индексов только в случае, если порядок элементов не меняется и список статичен."
      },
      {
        "id": 109,
        "question": "В чем основная идея Redux?",
        "answer": "Основная идея Redux заключается в централизованном хранении состояния приложения и управлении им с помощью предсказуемых и чистых функций редукторов. Redux позволяет управлять сложными состояниями приложения и обеспечивает однонаправленный поток данных."
      },
      {
        "id": 110,
        "question": "Работа со стилями в React.",
        "answer": "Стили в React можно управлять различными способами: встроенные стили через объекты JavaScript, использование CSS-модулей для локальной области видимости стилей, использование CSS-in-JS библиотек (например, styled-components или emotion), подключение внешних CSS или препроцессоров через Webpack."
      },
      {
        "id": 111,
        "question": "React - это библиотека или фреймворк? Какая разница между этими двумя понятиями.",
        "answer": "React — это библиотека для создания пользовательских интерфейсов (UI), а не полноценный фреймворк. Основная разница между библиотекой и фреймворком заключается в уровне контроля и внутренней архитектуре. Библиотека предоставляет набор инструментов для решения конкретных задач (например, отрисовка UI), тогда как фреймворк определяет структуру приложения и управляет всем его жизненным циклом."
      },
      {
        "id": 112,
        "question": "Можно ли использовать jQuery вместе с React? Почему да / нет?",
        "answer": "Технически можно использовать jQuery вместе с React, но это не рекомендуется. React и jQuery используют разные подходы к управлению DOM и состоянием. Использование jQuery может привести к конфликтам между обновлением DOM React и jQuery, что может вызвать неожиданное поведение или ухудшение производительности приложения. Вместо этого лучше использовать альтернативы, такие как нативные методы JavaScript или библиотеки, совместимые с React, например, lodash."
      },
      {
        "id": 113,
        "question": "Что такое codemod?",
        "answer": "Codemod — это программный скрипт, который автоматически преобразует исходный код одного формата в другой. Они часто используются для обновления кодовой базы при изменениях в языке программирования, библиотеках или стандартах кодирования."
      },
      {
        "id": 114,
        "question": "Приходилось ли вам настраивать проект React с нуля? С помощью каких инструментов вы это делали?",
        "answer": "Да, приходилось настраивать проект React с нуля. Для этого я использовал инструменты такие как Create React App для быстрого старта проекта с предустановленной конфигурацией, Webpack для настройки сборки и управления зависимостями, Babel для транспиляции JavaScript и поддержки современных функций языка."
      },
      {
        "id": 115,
        "question": "Перечислите все библиотеки, которые использовали в связке с React.",
        "answer": "В связке с React я использовал различные библиотеки в зависимости от требований проекта, включая Redux для управления состоянием, React Router для навигации, Axios для работы с HTTP-запросами, Formik для управления формами, Styled-components для CSS-in-JS и другие."
      },
      {
        "id": 116,
        "question": "Что самое сложное вам приходилось реализовывать с помощью React?",
        "answer": "Одной из самых сложных задач, с которыми мне приходилось сталкиваться в React, было создание сложных форм с динамически изменяющейся структурой и валидацией данных. Это требовало глубокого понимания управления состоянием в React, работы с асинхронными операциями, а также использования различных библиотек для форм и валидации."
      }
    ]
  },
  {
    "position": "junior",
    "topic": "backend",
    "questions": [
      {
        "id": 117,
        "question": "Что такое REPL?",
        "answer": "REPL (Read-Eval-Print Loop) — это интерактивная среда, которая позволяет вводить команды (обычно на языке программирования), которые сразу же исполняются, и выводить результаты. Примеры REPL включают Node.js REPL, Python REPL (интерпретатор Python), и другие."
      },
      {
        "id": 118,
        "question": "Что такое streams в Node.js?",
        "answer": "Streams в Node.js представляют собой объекты, которые позволяют читать или записывать данные побайтово (или кусочно), вместо того чтобы загружать их полностью в память. Это особенно полезно при работе с большими объемами данных или при работе с сетевыми запросами."
      },
      {
        "id": 119,
        "question": "Что такое middleware?",
        "answer": "Middleware — это функции, которые выполняются последовательно в цепочке при обработке HTTP-запросов во фреймворках, таких как Express.js. Они могут модифицировать запрос, ответ или просто выполнять какие-то действия перед тем, как передать управление следующему middleware или обработчику маршрута."
      },
      {
        "id": 120,
        "question": "Для чего используют функцию setImmediate?",
        "answer": "Функция setImmediate используется в Node.js для планирования выполнения кода после завершения текущего цикла событий. Она гарантирует, что колбэк будет вызван немедленно после завершения текущей операции, даже если есть другие задачи в очереди."
      },
      {
        "id": 121,
        "question": "Зачем нужен app.param() в express?",
        "answer": "Метод app.param() в Express.js используется для определения middleware, которые будут выполнены перед обработкой маршрутов, содержащих указанный параметр. Это позволяет предварительно обработать параметры маршрутов и выполнить определенные действия, например, проверку наличия объекта в базе данных по заданному идентификатору."
      },
      {
        "id": 122,
        "question": "Что такое token based authentication?",
        "answer": "Token based authentication — это метод аутентификации, при котором клиент получает токен (часто JWT — JSON Web Token) после успешной аутентификации. Этот токен используется для авторизации последующих запросов к серверу. Токен содержит информацию о пользователе и может быть проверен на сервере без необходимости хранения состояния аутентификации на сервере."
      }
    ]
  },
  {
    "position": "junior",
    "topic": "database",
    "questions": [
      {
        "id": 123,
        "question": "Напишите простой запрос для вычисления трех авторов, у которых больше всего книг.",
        "answer": "SELECT author_id, COUNT(*) as book_count FROM books GROUP BY author_id ORDER BY book_count DESC LIMIT 3;"
      },
      {
        "id": 124,
        "question": "Напишите запрос, который выбирает последние три комментария для конкретного пользователя для двух таблиц: комментарии и пользователи.",
        "answer": "SELECT comments.* FROM comments JOIN users ON comments.user_id = users.id WHERE users.id = ? ORDER BY comments.created_at DESC LIMIT 3;"
      },
      {
        "id": 125,
        "question": "Спроектируйте простую схему базы данных для библиотеки.",
        "answer": "Схема базы данных для библиотеки может выглядеть так:\n- Таблица books (id, title, author_id, genre, published_date)\n- Таблица authors (id, name, birth_date, death_date)\n- Таблица users (id, name, email, membership_date)\n- Таблица loans (id, user_id, book_id, loan_date, return_date)"
      },
      {
        "id": 126,
        "question": "Для чего используют SQL-оператор HAVING?",
        "answer": "Оператор HAVING используется для фильтрации результатов, полученных после применения оператора GROUP BY. Он позволяет задавать условия для агрегатных функций, таких как COUNT, SUM и AVG."
      },
      {
        "id": 127,
        "question": "Зачем используют SQL-оператор LEFT JOIN?",
        "answer": "Оператор LEFT JOIN используется для объединения двух таблиц, включая все записи из левой таблицы и соответствующие записи из правой таблицы. Если в правой таблице нет соответствующих записей, результат все равно будет включать все записи из левой таблицы с NULL значениями для столбцов из правой таблицы."
      },
      {
        "id": 128,
        "question": "Чем отличается embed- от reference-связи в MongoDB?",
        "answer": "В MongoDB embed-связи означают, что вложенные документы хранятся внутри родительского документа, что позволяет быстро получать всю связанную информацию. Reference-связи означают, что документы содержат ссылки на другие документы, что экономит место и позволяет использовать нормализацию данных, но требует дополнительных запросов для получения связанной информации."
      },
      {
        "id": 129,
        "question": "В одном проекте программисты сохраняют данные в MongoDB-коллекции комментариев, используя такие типы данных (смотрите ниже). Что плохого в этом решении?\nid: ObjectID\ntext: string\nauthor_id: string\ncreated_at: Date",
        "answer": "Проблема в том, что author_id сохраняется как строка вместо ObjectID. Это может вызвать проблемы с производительностью и целостностью данных. Лучше использовать ObjectID для хранения author_id, чтобы поддерживать ссылочную целостность и улучшить производительность запросов."
      },
      {
        "id": 130,
        "question": "В проекте понадобилось внести изменения в структуру таблиц, добавить несколько полей и индексы. Как программисты будут делать это на продакшене?",
        "answer": "Программисты будут использовать миграции базы данных для внесения изменений в структуру таблиц на продакшене. Миграции позволяют последовательно применять изменения схемы базы данных, добавлять поля, создавать индексы и т.д., что помогает поддерживать согласованность данных и минимизировать простои."
      }
    ]
  },
  {
    "position": "junior",
    "topic": "tools",
    "questions": [
      {
        "id": 131,
        "question": "Каждый раз, когда вы делаете pull, почему-то случается конфликт в последней строке во всех файлах, которые вы редактировали. Что происходит?",
        "answer": "Конфликты на последней строке файлов часто возникают из-за различий в формате перевода строки (LF vs CRLF) между операционными системами. Например, Unix-подобные системы используют LF, тогда как Windows использует CRLF. Использование консистентного формата перевода строки и конфигурации git, такой как .gitattributes, может помочь избежать таких конфликтов."
      },
      {
        "id": 132,
        "question": "Что делает команда git fetch?",
        "answer": "Команда git fetch загружает изменения из удаленного репозитория в ваш локальный репозиторий, но не сливает их с вашими текущими изменениями. Это позволяет вам видеть обновления на удаленном репозитории без изменения вашего рабочего состояния."
      },
      {
        "id": 133,
        "question": "Какой git hygiene подходы вы знаете?",
        "answer": "К git hygiene подходам относятся:\n- Регулярные коммиты с осмысленными сообщениями.\n- Использование веток для разработки новых фич и исправления багов.\n- Регулярное слияние или ребейз веток, чтобы минимизировать конфликты.\n- Проверка кода перед слиянием (code review).\n- Использование .gitignore для исключения временных или ненужных файлов."
      },
      {
        "id": 134,
        "question": "Что такое CI / CD? Для чего это нужно?",
        "answer": "CI (Continuous Integration) - это практика регулярной интеграции изменений в основной код, с автоматическим тестированием каждого изменения. CD (Continuous Delivery/Continuous Deployment) - это практика автоматического развертывания проверенного кода в производственную среду. Эти практики помогают обнаруживать ошибки на ранних стадиях разработки, обеспечивают стабильность и ускоряют выпуск новых версий."
      }
    ]
  },
  {
    "position": "junior",
    "topic": "practical",
    "questions": [
      {
        "id": 135,
        "question": "Расскажите, какие есть способы копирования простого объекта типа obj = {a: 1, b: 2, c: 3}",
        "answer": "Для копирования простого объекта можно использовать несколько способов:\n1. Object.assign: const newObj = Object.assign({}, obj);\n2. Spread operator: const newObj = {...obj};\n3. JSON.parse(JSON.stringify(obj)) - для глубокого копирования, но с ограничениями на работу с функциями и undefined."
      },
      {
        "id": 136,
        "question": "Напишите deep clone для объекта.",
        "answer": "Для глубокого клонирования объекта можно использовать рекурсивную функцию или библиотеку lodash:\nfunction deepClone(obj) {\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n  const copy = Array.isArray(obj) ? [] : {};\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      copy[key] = deepClone(obj[key]);\n    }\n  }\n  return copy;\n}\nconst clonedObj = deepClone(originalObj);"
      },
      {
        "id": 137,
        "question": "Назовите различные способы, как поменять местами значения двух переменных.",
        "answer": "Для замены значений двух переменных можно использовать несколько способов:\n1. С использованием временной переменной: let temp = a; a = b; b = temp;\n2. С использованием деструктуризации: [a, b] = [b, a];\n3. С использованием арифметических операций: a = a + b; b = a - b; a = a - b; (только для чисел)"
      },
      {
        "id": 138,
        "question": "Менеджер попросил в задаче поменять статусы из «active, inactive» на «active, removed», но в коде фигурируют только цифры и непонятно, какой статус соответствует какой цифре. Как помочь будущим программистам не лезть в документацию по коду? Вопрос ставят на конкретном примере с кодом.",
        "answer": "Чтобы упростить понимание статусов, можно использовать объект для хранения значений статусов и пояснительные комментарии:\nconst Status = {\n  ACTIVE: 1,\n  INACTIVE: 0, // Это статус будет удален\n  REMOVED: 2\n};\n// Пример использования\nlet userStatus = Status.ACTIVE;"
      },
      {
        "id": 139,
        "question": "Необходимо сделать мини проект - список пользователей с формой создания / редактирования пользователя:\nДля хранения пользователей используйте Firebase (это бесплатно).\nДля стилизации используйте Bootstrap.\nМинимальный набор полей пользователя:\nимя;\nфамилия;\nэлектронная почта;\nтелефон (в формате +380 (XX) XXX-XX-XX)\nдата рождения;\nбудет плюсом - добавление аватара и возможность crop-картинки.\nПользователи должны иметь возможность фильтрации и пагинацию.\nПроект должен содержать README-файл с шагами для запуска.",
        "answer": "Для реализации этого проекта можно использовать следующие шаги:\n1. Настройка проекта с использованием create-react-app.\n2. Подключение Firebase и настройка аутентификации и базы данных.\n3. Создание форм с использованием React Hook Form и стилизация с помощью Bootstrap.\n4. Реализация загрузки аватара с использованием Firebase Storage и библиотеки для обрезки изображений, такой как react-avatar-editor.\n5. Добавление функциональности фильтрации и пагинации с использованием React и библиотеки react-paginate.\n6. Написание README-файла с описанием шагов для установки и запуска проекта."
      }
    ]
  }
]