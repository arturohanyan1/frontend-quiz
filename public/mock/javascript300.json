[
  {
    "position": "junior",
    "topic": "accessibility",
    "questions": [
      {
        "question": "Что такое WCAG?",
        "answer": "WCAG (Web Content Accessibility Guidelines) — это набор руководств, разработанных для улучшения доступности веб-контента для людей с ограниченными возможностями. Эти руководства помогают разработчикам создавать веб-сайты, которые могут быть использованы всеми, независимо от их физических или когнитивных способностей."
      },
      {
        "question": "Основные принципы доступности?",
        "answer": "Основные принципы доступности включают: 1) Воспринимаемость — информация и пользовательские интерфейсы должны быть представлены так, чтобы их могли воспринимать все пользователи. 2) Управляемость — элементы интерфейса и навигации должны быть доступны и управляемы всеми пользователями. 3) Понятность — информация и управление интерфейсом должны быть понятными и простыми для использования. 4) Надёжность — контент должен быть достаточно надёжным для интерпретации различными пользователями и технологиями."
      },
      {
        "question": "Что такое скринридер?",
        "answer": "Скринридер — это программа, которая преобразует текст и элементы пользовательского интерфейса на экране компьютера в речевые или тактильные выходы. Она используется людьми с нарушениями зрения для навигации и взаимодействия с компьютерами и мобильными устройствами."
      },
      {
        "question": "Уровни доступности?",
        "answer": "WCAG определяет три уровня соответствия доступности: A (минимальный уровень), AA (средний уровень) и AAA (высший уровень). Уровень A включает основные требования, которые должны быть выполнены для того, чтобы веб-сайт был доступен, уровень AA включает дополнительные требования для улучшения доступности, а уровень AAA включает самые строгие требования, которые делают сайт максимально доступным."
      },
      {
        "question": "Как скрыть содержимое тэга от скринридеров?",
        "answer": "Чтобы скрыть содержимое тэга от скринридеров, можно использовать CSS свойство `display: none;` или `visibility: hidden;`. Однако, если необходимо скрыть элемент только от скринридеров, но оставить видимым для всех остальных пользователей, можно использовать атрибут `aria-hidden=\"true\"`."
      },
      {
        "question": "Как удалить семантику у элемента?",
        "answer": "Чтобы удалить семантику у элемента, можно использовать роль `none` или `presentation` в атрибуте `role`. Это удаляет семантическое значение элемента для вспомогательных технологий, таких как скринридеры. Например: `<div role=\"none\"></div>`."
      },
      {
        "question": "Что такое ARIA роли в веб приложении?",
        "answer": "ARIA (Accessible Rich Internet Applications) роли используются для улучшения доступности веб-приложений путем предоставления дополнительных семантических меток, которые помогают вспомогательным технологиям (таким как скринридеры) правильно интерпретировать и взаимодействовать с элементами интерфейса."
      },
      {
        "question": "Для чего используется атрибут aria-roledescription?",
        "answer": "Атрибут `aria-roledescription` используется для предоставления пользовательского описания роли элемента. Это описание замещает стандартное описание роли, предоставляемое вспомогательными технологиями, и может быть полезно для более точного объяснения функции нестандартных элементов интерфейса."
      },
      {
        "question": "Какие HTML атрибуты можно использовать для улучшения доступности?",
        "answer": "Для улучшения доступности можно использовать следующие HTML атрибуты: `alt` для изображений, `title` для дополнительных описаний, `aria-label` для меток, `aria-labelledby` для связи с другими элементами, `aria-describedby` для указания описательных элементов, и `tabindex` для управления порядком фокусировки."
      },
      {
        "question": "Назовите средства и методы тестирования доступности?",
        "answer": "Для тестирования доступности можно использовать: 1) Скринридеры (например, JAWS, NVDA, VoiceOver) для проверки аудио вывода. 2) Инструменты автоматического тестирования (например, Axe, Lighthouse, WAVE) для выявления проблем с доступностью. 3) Клавиатурное тестирование для проверки управляемости без использования мыши. 4) Тестирование цветовых контрастов (например, через Color Contrast Analyzers). 5) Пользовательское тестирование с участием людей с ограниченными возможностями."
      },
      {
        "question": "Какие стандарты доступности следует учитывать при разработке?",
        "answer": "При разработке следует учитывать стандарты WCAG, а также законодательные требования, такие как Americans with Disabilities Act (ADA) в США и Европейская директива о доступности для веб-сайтов и мобильных приложений (European Accessibility Act) в Европе."
      },
      {
        "question": "Разница между usability и accessibility?",
        "answer": "Usability (удобство использования) относится к тому, насколько эффективно и легко пользователи могут взаимодействовать с продуктом. Accessibility (доступность) же относится к тому, насколько продукт доступен для людей с ограниченными возможностями. Usability фокусируется на общей пользовательской эффективности, тогда как accessibility фокусируется на устранении барьеров для людей с ограниченными возможностями."
      },
      {
        "question": "Что нужно учитывать при разработке доступного сайта?",
        "answer": "При разработке доступного сайта необходимо учитывать следующие аспекты: 1) Структура заголовков для улучшения навигации. 2) Использование альтернативных текстов для изображений. 3) Обеспечение контрастности цветов. 4) Поддержка клавиатурной навигации. 5) Использование ARIA атрибутов. 6) Тестирование с помощью вспомогательных технологий."
      },
      {
        "question": "Как структура заголовков (H1-H6) влияет на доступность? Как правильно их использовать для улучшения навигации и доступности контента?",
        "answer": "Структура заголовков (H1-H6) помогает пользователям и вспомогательным технологиям понять организацию контента на странице. Правильное использование заголовков улучшает навигацию и доступность, позволяя пользователям быстро находить нужные разделы. Заголовки должны использоваться иерархически, начиная с H1 для основного заголовка и дальше по уровням (H2, H3 и т.д.)."
      },
      {
        "question": "Какие правила следует соблюдать при работе с цветом для обеспечения лучшей доступности?",
        "answer": "При работе с цветом следует соблюдать следующие правила: 1) Обеспечить достаточный контраст между текстом и фоном (минимум 4.5:1 для обычного текста и 3:1 для крупного текста). 2) Не использовать цвет как единственное средство передачи информации. 3) Учитывать цветовые слепоты и использовать альтернативные способы различения элементов."
      },
      {
        "question": "Какие рекомендации существуют для работы с мультимедиа-контентом для обеспечения лучшей доступности?",
        "answer": "Для обеспечения доступности мультимедиа-контента следует: 1) Добавлять субтитры и транскрипции для видео. 2) Использовать описательные аудиокомментарии для визуально важного контента. 3) Обеспечить доступность мультимедиа-плееров, чтобы они могли управляться с клавиатуры и поддерживали вспомогательные технологии."
      }
    ]
  },
  {
    "position": "junior",
    "topic": "asynchrony",
    "questions": [
      {
        "question": "Разница между синхронными и асинхронными функциями?",
        "answer": "Синхронные функции выполняются последовательно, блокируя выполнение последующих задач до завершения текущей. Асинхронные функции позволяют программе продолжать выполнение других задач, не дожидаясь завершения асинхронной операции, что позволяет обрабатывать несколько задач одновременно."
      },
      {
        "question": "Что такое AJAX?",
        "answer": "AJAX (Asynchronous JavaScript and XML) — это набор технологий, который позволяет веб-страницам асинхронно запрашивать данные с сервера и обновлять содержимое страницы без перезагрузки."
      },
      {
        "question": "Что такое same-origin policy в контексте JavaScript?",
        "answer": "Same-origin policy — это политика безопасности, которая ограничивает взаимодействие между документами и скриптами, загруженными из разных источников (origin). Источники считаются одинаковыми, если у них совпадают протокол, домен и порт."
      },
      {
        "question": "Что такое цикл событий (event loop) и как он работает?",
        "answer": "Цикл событий (event loop) — это механизм в JavaScript, который обрабатывает асинхронные операции и колбэки. Он постоянно проверяет очередь задач (task queue) и выполняет задачи, когда основной поток (call stack) пуст."
      },
      {
        "question": "Разница между микро и макрозадачами в event loop?",
        "answer": "Микрозадачи (microtasks) — это задачи, которые выполняются сразу после завершения текущей операции и перед следующей макрозадачей. Макрозадачи (macrotasks) — это основные задачи, которые выполняются движком JavaScript, такие как обработка событий и выполнение setTimeout."
      },
      {
        "question": "Расскажите о queueMicrotask?",
        "answer": "Метод `queueMicrotask` добавляет микрозадачу в очередь микрозадач. Микрозадачи выполняются после текущего кода и перед выполнением очередной макрозадачи, что позволяет выполнять критические задачи быстрее."
      },
      {
        "question": "Что такое промисы (Promises)?",
        "answer": "Промисы (Promises) — это объекты, представляющие завершение или отказ асинхронной операции и её результат. Промисы позволяют писать асинхронный код, который выглядит более последовательным и понятным."
      },
      {
        "question": "Плюсы и минусы использовании Ajax?",
        "answer": "Плюсы: улучшение пользовательского опыта за счёт обновления части страницы без перезагрузки, снижение нагрузки на сервер и сети. Минусы: сложность отладки, возможные проблемы с безопасностью и SEO."
      },
      {
        "question": "Подходы при работе с асинхронным кодом?",
        "answer": "Основные подходы: использование колбэков, промисов и async/await. Колбэки — традиционный метод, промисы — более удобный и понятный способ управления асинхронностью, async/await — синтаксический сахар для промисов, делающий код ещё более читаемым."
      },
      {
        "question": "Преимущества использовании промисов вместо колбэков?",
        "answer": "Промисы позволяют избежать вложенности колбэков (Callback Hell), улучшить читаемость кода и управлять ошибками через цепочку `.then()` и `.catch()`."
      },
      {
        "question": "Что такое callback-функция? Что такое Callback Hell?",
        "answer": "Callback-функция — это функция, переданная в качестве аргумента другой функции и вызываемая по завершении операции. Callback Hell — это ситуация, когда в коде слишком много вложенных колбэков, что делает его трудным для чтения и поддержки."
      },
      {
        "question": "Проблемы при использовании callback-функций?",
        "answer": "Основные проблемы: сложно читать и поддерживать, трудности с отладкой и управлением ошибками, возможное возникновение Callback Hell."
      },
      {
        "question": "Что такое async/await?",
        "answer": "Async/await — это синтаксис для работы с асинхронными операциями, который позволяет писать асинхронный код в синхронном стиле. Ключевое слово `async` используется для обозначения асинхронной функции, а `await` — для ожидания завершения промиса."
      },
      {
        "question": "Разница между Promise.all(), Promise.any() и Promise.race()?",
        "answer": "Promise.all() ожидает завершения всех промисов и возвращает их результаты. Promise.any() возвращает результат первого успешно завершенного промиса. Promise.race() возвращает результат первого завершенного промиса, независимо от того, был ли он успешным или нет."
      },
      {
        "question": "Расскажите про статический метод .allSettled()?",
        "answer": "Promise.allSettled() возвращает промис, который завершается, когда все предоставленные промисы завершены (независимо от того, были ли они выполнены или отклонены). Он возвращает массив объектов с состоянием и результатом каждого промиса."
      },
      {
        "question": "Плюсы и минусы асинхронного программирования в JavaScript?",
        "answer": "Плюсы: улучшение производительности за счёт одновременного выполнения задач, улучшение пользовательского опыта. Минусы: сложность отладки и управления ошибками, потенциальные проблемы с конкурентностью и синхронизацией."
      },
      {
        "question": "Как выполнить несколько асинхронных операций последовательно?",
        "answer": "Для последовательного выполнения асинхронных операций можно использовать цепочки промисов или синтаксис async/await. Это позволяет выполнять операции в строго заданном порядке и обрабатывать результаты или ошибки по мере их завершения."
      },
      {
        "question": "Какие проблемы может вызвать неправильное использование асинхронности в JavaScript?",
        "answer": "Проблемы: утечки памяти из-за невыпущенных ресурсов, конкуренция за общие ресурсы, сложности с отладкой и трассировкой кода, потенциальное блокирование основного потока."
      },
      {
        "question": "Что такое fetch()? Как работает функция fetch()?",
        "answer": "Fetch — это современный метод для выполнения HTTP-запросов в JavaScript. Он возвращает промис, который разрешается с объектом Response, представляющим ответ от сервера. Метод fetch() позволяет асинхронно получать данные с сервера и обрабатывать их."
      },
      {
        "question": "Что такое JSON в JavaScript? Как его можно использовать?",
        "answer": "JSON (JavaScript Object Notation) — это формат обмена данными, который использует текст для представления объектов и массивов. В JavaScript JSON используется для сериализации объектов и обмена данными с сервером. Методы `JSON.stringify()` и `JSON.parse()` позволяют преобразовывать объекты в JSON-строки и обратно."
      },
      {
        "question": "Что такое и как работает коэффициент сжатия (compression ratio) в контексте веб-разработки?",
        "answer": "Коэффициент сжатия (compression ratio) — это отношение размера исходных данных к размеру сжатых данных. В контексте веб-разработки он используется для уменьшения объема передаваемых данных и ускорения загрузки страниц. Методы сжатия, такие как Gzip и Brotli, уменьшают размер файлов, что улучшает производительность веб-сайтов."
      }
    ]
  },
  {
    "position": "junior",
    "topic": "browser",
    "questions": [
      {
        "question": "Что такое DOM?",
        "answer": "DOM (Document Object Model) — это объектная модель документа, которая представляет структуру HTML и XML документов в виде дерева, где каждый узел является объектом, предоставляя интерфейсы для доступа и изменения структуры, стиля и содержимого документа."
      },
      {
        "question": "Типы узлов DOM-дерева?",
        "answer": "Типы узлов DOM-дерева включают: 1) Элемент (Element) — представляет HTML или XML элемент. 2) Текст (Text) — представляет текстовое содержимое элемента или атрибута. 3) Атрибут (Attribute) — представляет атрибут элемента. 4) Комментарий (Comment) — представляет комментарий в документе. 5) Документ (Document) — корневой узел для HTML или XML документа."
      },
      {
        "question": "Методы поиска элементов в DOM?",
        "answer": "Методы поиска элементов в DOM включают: `getElementById()`, `getElementsByClassName()`, `getElementsByTagName()`, `querySelector()`, `querySelectorAll()`."
      },
      {
        "question": "Свойства для перемещения по DOM-дереву?",
        "answer": "Свойства для перемещения по DOM-дереву включают: `parentNode`, `childNodes`, `firstChild`, `lastChild`, `nextSibling`, `previousSibling`, `children`, `firstElementChild`, `lastElementChild`, `nextElementSibling`, `previousElementSibling`."
      },
      {
        "question": "Разница между attribute и property у DOM-элементов?",
        "answer": "Attribute — это то, что указано в HTML-коде элемента, и его значение всегда является строкой. Property — это свойство DOM-объекта, которое может принимать любые типы данных и изменяться динамически через JavaScript."
      },
      {
        "question": "Что такое BOM?",
        "answer": "BOM (Browser Object Model) — это модель объектов браузера, предоставляющая методы и свойства для взаимодействия с браузером вне контекста документа, такие как `window`, `navigator`, `location`, `history`, и `screen`."
      },
      {
        "question": "Виды событий в JavaScript?",
        "answer": "Виды событий в JavaScript включают: пользовательские события (click, input, submit), события клавиатуры (keydown, keyup), события мыши (mousedown, mouseup, mousemove), события фокуса (focus, blur), события загрузки (load, DOMContentLoaded), и события таймеров (setTimeout, setInterval)."
      },
      {
        "question": "Как добавить обработчик события на DOM-элемент?",
        "answer": "Чтобы добавить обработчик события на DOM-элемент, можно использовать метод `addEventListener()`, например: `element.addEventListener('click', function() { ... });`."
      },
      {
        "question": "Как удалить обработчик события с DOM-элемента?",
        "answer": "Чтобы удалить обработчик события с DOM-элемента, можно использовать метод `removeEventListener()`, например: `element.removeEventListener('click', functionName);`."
      },
      {
        "question": "Что такое распространение события (Event Propagation)?",
        "answer": "Распространение события (Event Propagation) — это процесс, при котором событие, произошедшее в одном элементе, распространяется на родительские элементы. Существует три фазы: захват (capture), целевая фаза (target), и всплытие (bubble)."
      },
      {
        "question": "Что такое делегирование событий (Event Delegation)?",
        "answer": "Делегирование событий (Event Delegation) — это техника, при которой обработчик события устанавливается на родительский элемент, а события дочерних элементов обрабатываются через этот обработчик. Это помогает уменьшить количество обработчиков событий и улучшить производительность."
      },
      {
        "question": "Как использовать media выражения в JavaScript?",
        "answer": "Media выражения в JavaScript используются с помощью объекта `window.matchMedia()`, который возвращает объект `MediaQueryList`. С помощью метода `addListener()` можно добавить обработчик изменения состояния, например: `const mediaQuery = window.matchMedia('(max-width: 600px)'); mediaQuery.addListener(function(e) { if (e.matches) { ... } else { ... } });`."
      },
      {
        "question": "Расскажите про координаты в браузере?",
        "answer": "Координаты в браузере определяют позицию элемента или события на экране. Основные координаты: `clientX` и `clientY` (координаты относительно видимой области окна), `pageX` и `pageY` (координаты относительно всей страницы), `screenX` и `screenY` (координаты относительно экрана)."
      },
      {
        "question": "Разница между HTMLCollection и NodeList?",
        "answer": "HTMLCollection — это коллекция элементов, обновляющаяся в реальном времени (live), обычно возвращаемая методами `getElementsByClassName` и `getElementsByTagName`. NodeList — это коллекция узлов, которая может быть статической или живой, возвращаемая методами `querySelectorAll` (статическая) и `childNodes` (живая)."
      },
      {
        "question": "Как динамически добавить элемент на HTML-страницу?",
        "answer": "Чтобы динамически добавить элемент на HTML-страницу, можно использовать методы `createElement`, `appendChild`, `insertBefore`. Пример: `const newElement = document.createElement('div'); newElement.textContent = 'Hello, World!'; document.body.appendChild(newElement);`."
      },
      {
        "question": "Разница между feature detection, feature inference и анализом строки user-agent?",
        "answer": "Feature detection (определение возможности) проверяет, поддерживается ли конкретная функция браузером. Feature inference (вывод возможности) делает предположения о поддержке функций на основе других возможностей. User-agent sniffing (анализ строки user-agent) проверяет строку user-agent браузера для определения его версии и особенностей."
      },
      {
        "question": "Разница между e.preventDefault() и e.stopPropagation()?",
        "answer": "e.preventDefault() предотвращает стандартное поведение события (например, отправку формы). e.stopPropagation() останавливает дальнейшее распространение события по фазам захвата и всплытия."
      },
      {
        "question": "Разница между event.target и event.currentTarget?",
        "answer": "event.target — это элемент, на котором произошло событие. event.currentTarget — это элемент, на который установлен обработчик события и который в данный момент обрабатывает событие."
      },
      {
        "question": "Разница между .stopPropagation() и .stopImmediatePropagation()?",
        "answer": ".stopPropagation() останавливает распространение события по фазам захвата и всплытия. .stopImmediatePropagation() дополнительно предотвращает выполнение других обработчиков событий на текущем элементе."
      },
      {
        "question": "Разница между событиями load и DOMContentLoaded?",
        "answer": "Событие `DOMContentLoaded` срабатывает, когда весь HTML-документ загружен и разобран, без ожидания загрузки стилей, изображений и подресурсов. Событие `load` срабатывает после полной загрузки страницы, включая все её ресурсы."
      },
      {
        "question": "Сколько аргументов принимает addEventListener?",
        "answer": "Метод `addEventListener` принимает три аргумента: имя события, функцию-обработчик, и необязательный объект параметров (например, { capture: true, once: true, passive: true })."
      },
      {
        "question": "Разница между innerHTML и outerHTML?",
        "answer": "innerHTML устанавливает или возвращает HTML-содержимое элемента. outerHTML устанавливает или возвращает HTML-содержимое элемента вместе с самим элементом."
      },
      {
        "question": "Разница между JSON и XML?",
        "answer": "JSON (JavaScript Object Notation) — это формат обмена данными, который использует текст для представления объектов и массивов, легко читаем и пишется. XML (Extensible Markup Language) — это формат обмена данными, использующий теги для определения структуры данных, более сложен и менее удобен для чтения и записи."
      },
      {
        "question": "Как узнать об использовании метода event.preventDefault()?",
        "answer": "Чтобы узнать, был ли вызван метод `event.preventDefault()`, можно использовать свойство `event.defaultPrevented`, которое возвращает `true`, если метод был вызван, и `false` в противном случае."
      },
      {
        "question": "Для чего используется свойство window.navigator?",
        "answer": "Свойство `window.navigator` предоставляет информацию о браузере и операционной системе пользователя, включая данные о user-agent, языке браузера, онлайн-статусе и поддержке определённых API, таких как геолокация и хранение."
      },
      {
        "question": "Для чего используется метод .focus()?",
        "answer": "Метод `.focus()` используется для установки фокуса на определённый элемент, обычно на форму или интерактивный элемент, позволяя пользователю взаимодействовать с ним сразу."
      },
      {
        "question": "Для чего используется свойство .forms?",
        "answer": "Свойство `.forms` используется для получения коллекции всех форм в документе. Оно возвращает `HTMLCollection` объектов формы, к которым можно получить доступ по индексу или имени."
      },
      {
        "question": "Для чего используется метод .scrollIntoView()?",
        "answer": "Метод `.scrollIntoView()` прокручивает родительские элементы таким образом, чтобы элемент, к которому он применяется, стал видимым в области просмотра. Это полезно для перемещения к определённым частям страницы."
      },
      {
        "question": "Разница между методами .submit() и .requestSubmit()?",
        "answer": "Метод `.submit()` отправляет форму программно, не вызывая событий валидации. Метод `.requestSubmit()` отправляет форму, вызывая все события валидации и предоставляя возможность программно отменить отправку, если валидация не пройдена."
      },
      {
        "question": "Расскажите о IntersectionObserver?",
        "answer": "IntersectionObserver — это API, который позволяет наблюдать за изменениями пересечения элемента с предками или областью просмотра. Он полезен для ленивой загрузки, выполнения анимаций, когда элемент становится видимым, и других задач, связанных с видимостью элементов."
      },
      {
        "question": "Расскажите о URLSearchParams?",
        "answer": "URLSearchParams — это интерфейс, который предоставляет методы для работы с параметрами строки запроса URL. Он позволяет легко добавлять, изменять, удалять и читать параметры, например: `const params = new URLSearchParams(window.location.search); params.get('key'); params.set('key', 'value');`."
      },
      {
        "question": "Какие есть ограничения у window.close()?",
        "answer": "Метод `window.close()` можно использовать для закрытия окна, только если оно было открыто с помощью `window.open()`. Попытка закрыть основное окно или окно, не открытое скриптом, будет игнорироваться браузером по соображениям безопасности."
      },
      {
        "question": "Как можно создавать пользовательское событие (custom events) в JavaScript?",
        "answer": "Пользовательские события создаются с помощью конструктора `CustomEvent`. Можно задать имя события и дополнительные данные, передаваемые в объекте `detail`, например: `const event = new CustomEvent('myEvent', { detail: { key: 'value' } }); element.dispatchEvent(event);`."
      },
      {
        "question": "Что такое IndexedDB? Как работает IndexedDB?",
        "answer": "IndexedDB — это низкоуровневый API для хранения значительных объёмов структурированных данных, включая файлы и бинарные объекты. Она работает асинхронно и позволяет создавать базы данных, хранилища объектов, индексы и транзакции для эффективного доступа к данным."
      },
      {
        "question": "Расскажите о методе requestAnimationFrame()?",
        "answer": "Метод `requestAnimationFrame()` сообщает браузеру, что вы хотите выполнить анимацию, и просит его запланировать перерисовку на следующем кадре. Этот метод обеспечивает плавную анимацию, синхронизированную с частотой обновления экрана, и лучшее управление производительностью по сравнению с использованием `setTimeout` или `setInterval`."
      }
    ]
  },
  {
    "position": "junior",
    "topic": "css",
    "questions": [
      {
        "question": "Что такое CSS? И для чего он используется?",
        "answer": "CSS (Cascading Style Sheets) — это язык стилей, который используется для описания внешнего вида элементов HTML и XML документов. Он определяет стилизацию текста, цвета, шрифты, расположение элементов и другие аспекты представления веб-страницы."
      },
      {
        "question": "Что такое CSS-правило?",
        "answer": "CSS-правило состоит из селектора, определяющего на какие элементы оно будет применяться, и блока объявлений, содержащего свойства и их значения, которые устанавливаются для выбранных элементов."
      },
      {
        "question": "Варианты добавления CSS стилей на страницу?",
        "answer": "CSS стили можно добавить на страницу используя: внешний файл CSS с помощью `<link>` элемента, внутренний стиль с помощью `<style>` элемента внутри `<head>` или инлайновые стили с помощью атрибута `style` у элементов HTML."
      },
      {
        "question": "Типы позиционирования в CSS?",
        "answer": "Типы позиционирования в CSS включают: статическое позиционирование (default), относительное позиционирование (`position: relative;`), абсолютное позиционирование (`position: absolute;`), фиксированное позиционирование (`position: fixed;`), и закреплённое позиционирование (`position: sticky;`)."
      },
      {
        "question": "Блочная модель CSS?",
        "answer": "Блочная модель CSS описывает способ, как браузер распределяет пространство вокруг элемента, включая его содержимое (content), отступы (padding), границы (border), и внешние поля (margin). Эти части составляют 'коробку или 'блок', который формирует элемент на странице."
      },
      {
        "question": "Что такое селектор? И какие селекторы существуют?",
        "answer": "Селектор в CSS определяет, к каким элементам будет применяться набор правил стилей. Существуют различные типы селекторов: элементные селекторы (например, `div`, `p`), классовые селекторы (например, `.class-name`), идентификаторные селекторы (например, `#id-name`), селекторы атрибутов (например, `[type='text']`), псевдоклассы (например, `:hover`, `:nth-child(n)`), и псевдоэлементы (например, `::before`, `::after`)."
      },
      {
        "question": "Что такое специфичность селектора? Как считать вес селектора?",
        "answer": "Специфичность селектора — это значение, определяющее приоритет применения стилей к элементу. Она вычисляется как комбинация числовых значений, увеличивающихся с каждым типом селектора: элементный селектор (0,0,1,0), класс или псевдокласс (0,1,0,0), идентификатор (1,0,0,0). Чем выше значение, тем выше приоритет."
      },
      {
        "question": "Разница между Reset.css и Normalize.css?",
        "answer": "Reset.css устанавливает нулевые стили по умолчанию для всех элементов, обнуляя все стили браузера и создавая единообразие визуального вида элементов. Normalize.css исправляет стандартные стили браузера, делая их согласованными и предсказуемыми в различных браузерах, но не полностью обнуляет стили."
      },
      {
        "question": "Разница между margin и padding?",
        "answer": "`margin` определяет внешние отступы элемента, которые пространство между элементом и соседними элементами. `padding` определяет внутренние отступы элемента, которые пространство между содержимым элемента и его границей."
      },
      {
        "question": "Разница между display: none и visibility: hidden?",
        "answer": "`display: none;` скрывает элемент и исключает его из макета документа, он не занимает места на странице. `visibility: hidden;` делает элемент невидимым, но он продолжает занимать место на странице."
      },
      {
        "question": "Разница между блочным и строчным (инлайновым) элементами?",
        "answer": "Блочные элементы занимают всю доступную ширину и всегда начинаются с новой строки, например `div`, `p`. Строчные (инлайновые) элементы занимают только столько пространства, сколько необходимо для их содержимого, и не начинают новую строку, например `span`, `a`."
      },
      {
        "question": "Разница между классом и идентификатором в CSS?",
        "answer": "Класс в CSS обозначается символом точки (`.`) и может применяться к нескольким элементам на странице. Идентификатор обозначается символом решетки (`#`) и должен быть уникален на странице, применяется к одному элементу."
      },
      {
        "question": "Что такое CSS спрайт? И для чего он используется?",
        "answer": "CSS спрайт — это метод комбинирования нескольких изображений в одно большое изображение, а CSS используется для вырезания и позиционирования отдельных частей из этого изображения. Он используется для уменьшения количества запросов к серверу и улучшения производительности загрузки страницы."
      },
      {
        "question": "Что такое вендорные префиксы? И для чего они используются?",
        "answer": "Вендорные префиксы — это префиксы, добавляемые к CSS свойствам для обеспечения поддержки экспериментальных или нестандартных возможностей браузерами разных производителей. Они используются для временной поддержки новых возможностей до их стандартизации и общей поддержки в браузерах."
      },
      {
        "question": "Что такое псевдоэлементы? И для чего они используются?",
        "answer": "Псевдоэлементы в CSS представляют собой дополнительные элементы, создаваемые с помощью псевдоклассов, таких как `::before` и `::after`. Они используются для добавления декоративных элементов или изменения внешнего вида элемента без добавления дополнительных узлов в HTML."
      },
      {
        "question": "Что такое схлопывание границ (margin collapsing)?",
        "answer": "Схлопывание границ — это явление в CSS, когда верхний и нижний внешние отступы (`margin`) двух смежных блочных элементов объединяются в один общий отступ, который равен большему из двух отступов, если они пересекаются."
      },
      {
        "question": "Что такое CSS препроцессор?",
        "answer": "CSS препроцессор — это инструмент, который расширяет функциональность обычного CSS, добавляя переменные, вложенные правила, миксины и другие возможности, улучшая поддерживаемость и организацию стилей."
      },
      {
        "question": "Что такое z-index? Как формируется контекст наложения?",
        "answer": "`z-index` в CSS определяет порядок наложения элементов на странице. Элементы с большим значением `z-index` находятся выше по стеку. Контекст наложения формируется из блочных контейнеров, которые формируют контекст наложения для дочерних элементов."
      },
      {
        "question": "Порядок наложения элементов в CSS (Stacking Order)?",
        "answer": "Порядок наложения элементов в CSS определяется иерархией и контекстом наложения элементов. Он управляется свойством `z-index`, которое задаёт глубину наложения элементов на странице."
      },
      {
        "question": "Как с помощью CSS определить, поддерживается ли свойство в браузере?",
        "answer": "Для определения поддержки свойства в браузере можно использовать функцию проверки наличия свойства, например: `if ('property' in document.body.style) { /* свойство поддерживается */ } else { /* свойство не поддерживается */ }`."
      },
      {
        "question": "Как поддерживать страницы в браузерах с ограниченными функциями?",
        "answer": "Для поддержки страниц в браузерах с ограниченными функциями следует использовать прогрессивное улучшение и деградацию функциональности, адаптировать стили и скрипты для работы в старых и менее функциональных браузерах, использовать полифиллы для эмуляции новых возможностей."
      },
      {
        "question": "Как исправлять специфичные проблемы со стилями для разных браузеров?",
        "answer": "Для исправления специфичных проблем со стилями для разных браузеров следует использовать вендорные префиксы, полифиллы и другие методы, которые обеспечивают согласованное отображение в различных браузерах."
      },
      {
        "question": "Глобальные ключевые слова в CSS?",
        "answer": "Глобальные ключевые слова в CSS включают `initial` (устанавливает начальное значение свойства), `inherit` (наследует значение от родительского элемента), `unset` (устанавливает значение, которое зависит от контекста), и `revert` (возвращает значение к первоначальному состоянию)."
      },
      {
        "question": "Что такое CSS-атрибут (attr)?",
        "answer": "CSS-атрибут `attr` используется для извлечения значения HTML-атрибута и его использования в CSS. Например, `content: attr(data-attribute);` позволяет использовать значение атрибута `data-attribute` в качестве содержимого."
      },
      {
        "question": "Что такое перечисление селекторов?",
        "answer": "Перечисление селекторов в CSS позволяет задавать стили для нескольких элементов, перечисляя селекторы через запятую. Например, `div, p { /* стили для всех <div> и <p> элементов */ }`."
      },
      {
        "question": "Для чего используется ключевое слово currentColor в CSS?",
        "answer": "Ключевое слово `currentColor` в CSS используется для установки значения свойства равным текущему цвету текста (`color`), что упрощает поддержку цветовых схем."
      },
      {
        "question": "Какие псевдоклассы были добавлены в CSS3?",
        "answer": "CSS3 добавил множество новых псевдоклассов, таких как `:nth-child()`, `:nth-of-type()`, `:not()`, `:focus-within`, `:checked`, `:target`, `:hover`, `:first-child`, `:last-child` и другие, предоставляющие возможности для более точного выбора элементов."
      },
      {
        "question": "Какие фильтры есть в CSS?",
        "answer": "CSS фильтры позволяют применять различные эффекты к элементам, такие как размытие (`blur()`), насыщенность (`saturate()`), контрастность (`contrast()`), яркость (`brightness()`), оттенок (`hue-rotate()`), инверсия (`invert()`), и другие."
      },
      {
        "question": "Для чего используется псевдокласс :invalid?",
        "answer": "Псевдокласс `:invalid` в CSS применяется к элементам формы (`<input>`, `<select>`, `<textarea>`) в случае, если они не проходят валидацию, определённую атрибутами `required`, `pattern` или другими атрибутами валидации."
      },
      {
        "question": "Расскажите про свойство display в CSS?",
        "answer": "Свойство `display` в CSS определяет тип отображения элемента. Оно может принимать различные значения, такие как `block` (блочный элемент), `inline` (строчный элемент), `inline-block` (строчно-блочный элемент), `flex` (флекс-контейнер), `grid` (сетка), и другие, контролируя способ, как элементы располагаются на странице."
      },
      {
        "question": "В каком случае лучше использовать translate() вместо абсолютного позиционирования?",
        "answer": "Метод `translate()` в CSS лучше использовать для перемещения элемента на странице, чем абсолютное позиционирование (`position: absolute;`), так как он использует аппаратное ускорение, что повышает производительность и улучшает анимации."
      },
      {
        "question": "Что такое плавающие элементы (floats)? Как они работают?",
        "answer": "Плавающие элементы (`floats`) в CSS позволяют элементам выходить из нормального потока и выравниваться по левому или правому краю родительского контейнера. Они используются для создания многоколоночного макета или обтекания текстом других элементов."
      },
      {
        "question": "Расскажите о свойстве text-rendering?",
        "answer": "Свойство `text-rendering` в CSS контролирует, как текст рендерится на странице. Оно может принимать значения `auto` (стандартный рендеринг), `optimizeSpeed` (оптимизация для скорости), `optimizeLegibility` (оптимизация для читаемости), и `geometricPrecision` (геометрическая точность), влияя на качество отображения текста."
      }
    ]
  },
  {
    "position": "junior",
    "topic": "ecmascript",
    "questions": [
      {
        "question": "Что такое ECMAScript? В чём отличие от JavaScript?",
        "answer": "ECMAScript (ES) — это стандартизированный язык программирования, на основе которого реализуется JavaScript. Отличие заключается в том, что JavaScript является конкретной реализацией стандарта ECMAScript, добавляя дополнительные возможности, такие как работа с DOM и BOM."
      },
      {
        "question": "Разница между let, const и var?",
        "answer": "Переменные, объявленные с помощью `var`, имеют функциональную область видимости и поднимаются вверх перед выполнением кода. Переменные `let` и `const` имеют блочную область видимости и не поднимаются. `let` позволяет изменять значение переменной, в то время как значение, определённое с помощью `const`, не может быть изменено после инициализации."
      },
      {
        "question": "Можно ли изменить значение, определённое через const?",
        "answer": "Нет, значение, определённое через `const`, не может быть изменено после инициализации. Попытка переназначить `const` переменную вызовет ошибку."
      },
      {
        "question": "Что такое временная мёртвая зона (temporal dead zone)?",
        "answer": "Временная мёртвая зона (temporal dead zone) — это фаза во время выполнения кода, когда переменная уже была объявлена (с помощью `let` или `const`), но до того, как она была инициализирована. В этой зоне доступ к переменной вызовет ошибку ReferenceError."
      },
      {
        "question": "Разница между Rest и Spread операторами?",
        "answer": "Оператор `...` используется как Rest оператор в контексте деструктуризации массивов или объектов для сбора оставшихся элементов в массив или объект. В контексте вызова функций он используется как Spread оператор для передачи элементов массива как отдельных аргументов функции."
      },
      {
        "question": "Что такое деструктуризация?",
        "answer": "Деструктуризация в JavaScript — это способ извлечения значений из массивов или объектов и присвоения их переменным с помощью синтаксиса, подобного образу, в котором массивы или объекты были бы написаны."
      },
      {
        "question": "Для чего используется цикл for…of?",
        "answer": "Цикл `for...of` используется для перебора элементов массива, строки, или других итерируемых объектов. Он проходит по каждому элементу коллекции в порядке их следования."
      },
      {
        "question": "Что такое шаблонные литералы (Template Literals)?",
        "answer": "Шаблонные литералы — это специальный вид строк в JavaScript, позволяющий встраивать выражения в строковые литералы с помощью синтаксиса `${выражение}`."
      },
      {
        "question": "Что такое Set, Map, WeakMap и WeakSet?",
        "answer": "Set — это коллекция уникальных значений, Map — это коллекция ключ-значение, WeakSet и WeakMap — это версии Set и Map, которые позволяют объектам быть подверженными сборке мусора, если на них больше нет ссылок."
      },
      {
        "question": "Разница между обычными функциями и стрелочными?",
        "answer": "Стрелочные функции в JavaScript — это более краткая форма для написания функций. Они не имеют своего контекста выполнения (`this`), поднимаемые они не бывают и не могут быть использованы как конструкторы. Обычные функции могут быть вызваны как конструкторы и имеют свои собственные контексты выполнения."
      },
      {
        "question": "Разница между методом Object.freeze() и const?",
        "answer": "`Object.freeze()` замораживает объект, предотвращая добавление, удаление и изменение существующих свойств. `const` же предотвращает переназначение переменной после инициализации, но не защищает от изменений внутри самого объекта."
      },
      {
        "question": "Что такое итераторы?",
        "answer": "Итераторы в JavaScript — это объекты, которые предоставляют метод `next()`, возвращающий следующий элемент последовательности. Они используются для перебора данных в циклах `for...of` и других контекстах, поддерживающих итерацию."
      },
      {
        "question": "Что такое генераторы? Когда стоит использовать генераторы?",
        "answer": "Генераторы в JavaScript — это функции, которые могут приостанавливать своё выполнение, возвращать промежуточный результат и затем возобновлять выполнение с последней точки приостановки. Они полезны для создания ленивых вычислений или работы с потоками данных."
      },
      {
        "question": "Что такое ES6 модули?",
        "answer": "ES6 модули в JavaScript представляют собой механизм организации кода, который позволяет импортировать и экспортировать функции, переменные и другие значения между различными JavaScript файлами, обеспечивая лучшую модульность и поддержку зависимостей."
      },
      {
        "question": "Что такое символ (Symbol) в ES6?",
        "answer": "Символ (Symbol) в JavaScript — это примитивный тип данных, представляющий собой уникальный и неизменяемый идентификатор. Символы часто используются для создания уникальных свойств объектов."
      },
      {
        "question": "Для чего используется метод .includes()?",
        "answer": "Метод `.includes()` используется для проверки наличия подстроки в строке или элемента в массиве. Он возвращает `true`, если подстрока или элемент найдены, и `false` в противном случае."
      },
      {
        "question": "Для чего используется метод .getOwnPropertyDescriptors()?",
        "answer": "Метод `.getOwnPropertyDescriptors()` возвращает объект, содержащий дескрипторы всех собственных свойств объекта, включая их значения, уровни доступа и типы."
      },
      {
        "question": "Расскажите о методах .keys(), .values(), .entries()?",
        "answer": "Методы `.keys()`, `.values()` и `.entries()` используются для получения итераторов ключей, значений и пар ключ-значение соответственно из объекта или массива. Они позволяют эффективно перебирать элементы структуры данных."
      },
      {
        "question": "Для чего используется метод .fromEntries()?",
        "answer": "Метод `.fromEntries()` преобразует список пар ключ-значение (полученный например с помощью метода `.entries()`) в новый объект. Он обратный методу `.entries()`."
      },
      {
        "question": "Для чего используются методы .flat() и .flatMap()?",
        "answer": "Метод `.flat()` используется для рекурсивного сглаживания массива до указанной глубины. Метод `.flatMap()` выполняет сначала сглаживание, а затем применяет функцию к каждому элементу массива и возвращает новый массив."
      },
      {
        "question": "Для чего используются методы .padStart() и .padEnd()?",
        "answer": "Методы `.padStart()` и `.padEnd()` используются для добавления пробельных символов в начало или конец строки соответственно, чтобы достигнуть заданной длины строки."
      },
      {
        "question": "Для чего используются методы .startsWith() и .endsWith()?",
        "answer": "Метод `.startsWith()` используется для проверки, начинается ли строка с определённой подстроки. Метод `.endsWith()` используется для проверки, заканчивается ли строка на определённую подстроку. Оба метода возвращают `true` или `false`."
      },
      {
        "question": "Как в JavaScript удалять пробельные символы в начале и в конце строки?",
        "answer": "Для удаления пробельных символов в начале строки используйте метод `.trimStart()`, а для удаления в конце строки — метод `.trimEnd()`. Для удаления пробелов с обоих концов используйте метод `.trim()`."
      },
      {
        "question": "Расскажите об операторе Optional Chaining (?.)?",
        "answer": "Оператор Optional Chaining (?.) позволяет избежать ошибок типа `TypeError` при обращении к свойству или вызове метода объекта, если указанное свойство или метод отсутствует. Он возвращает `undefined`, если свойство не существует."
      },
      {
        "question": "Для чего используется метод .replaceAll()?",
        "answer": "Метод `.replaceAll()` используется для замены всех вхождений подстроки в строке на другую подстроку."
      },
      {
        "question": "Что такое оператор логического присваивания?",
        "answer": "Оператор логического присваивания (`??=`) присваивает правый операнд левому операнду только в том случае, если левый операнд имеет значение `null` или `undefined`."
      },
      {
        "question": "Как увеличить читаемость больших чисел?",
        "answer": "Для увеличения читаемости больших чисел в JavaScript можно использовать подчёркивания в числовых литералах для разделения разрядов. Например, `1_000_000` вместо `1000000`."
      },
      {
        "question": "Что такое приватные аксессоры?",
        "answer": "Приватные аксессоры — это методы доступа (геттеры и сеттеры), которые могут быть объявлены внутри класса или объекта с использованием префикса `#`. Они обеспечивают защиту данных, ограничивая доступ к ним извне."
      },
      {
        "question": "Разница между ES6-классами и конструкторами функций?",
        "answer": "ES6-классы в JavaScript предоставляют более удобный и декларативный синтаксис для создания объектов и организации наследования, чем конструкторы функций, которые используются в предыдущих версиях JavaScript."
      },
      {
        "question": "Что такое оператор нулевого слияния (??)?",
        "answer": "Оператор нулевого слияния (`??`) возвращает правый операнд, если левый операнд имеет значение `null` или `undefined`, в противном случае возвращает значение левого операнда."
      },
      {
        "question": "В чём отличие оператора нулевого слияния (??) и оператора “ИЛИ” (||)?",
        "answer": "Оператор `||` выполняет логическое ИЛИ и возвращает первый истинный операнд. Оператор `??` возвращает правый операнд только если левый операнд равен `null` или `undefined`."
      },
      {
        "question": "Назовите основные методы и свойства работы с коллекцией Map?",
        "answer": "Основные методы и свойства работы с коллекцией `Map` включают: `.set(key, value)` для добавления элемента, `.get(key)` для получения элемента по ключу, `.delete(key)` для удаления элемента, `.has(key)` для проверки наличия ключа, `.size` для получения количества элементов."
      },
      {
        "question": "Назовите основные методы и свойства работы с коллекцией Set?",
        "answer": "Основные методы и свойства работы с коллекцией `Set` включают: `.add(value)` для добавления элемента, `.delete(value)` для удаления элемента, `.has(value)` для проверки наличия элемента, `.size` для получения количества элементов."
      },
      {
        "question": "Как осуществить перебор элементов в коллекциях Map и Set?",
        "answer": "Для перебора элементов в коллекции `Map` используйте методы `.keys()`, `.values()` или `.entries()` в цикле `for...of`. В коллекции `Set` перебор осуществляется аналогично."
      },
      {
        "question": "Как работают дефолтные параметры в ES6?",
        "answer": "Дефолтные параметры в ES6 позволяют задать значения по умолчанию для параметров функции, которые будут использоваться, если при вызове функции не переданы аргументы или переданы `undefined`."
      },
      {
        "question": "Что такое BigInt в ES2020 и для чего он используется?",
        "answer": "BigInt в ES2020 — это встроенный тип данных, представляющий целые числа произвольной длины. Он используется для работы с числами, которые превышают максимально допустимый размер для типа `Number` в JavaScript."
      },
      {
        "question": "Какие нововведения были представлены в ECMAScript 2021 (ES12)?",
        "answer": "ECMAScript 2021 включает нововведения, такие как `String.prototype.replaceAll()` для замены всех вхождений подстроки в строке, оператор логического присваивания `??=`, методы для работы с `Promise`, и другие улучшения."
      }
    ]
  },
  {
    "position": "junior",
    "topic": "html",
    "questions": [
      {
        "question": "Что такое HTML и для чего он используется?",
        "answer": "HTML (HyperText Markup Language) — это язык разметки, используемый для создания структуры веб-страницы. Он определяет содержимое и структуру элементов на странице, таких как заголовки, параграфы, изображения, ссылки и другие элементы."
      },
      {
        "question": "Что такое HTML-элемент? Какова его структура?",
        "answer": "HTML-элемент представляет собой основные строительные блоки веб-страницы, состоящие из открывающего тега, содержимого элемента и закрывающего тега (если элемент не одиночный). Например, <p>Это параграф</p>."
      },
      {
        "question": "Что такое атрибуты в HTML? Как они используются в элементах?",
        "answer": "Атрибуты HTML предоставляют дополнительную информацию о элементах. Они задаются в открывающем теге элемента и содержат значение. Например, в <img src=\"image.jpg\" alt=\"Изображение\"> атрибуты src и alt задают источник изображения и его альтернативный текст."
      },
      {
        "question": "Какие глобальные атрибуты есть в HTML?",
        "answer": "Глобальные атрибуты в HTML могут быть применены к любому элементу и включают атрибуты, такие как id, class, style, title, lang, tabindex и другие. Они не ограничены конкретными типами элементов."
      },
      {
        "question": "Что такое категории контента в HTML5?",
        "answer": "Категории контента в HTML5 описывают основные типы информации, которые могут содержаться на веб-странице. Они включают метаданные, разделы, группировки контента, встраиваемый контент, формы, интерактивный контент и другие."
      },
      {
        "question": "Какие категории считаются основными категориями контента?",
        "answer": "Основными категориями контента в HTML5 являются метаданные (например, meta), разделы (например, section), группировки контента (например, div), встраиваемый контент (например, iframe), формы (например, form), интерактивный контент (например, button)."
      },
      {
        "question": "Что такое doctype? И для чего он используется?",
        "answer": "Doctype (Document Type Declaration) — это специальная инструкция в начале HTML-документа, которая сообщает браузеру о версии HTML (или XHTML), используемой в документе. Это необходимо для правильного отображения и интерпретации страницы."
      },
      {
        "question": "Опишите базовую структуру HTML-страницы.",
        "answer": "Базовая структура HTML-страницы включает doctype, открывающий и закрывающий тег html, секцию head и body. Пример: <!DOCTYPE html><html lang=\"en\"><head><meta charset=\"UTF-8\"><title>Заголовок страницы</title></head><body><h1>Привет, мир!</h1></body></html>"
      },
      {
        "question": "Что такое валидация? И какие типы проверок HTML документа вы знаете?",
        "answer": "Валидация HTML — это процесс проверки соответствия HTML-документа стандартам и синтаксическим правилам языка. Типы проверок включают проверку структуры документа, правильности использования элементов и атрибутов, а также правильности вложенности элементов."
      },
      {
        "question": "Основные этапы проверок валидности HTML-документа?",
        "answer": "Основные этапы проверки валидности HTML-документа включают синтаксическую проверку, проверку наличия обязательных элементов, правильность вложенности элементов, проверку атрибутов и их значений, а также проверку на соответствие спецификации языка."
      },
      {
        "question": "Если представить HTML5 как открытую веб-платформу, из каких блоков он состоит?",
        "answer": "HTML5 как открытая веб-платформа состоит из блоков, таких как семантика, доступность, устройства ввода-вывода, производительность, стилевое оформление, мультимедиа и сетевые возможности."
      },
      {
        "question": "Какой тэг использовать для того, чтобы сверстать кнопку?",
        "answer": "Для создания кнопки на веб-странице используется тег <button>. Например: <button>Нажми меня</button>."
      },
      {
        "question": "Что такое инлайновый стиль? Можно ли его переопределить?",
        "answer": "Инлайновый стиль — это стиль, применённый напрямую к элементу через атрибут style. Его можно переопределить с помощью более специфичных CSS-правил, например, используя селекторы с большей специфичностью или !important."
      },
      {
        "question": "Есть ли у HTML элементов свои дефолтные специфичные стили?",
        "answer": "Да, у многих HTML элементов есть дефолтные стили, заданные браузером. Например, у тега <p> может быть задан отступ и размер шрифта по умолчанию, если не указаны другие стили."
      },
      {
        "question": "Что такое семантика? Какие семантичные тэги вы знаете?",
        "answer": "Семантика в HTML означает использование элементов согласно их смысловому назначению, что улучшает структуру и понимание содержимого страницы поисковыми системами и разработчиками. Примеры семантичных тегов: <header>, <nav>, <section>, <article>, <footer> и другие."
      },
      {
        "question": "Как семантически правильно сверстать картинку с подписью?",
        "answer": "Для сверстывания картинки с подписью используются семантические элементы, например: <figure> для картинки и <figcaption> для подписи. Пример: <figure><img src=\"image.jpg\" alt=\"Изображение\"><figcaption>Подпись к изображению</figcaption></figure>."
      },
      {
        "question": "Типы списков в HTML?",
        "answer": "В HTML есть три типа списков: неупорядоченный список (<ul>), упорядоченный список (<ol>) и список определений (<dl>)."
      },
      {
        "question": "Для какого тэга используется атрибут alt и зачем он нужен?",
        "answer": "Атрибут alt используется для задания текстового описания изображения в случае, если изображение не может быть отображено или если пользователь использует средство чтения для слабовидящих. Например: <img src=\"image.jpg\" alt=\"Описание изображения\">."
      },
      {
        "question": "Какая разница между тэгами <strong><em> и <b><i>?",
        "answer": "<strong> и <em> — это семантические теги для выделения важности и ударения текста, соответственно. <b> и <i> — это стилистические теги для жирного и курсивного текста. Различие в их использовании влияет на семантику и доступность контента."
      },
      {
        "question": "Типы <input> элементов в HTML?",
        "answer": "<input> в HTML может использоваться для создания различных типов элементов управления, таких как текстовое поле (type=\"text\"), поле ввода пароля (type=\"password\"), флажки (type=\"checkbox\"), радиокнопки (type=\"radio\"), кнопки (type=\"button\"), поле выбора файла (type=\"file\") и другие."
      },
      {
        "question": "Для чего используют data-атрибуты?",
        "answer": "Data-атрибуты (атрибуты данных) используются для хранения пользовательских данных в HTML и JavaScript. Они начинаются с префикса data- и могут быть доступны с помощью JavaScript для удобного хранения и работы с данными."
      },
      {
        "question": "Разница между <script>, <script async> и <script defer>?",
        "answer": "<script> используется для подключения скриптов на странице. Атрибуты async и defer определяют способ загрузки скрипта. Атрибут async загружает скрипт асинхронно, не блокируя загрузку страницы. Атрибут defer загружает скрипт асинхронно, но выполняет его после того, как HTML будет полностью разобран."
      },
      {
        "question": "Для чего используется элемент <datalist>?",
        "answer": "Элемент <datalist> используется для создания списка вариантов (опций) для элементов <input> с атрибутом list. Пользователь может выбирать варианты из предложенного списка или вводить свои значения."
      },
      {
        "question": "Почему хорошей практикой считается располагать <link> для подключения CSS стилей внутри тэга <head>, а <script> для подключения JS ставить перед закрывающимся тэгом </body>?",
        "answer": "Это рекомендуется для оптимизации загрузки страницы. Подключение CSS в <head> позволяет браузеру сначала загрузить стили, что предотвращает мерцание (FOUC). Подключение JS перед </body> обеспечивает, что скрипты не блокируют отображение содержимого страницы, пока она полностью не загрузится."
      },
      {
        "question": "Что такое мета-тэги?",
        "answer": "Мета-тэги в HTML предназначены для предоставления метаданных о веб-странице. Они могут содержать информацию о кодировке страницы, авторе, описании, ключевых словах, совместимости с браузерами и другие данные."
      },
      {
        "question": "Что описывается в тэге <head>?",
        "answer": "Тэг <head> в HTML используется для содержания мета-тэгов, стилей, скриптов, заголовка страницы, ссылок на внешние ресурсы и других элементов, которые не отображаются напрямую на веб-странице, но влияют на её отображение и поведение."
      },
      {
        "question": "Для чего используются тэги <tr>, <th>, <td>?",
        "answer": "<tr> используется для создания строки в таблице, <th> — для заголовков ячеек в таблице, <td> — для ячеек данных в таблице."
      },
      {
        "question": "Расскажите о meta-теге с name=\"viewport\"?",
        "answer": "Мета-тег viewport используется для настройки параметров отображения страницы на мобильных устройствах. Например, <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> задаёт ширину страницы, соответствующую ширине экрана устройства, и начальный масштаб отображения."
      },
      {
        "question": "Что такое элемент <canvas>? И для чего он используется?",
        "answer": "Элемент <canvas> в HTML используется для создания графики, рисования, анимации и других визуальных эффектов на веб-странице с помощью JavaScript."
      },
      {
        "question": "Что такое <svg> и <canvas>?",
        "answer": "<svg> и <canvas> — это два разных подхода к созданию графики на веб-странице. <svg> представляет векторную графику, описываемую в XML, а <canvas> создаёт растровую графику, которая рисуется при помощи JavaScript."
      },
      {
        "question": "Разница между <canvas> и <svg>?",
        "answer": "<canvas> предназначен для растровой графики, рисуется программно через JavaScript, не масштабируется без потери качества. <svg> — для векторной графики, описывается XML, масштабируется без потери качества, поддерживает события DOM."
      },
      {
        "question": "В каких случаях лучше использовать <canvas>, а в каких <svg>?",
        "answer": "Используйте <canvas> для создания сложных растровых изображений или анимации, когда требуется быстрое рисование большого количества элементов. Используйте <svg> для создания векторной графики, интерактивных изображений или анимации, требующих масштабируемости."
      },
      {
        "question": "Плюсы и минусы <canvas> и <svg>?",
        "answer": "Плюсы <canvas>: высокая производительность при рисовании множества объектов, подходит для сложной растровой графики. Минусы <canvas>: не поддерживает ретинизацию, трудно взаимодействовать с элементами. Плюсы <svg>: масштабируемость, доступность для изменения и интерактивности. Минусы <svg>: может быть медленным при большом количестве элементов."
      },
      {
        "question": "Для чего нужен атрибут autocomplete?",
        "answer": "Атрибут autocomplete в HTML используется для указания браузеру, должно ли автоматическое заполнение формы включаться для данного элемента ввода. Он может принимать значения on и off."
      },
      {
        "question": "Что такое элемент <output> в HTML5?",
        "answer": "Элемент <output> в HTML5 используется для отображения результата вычислений или операций, выполненных на веб-странице. Он может быть использован вместе с JavaScript для вывода информации пользователю."
      },
      {
        "question": "Что такое свойство valueAsNumber?",
        "answer": "Свойство valueAsNumber у элементов <input> типа number возвращает числовое значение, введённое пользователем. Оно преобразует введённое значение в число."
      },
      {
        "question": "Что такое атрибут target? Какие значения он принимает?",
        "answer": "Атрибут target в HTML используется для указания, куда следует открыть связанную с элементом ссылку или форму. Он может принимать значения _blank (открыть в новом окне), _self (открыть в текущем окне), _parent (в родительском фрейме) и _top (заменить все фреймы текущего окна)."
      },
      {
        "question": "Что такое ApplicationCache в HTML5?",
        "answer": "ApplicationCache в HTML5 предоставляет возможность веб-приложениям работать оффлайн, кэшируя ресурсы, которые могут использоваться без подключения к Интернету. Это позволяет улучшить производительность и доступность приложения."
      },
      {
        "question": "Для чего используется элемент <picture>?",
        "answer": "Элемент <picture> в HTML используется для адаптивной загрузки изображений на основе различных размеров экрана и разрешений устройства. Он позволяет указывать разные источники изображений для разных условий экрана."
      },
      {
        "question": "Что такое srcset? Как работает srcset?",
        "answer": "Атрибут srcset в элементе <img> используется для указания нескольких источников изображений с разным разрешением. Браузер использует этот атрибут для выбора подходящего изображения в зависимости от разрешения экрана устройства пользователя."
      },
      {
        "question": "Как семантически верно сверстать навигационное меню?",
        "answer": "Семантически верное навигационное меню может быть свёрстано с использованием элементов <nav> для обозначения области навигации и <ul> с <li> для списка ссылок. Например: <nav><ul><li><a href=\"#\">Главная</a></li><li><a href=\"#\">О нас</a></li></ul></nav>."
      },
      {
        "question": "Что такое <iframe>?",
        "answer": "Элемент <iframe> в HTML используется для встраивания другого документа или содержимого, такого как веб-страница, в текущий HTML-документ. Он позволяет отображать содержимое других сайтов или внутренние документы внутри текущей страницы."
      },
      {
        "question": "Для чего используются тэги <sub> и <sup>?",
        "answer": "<sub> используется для создания нижнего индекса, а <sup> — для верхнего индекса. Например: H<sub>2</sub>O."
      },
      {
        "question": "Как можно скрыть элемент разметки не используя CSS и JS?",
        "answer": "Элемент можно скрыть с помощью атрибута hidden, который предотвращает его отображение в браузере. Например: <div hidden>Скрытый текст</div>."
      },
      {
        "question": "Разница между <meter> и <progress>?",
        "answer": "<meter> используется для измерения значения в заданном диапазоне, например, прогресса выполнения задачи. <progress> — для отображения текущего прогресса выполнения задачи в процентном соотношении."
      },
      {
        "question": "Как можно сгруппировать опции внутри тэга <select>?",
        "answer": "Опции внутри элемента <select> можно группировать с помощью элемента <optgroup>. Например: <select><optgroup label=\"Group 1\"><option>Option 1.1</option><option>Option 1.2</option></optgroup><optgroup label=\"Group 2\"><option>Option 2.1</option><option>Option 2.2</option></optgroup></select>."
      },
      {
        "question": "Как можно изменить форму картинки или HTML элемента?",
        "answer": "Форму картинки или HTML элемента можно изменить с помощью CSS, задавая свойства, такие как border-radius для округления углов или transform для изменения размера, поворота или формы элемента."
      },
      {
        "question": "Чем отличается <article> от <section>?",
        "answer": "<article> представляет собой самостоятельный контент, который может существовать независимо от остального содержимого на странице, например, статья в блоге. <section> служит для группировки связанного контента и может содержать различные тематические блоки на странице."
      },
      {
        "question": "Расскажите об особенностях стилизации <svg>?",
        "answer": "SVG (Scalable Vector Graphics) поддерживает стилизацию с помощью CSS. Это позволяет изменять цвета, размеры, заливку и другие атрибуты графических элементов прямо в коде SVG или через внешние таблицы стилей."
      },
      {
        "question": "Разница между кнопкой и ссылкой в HTML?",
        "answer": "Кнопка (<button>) используется для создания интерактивных элементов, которые выполняют какие-то действия, например, отправка формы или выполнение JavaScript-функции. Ссылка (<a>) используется для перехода на другую страницу или ресурс по URL."
      },
      {
        "question": "Для чего используется атрибут decoding?",
        "answer": "Атрибут decoding в элементе <img> определяет, как браузер должен обрабатывать изображение при загрузке. Он может принимать значения async (параллельная загрузка), sync (последовательная загрузка) или auto (автоматическое определение)."
      },
      {
        "question": "Для чего используется атрибут enterkeyhint?",
        "answer": "Атрибут enterkeyhint указывает браузеру, какую операцию следует выполнить по нажатию клавиши Enter на клавиатуре для элемента ввода. Например, enterkeyhint=\"search\" подсказывает браузеру выполнить поиск."
      },
      {
        "question": "Для чего используют атрибут novalidate?",
        "answer": "Атрибут novalidate в элементе <form> предотвращает встроенную HTML5 валидацию формы при отправке данных на сервер. Это позволяет использовать пользовательскую валидацию формы с помощью JavaScript."
      },
      {
        "question": "Для чего используется атрибут inputmode?",
        "answer": "Атрибут inputmode в элементе <input> указывает браузеру, какой тип ввода ожидается от пользователя. Например, inputmode=\"numeric\" подсказывает браузеру использовать числовую клавиатуру на мобильных устройствах."
      },
      {
        "question": "Для чего используется атрибут pattern?",
        "answer": "Атрибут pattern в элементах <input> формы HTML используется для задания регулярного выражения, которое определяет допустимый формат вводимых пользователем данных."
      },
      {
        "question": "Что такое и зачем нужен атрибут rel=\"nofollow” в HTML?",
        "answer": "Атрибут rel=\"nofollow\" в HTML используется для указания поисковым системам, что ссылка не должна учитываться при расчёте рейтинга страницы, на которую указывает эта ссылка."
      },
      {
        "question": "Почему стоит использовать семантические теги в верстке?",
        "answer": "Использование семантических тегов в HTML помогает улучшить доступность и SEO-оптимизацию страницы, а также упрощает понимание её структуры разработчиками."
      },
      {
        "question": "Для чего используется тэг <label>?",
        "answer": "Тег <label> в HTML используется для связи текстовой метки с элементом формы (<input>, <select>, <textarea> и др.). Это улучшает удобство использования форм для пользователей."
      },
      {
        "question": "Способы улучшения производительности веб-страницы при использовании HTML?",
        "answer": "Для улучшения производительности веб-страницы можно использовать методы, такие как минимизация и объединение файлов CSS и JS, оптимизация изображений, использование асинхронной загрузки ресурсов, кэширование и т.д."
      },
      {
        "question": "Основные атрибуты HTML-форм? Как они влияют на отправку данных с веб-страницы?",
        "answer": "Основные атрибуты форм в HTML включают action (URL для отправки данных), method (метод отправки данных, например, GET или POST), name (имя формы для идентификации на сервере) и другие. Они определяют, как и куда отправлять данные, а также формат их представления."
      },
      {
        "question": "Какие HTML-элементы используются для создания и форматирования таблиц? Какие атрибуты у них есть?",
        "answer": "Для создания и форматирования таблиц в HTML используются элементы <table> (для создания таблицы), <tr> (для строк), <th> (для заголовков ячеек) и <td> (для ячеек данных). У них есть атрибуты для определения ширины, высоты, границ, выравнивания и других параметров."
      },
      {
        "question": "Расскажите о тэге <samp>?",
        "answer": "Тег <samp> в HTML используется для отображения примеров вывода компьютерной программы или скрипта. Он форматирует текст как моноширинный, обычно с использованием стиля по умолчанию для моноширинного текста в браузере."
      },
      {
        "question": "Для чего используется атрибут capture?",
        "answer": "Атрибут capture в элементах <input type=\"file\"> в HTML используется для указания, должно ли событие выбора файла быть захвачено в момент, когда пользователь выбирает файл, или только после того, как файл был выбран."
      }
    ]
  },
  {
    "position": "junior",
    "topic": "javascript",
    "questions": [
      {
        "question": "Типы данных в JavaScript?",
        "answer": "В JavaScript существует семь основных типов данных: \n1. Примитивные типы: \n- Number: для представления чисел (целых и вещественных). \n- String: для представления строк. \n- Boolean: для представления логических значений true или false. \n- Null: для представления намеренного отсутствия значения. \n- Undefined: для представления неопределённого значения. \n- Symbol: для создания уникальных идентификаторов. \n2. Объекты: \n- Object: для создания сложных структур данных."
      },
      {
        "question": "Разница между == и === (нестрогое/строгое равенство)?",
        "answer": "Оператор == сравнивает значения с приведением типов, что означает, что он пытается преобразовать операнды к одному типу перед сравнением. Например, '5' == 5 вернёт true. Оператор === сравнивает значения без приведения типов, то есть он учитывает и тип данных. Например, '5' === 5 вернёт false, потому что строка не равна числу."
      },
      {
        "question": "Что такое Strict mode в JavaScript?",
        "answer": "Strict mode (строгий режим) - это режим выполнения JavaScript, который вводит более строгие правила проверки кода и предотвращает использование некоторых функций. Он активируется добавлением строки 'use strict'; в начале скрипта или функции. В строгом режиме ошибки, которые в обычном режиме игнорируются, вызывают исключения, что помогает избежать потенциальных багов и улучшает производительность."
      },
      {
        "question": "Разница между function declaration и function expression?",
        "answer": "Function declaration (объявление функции) - это способ определения функции, когда её объявление начинается с ключевого слова function, за которым следует имя функции. Function expressions (функциональное выражение) создаются путём присвоения функции переменной. Основное отличие заключается в подъёме (hoisting): объявления функций поднимаются вверх области видимости, тогда как функциональные выражения - нет."
      },
      {
        "question": "Разница между null и undefined?",
        "answer": "Null и undefined - это примитивные типы данных, представляющие отсутствие значения. Undefined указывает на то, что переменная объявлена, но не имеет присвоенного значения. Null же используется для явного указания на отсутствие значения. В контексте сравнения null == undefined вернёт true, но null === undefined вернёт false."
      },
      {
        "question": "Типы таймеров в JavaScript?",
        "answer": "В JavaScript существуют два основных типа таймеров: \n1. setTimeout: используется для выполнения кода через определённое количество миллисекунд. Например, setTimeout(() => console.log('Hello'), 1000) выполнит код через 1 секунду. \n2. setInterval: используется для выполнения кода через регулярные промежутки времени. Например, setInterval(() => console.log('Hello'), 1000) будет выполнять код каждые 1 секунду. Оба метода возвращают идентификатор таймера, который можно использовать для отмены таймера с помощью clearTimeout и clearInterval соответственно."
      },
      {
        "question": "Что такое поднятие (Hoisting)?",
        "answer": "Поднятие (Hoisting) - это механизм в JavaScript, при котором объявления переменных и функций поднимаются в начало их области видимости перед выполнением кода. Это означает, что вы можете использовать функции и переменные до их фактического объявления в коде. Например, функция может быть вызвана до её объявления, но это не относится к функциональным выражениям."
      },
      {
        "question": "Что такое область видимости (Scope)?",
        "answer": "Область видимости (Scope) определяет видимость переменных и функций в разных частях кода. В JavaScript существует два типа областей видимости: \n1. Глобальная область видимости: переменные и функции, объявленные в глобальной области видимости, доступны в любом месте кода. \n2. Локальная область видимости: переменные и функции, объявленные внутри функций, доступны только внутри этих функций. В ES6 также была введена блочная область видимости, которая создаётся с помощью ключевых слов let и const внутри блоков кода."
      },
      {
        "question": "Разница между var, let и const?",
        "answer": "Var, let и const - это ключевые слова для объявления переменных в JavaScript. \n1. Var: имеет функциональную область видимости и поднимается в начало своей области видимости. Переменные, объявленные с помощью var, могут быть переопределены. \n2. Let: имеет блочную область видимости и не поднимается. Переменные, объявленные с помощью let, могут быть изменены, но не могут быть повторно объявлены в одной области видимости. \n3. Const: имеет блочную область видимости и не поднимается. Переменные, объявленные с помощью const, не могут быть изменены или повторно объявлены. Используется для объявления констант."
      },
      {
        "question": "Что такое замыкание (Closure)?",
        "answer": "Замыкание (Closure) - это функция, которая запоминает своё лексическое окружение, даже когда она выполняется вне своей первоначальной области видимости. Замыкания позволяют функциям иметь доступ к переменным из внешней функции после завершения её выполнения. Это достигается за счёт создания ссылки на внешние переменные в области видимости функции. Замыкания часто используются для создания приватных переменных и функций."
      },
      {
        "question": "Что обозначает this в JavaScript?",
        "answer": "This в JavaScript - это ключевое слово, которое ссылается на текущий контекст выполнения функции. Значение this зависит от контекста вызова функции: \n1. В методе объекта this ссылается на объект. \n2. В функции, вызываемой глобально, this ссылается на глобальный объект (window в браузере). \n3. В конструкторе this ссылается на создаваемый объект. \n4. В стрелочной функции this ссылается на контекст, в котором функция была объявлена."
      },
      {
        "question": "Что такое функции высшего порядка (Higher Order Functions)?",
        "answer": "Функции высшего порядка (Higher Order Functions) - это функции, которые могут принимать другие функции в качестве аргументов или возвращать их в качестве результата. Примеры таких функций включают map, filter, reduce и forEach. Эти функции позволяют более эффективно манипулировать и трансформировать данные."
      },
      {
        "question": "Как превратить любой тип данных в булевый? Перечислите ложные значения в JS?",
        "answer": "Для преобразования любого типа данных в булевый используется функция Boolean() или двойное отрицание (!!). Ложные значения в JavaScript включают: \n1. false \n2. 0 \n3. '' (пустая строка) \n4. null \n5. undefined \n6. NaN"
      },
      {
        "question": "Методы строк в JavaScript?",
        "answer": "Основные методы работы со строками в JavaScript включают: \n1. length - возвращает длину строки. \n2. charAt(index) - возвращает символ по указанному индексу. \n3. includes(substring) - проверяет, содержит ли строка подстроку. \n4. indexOf(substring) - возвращает индекс первого вхождения подстроки. \n5. slice(start, end) - возвращает подстроку. \n6. replace(searchValue, newValue) - заменяет подстроку. \n7. split(separator) - разделяет строку на массив подстрок. \n8. toUpperCase() и toLowerCase() - преобразуют строку в верхний и нижний регистры соответственно."
      },
      {
        "question": "Методы массивов в JavaScript?",
        "answer": "Основные методы работы с массивами в JavaScript включают: \n1. push() - добавляет элемент в конец массива. \n2. pop() - удаляет последний элемент массива. \n3. shift() - удаляет первый элемент массива. \n4. unshift() - добавляет элемент в начало массива. \n5. slice() - возвращает новый массив, содержащий копию части исходного массива. \n6. splice() - изменяет содержимое массива, удаляя или добавляя элементы. \n7. forEach() - выполняет функцию для каждого элемента массива. \n8. map() - создаёт новый массив, результат применения функции к каждому элементу массива. \n9. filter() - создаёт новый массив, содержащий элементы, прошедшие проверку функции. \n10. reduce() - применяет функцию к аккумулятору и каждому элементу массива, сводя его к единому значению."
      },
      {
        "question": "Что такое чистая функция?",
        "answer": "Чистая функция - это функция, которая при одинаковых входных данных всегда возвращает одинаковый результат и не имеет побочных эффектов, то есть не изменяет состояние внешних переменных. Чистые функции легче тестировать и отлаживать, они способствуют написанию предсказуемого и надёжного кода."
      },
      {
        "question": "Разница между .forEach() и .map()?",
        "answer": ".forEach() - это метод массива, который выполняет указанную функцию один раз для каждого элемента массива. Он не возвращает новый массив, а просто перебирает элементы. \n.map() - это метод массива, который создаёт новый массив, содержащий результаты вызова указанной функции для каждого элемента исходного массива. Он возвращает новый массив, не изменяя исходный."
      },
      {
        "question": "Разница между .call(), .apply() и bind()?",
        "answer": ".call() и .apply() - это методы для вызова функций с указанным this и аргументами. \n.call(thisArg, arg1, arg2, ...) принимает аргументы через запятую. \n.apply(thisArg, [argsArray]) принимает аргументы в виде массива. \n.bind(thisArg, arg1, arg2, ...) создаёт новую функцию, привязывая к ней указанное значение this и частично применённые аргументы, которые могут быть переданы позже."
      },
      {
        "question": "Почему в JS функции называют объектами первого класса?",
        "answer": "В JavaScript функции называют объектами первого класса, потому что они могут быть присвоены переменным, переданы в качестве аргументов другим функциям, возвращены из других функций и иметь методы и свойства. Это позволяет использовать функции гибко и динамично в коде."
      },
      {
        "question": "Как определить наличие свойства в объекте?",
        "answer": "Для определения наличия свойства в объекте используются два метода: \n1. Оператор in: 'property' in object возвращает true, если свойство существует в объекте или его прототипе. \n2. Метод .hasOwnProperty(): object.hasOwnProperty('property') возвращает true, если свойство существует непосредственно в объекте (не в его прототипе)."
      },
      {
        "question": "Что такое IIFE?",
        "answer": "IIFE (Immediately Invoked Function Expression) - это функция, которая определяется и сразу же вызывается. Такая функция создаёт локальную область видимости, защищая внутренние переменные и функции от внешнего доступа. Пример IIFE: (function() { /* код */ })();"
      },
      {
        "question": "Что такое псевдомассив arguments?",
        "answer": "Псевдомассив arguments — это объект, доступный внутри всех нестрелочных функций в JavaScript, который содержит все аргументы, переданные в функцию. Он похож на массив, но не является полноценным массивом и не имеет методов массивов, таких как .forEach() или .map(). Однако к его элементам можно обращаться по индексам, а также можно узнать количество аргументов через свойство .length. Пример использования arguments: \n\n```javascript\nfunction example() {\n  for (let i = 0; i < arguments.length; i++) {\n    console.log(arguments[i]);\n  }\n}\nexample(1, 2, 3); // Вывод: 1, 2, 3\n```"
      },
      {
        "question": "Разница между host-объектами и нативными объектами?",
        "answer": "Нативные (встроенные) объекты в JavaScript - это объекты, определенные спецификацией языка, такие как Array, Object, Function, Date и другие. Они являются частью самого языка JavaScript. \n\nХост-объекты - это объекты, предоставляемые окружением выполнения (например, браузером или Node.js), такие как window, document, console, XMLHttpRequest и другие. Эти объекты не определены спецификацией языка JavaScript, а предоставляются окружением, в котором выполняется код."
      },
      {
        "question": "Почему результат сравнения 2х объектов это false?",
        "answer": "В JavaScript объекты сравниваются по ссылке, а не по значению. Это означает, что два объекта считаются равными (=== или ==) только в том случае, если они ссылаются на одну и ту же область памяти. Даже если два объекта имеют одинаковые свойства и значения, они не равны, если не ссылаются на один и тот же объект в памяти. Пример: \n\n```javascript\nlet obj1 = { a: 1 };\nlet obj2 = { a: 1 };\nconsole.log(obj1 === obj2); // false\n```\nВ данном случае obj1 и obj2 — это разные объекты в памяти, поэтому результат сравнения — false."
      },
      {
        "question": "Что такое прототипное наследование? Как создать объект без прототипа?",
        "answer": "Прототипное наследование в JavaScript — это механизм, при котором объекты могут наследовать свойства и методы от других объектов. Каждый объект имеет скрытую ссылку (прототип), которая ссылается на другой объект. Когда к свойству объекта обращаются, JavaScript сначала ищет это свойство в самом объекте, а затем по цепочке прототипов. \n\nСоздать объект без прототипа можно с помощью метода Object.create(null). Такой объект не будет иметь наследуемых методов и свойств из Object.prototype: \n\n```javascript\nlet obj = Object.create(null);\nconsole.log(obj); // {}\nconsole.log(obj.toString); // undefined\n```"
      },
      {
        "question": "Почему расширение нативных JavaScript-объектов это плохая практика?",
        "answer": "Расширение нативных объектов JavaScript (таких как Array, Object, Function и т.д.) считается плохой практикой по нескольким причинам: \n1. Совместимость: Ваш код может конфликтовать с будущими версиями языка, если в них появятся методы с такими же именами.\n2. Поддержка: Расширение нативных объектов делает код менее предсказуемым и трудным для поддержки, так как это может привести к неожиданным результатам.\n3. Поломка библиотек: Если библиотеки или фреймворки, которые вы используете, также зависят от этих объектов, их работа может нарушиться из-за ваших изменений. Лучше использовать вспомогательные функции или создавать свои собственные классы и объекты для добавления новой функциональности."
      },
      {
        "question": "Что такое NaN? Как определить, что значение равно NaN?",
        "answer": "NaN (Not-a-Number) — это значение, которое указывает, что результат математической операции не является числом. Например, деление нуля на ноль или преобразование строки, которая не может быть интерпретирована как число, вернёт NaN. Важно отметить, что NaN не равен никакому значению, включая самого себя. Для проверки значения на NaN используется функция isNaN() или метод Number.isNaN() (в ES6): \n\n```javascript\nconsole.log(NaN === NaN); // false\nconsole.log(isNaN(NaN)); // true\nconsole.log(Number.isNaN(NaN)); // true\n```"
      },
      {
        "question": "Что такое объектная обертка (Wrapper Objects)?",
        "answer": "Объектные обертки (Wrapper Objects) в JavaScript — это объекты, которые временно создаются для примитивных значений (таких как строки, числа и булевы значения), чтобы позволить использовать методы и свойства, доступные только для объектов. Например, строка имеет методы, такие как .length, .toUpperCase(), которые доступны благодаря созданию временного объекта String: \n\n```javascript\nlet str = 'hello';\nconsole.log(str.toUpperCase()); // 'HELLO'\nconsole.log(str.length); // 5\n```\nПосле выполнения операции объектная обертка уничтожается."
      },
      {
        "question": "Как в JavaScript создать объект?",
        "answer": "В JavaScript объекты можно создать несколькими способами: \n1. Литерал объекта: \n\n```javascript\nlet obj = { key: 'value' };\n```\n2. Конструктор объекта: \n\n```javascript\nlet obj = new Object();\nobj.key = 'value';\n```\n3. Метод Object.create(): \n\n```javascript\nlet proto = { key: 'value' };\nlet obj = Object.create(proto);\n```\n4. С помощью класса (в ES6 и выше): \n\n```javascript\nclass MyClass {\n  constructor(key) {\n    this.key = key;\n  }\n}\nlet obj = new MyClass('value');\n```"
      },
      {
        "question": "Для чего используется ключевое слово new?",
        "answer": "Ключевое слово new используется для создания экземпляра объекта из функции-конструктора. Оно выполняет следующие действия: \n1. Создаёт новый пустой объект. \n2. Устанавливает прототип нового объекта на прототип конструктора. \n3. Вызывает конструктор с указанными аргументами и привязывает this к новому объекту. \n4. Возвращает новый объект, если конструктор явно не возвращает другой объект. Пример: \n\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\nlet person = new Person('John');\nconsole.log(person.name); // 'John'\n```"
      },
      {
        "question": "Операторы «И» и «ИЛИ» (&& и ||)?",
        "answer": "Операторы «И» (&&) и «ИЛИ» (||) — это логические операторы в JavaScript, используемые для выполнения логических операций: \n1. && (логическое И) возвращает true, если оба операнда истинны. Если первый операнд ложен, возвращается его значение, иначе возвращается значение второго операнда. Пример: \n\n```javascript\nconsole.log(true && false); // false\nconsole.log(1 && 2); // 2\n```\n2. || (логическое ИЛИ) возвращает true, если хотя бы один из операндов истинен. Если первый операнд истинен, возвращается его значение, иначе возвращается значение второго операнда. Пример: \n\n```javascript\nconsole.log(true || false); // true\nconsole.log(0 || 2); // 2\n```"
      },
      {
        "question": "Для чего используется оператор двойного отрицания (!!)?",
        "answer": "Оператор двойного отрицания (двойное восклицание, !!) используется для приведения значения к булевому типу. Первый оператор отрицания (!) преобразует значение в булевый тип и инвертирует его, второй оператор отрицания (!) снова инвертирует его, возвращая исходное булевое значение. Это полезно для явного преобразования значений в булевый тип. Пример: \n\n```javascript\nconsole.log(!!1); // true\nconsole.log(!!0); // false\nconsole.log(!!'hello'); // true\nconsole.log(!!null); // false\n```"
      },
      {
        "question": "Для чего используется оператор остатка (%)?",
        "answer": "Оператор остатка (%) используется для получения остатка от деления одного числа на другое. Он возвращает остаток после деления первого операнда на второй. Пример: \n\n```javascript\nconsole.log(10 % 3); // 1\nconsole.log(15 % 4); // 3\n```\nОператор остатка часто используется для определения чётности или нечётности числа (например, число % 2)."
      },
      {
        "question": "Как проверить, является ли значение массивом?",
        "answer": "Для проверки, является ли значение массивом, используется метод Array.isArray(): \n\n```javascript\nlet arr = [1, 2, 3];\nlet notArr = { a: 1 };\nconsole.log(Array.isArray(arr)); // true\nconsole.log(Array.isArray(notArr)); // false\n```\nТакже можно использовать метод obj instanceof Array, но он не всегда корректно работает в разных окружениях, например, при использовании iframe."
      },
      {
        "question": "Как работает boxing/unboxing в JavaScript?",
        "answer": "Boxing и unboxing — это процессы преобразования примитивных значений в объекты и обратно. \nBoxing: Когда примитивное значение (например, строка, число или булево значение) используется как объект (например, вызов метода или доступ к свойству), JavaScript автоматически создаёт объектную обертку (например, String, Number или Boolean). Пример: \n\n```javascript\nlet str = 'hello';\nconsole.log(str.toUpperCase()); // 'HELLO' (Boxing)\n```\nUnboxing: Когда метод или свойство объектной обертки возвращает примитивное значение, это значение автоматически преобразуется обратно в примитив. Пример: \n\n```javascript\nlet num = new Number(10);\nconsole.log(num + 5); // 15 (Unboxing)\n```"
      },
      {
        "question": "Что такое мемоизация? Реализуйте базовую логику функции для мемоизации?",
        "answer": "Мемоизация — это оптимизация производительности, при которой результат выполнения функции запоминается (кешируется), чтобы избежать повторных вычислений при одних и тех же входных данных. В JavaScript мемоизация часто реализуется с использованием замыканий. Вот пример базовой реализации функции для мемоизации:\n\n```javascript\nfunction memoize(func) {\n  let cache = {};\n  return function(...args) {\n    let key = JSON.stringify(args);\n    if (!cache[key]) {\n      cache[key] = func(...args);\n    }\n    return cache[key];\n  };\n}\n\n// Пример использования\nfunction factorial(n) {\n  if (n === 0 || n === 1) return 1;\n  return n * factorial(n - 1);\n}\n\nlet memoizedFactorial = memoize(factorial);\nconsole.log(memoizedFactorial(5)); // Запоминает и возвращает результат для 5\nconsole.log(memoizedFactorial(5)); // Использует кеш и возвращает результат\n```"
      },
      {
        "question": "Разница между оператором in и методом .hasOwnProperty()?",
        "answer": "Оператор in и метод .hasOwnProperty() используются для проверки наличия свойств в объекте, но есть разница в том, как они работают:\n\n1. Оператор in проверяет наличие свойства в объекте, включая унаследованные свойства из прототипа:\n\n```javascript\nlet obj = { a: 1 };\nconsole.log('a' in obj); // true\nconsole.log('toString' in obj); // true (наследованное от Object.prototype)\n```\n\n2. Метод .hasOwnProperty() проверяет, является ли свойство прямым свойством объекта и не унаследовано ли оно:\n\n```javascript\nlet obj = { a: 1 };\nconsole.log(obj.hasOwnProperty('a')); // true\nconsole.log(obj.hasOwnProperty('toString')); // false (унаследованное от Object.prototype)\n```\n"
      },
      {
        "question": "Разница между глубокой (deep) и поверхностной (shallow) копиями объекта? Как сделать каждую из них?",
        "answer": "Глубокая (deep) и поверхностная (shallow) копии объекта отличаются способом копирования вложенных объектов и ссылок:\n\n1. Поверхностная копия (shallow copy) создает новый объект, но копирует только ссылки на вложенные объекты. Изменения во вложенных объектах отразятся в обоих копии и исходном объекте:\n\n```javascript\nlet obj = { a: 1, b: { c: 2 } };\nlet shallowCopy = Object.assign({}, obj);\nshallowCopy.b.c = 3;\nconsole.log(obj.b.c); // 3 (изменение отразилось в исходном объекте)\n```\n\n2. Глубокая копия (deep copy) создает полностью независимую копию объекта, включая все вложенные объекты и их значения. Изменения в глубокой копии не отразятся на исходном объекте:\n\n```javascript\nlet obj = { a: 1, b: { c: 2 } };\nlet deepCopy = JSON.parse(JSON.stringify(obj));\ndeepCopy.b.c = 3;\nconsole.log(obj.b.c); // 2 (изменение не отразилось в исходном объекте)\n```\n"
      },
      {
        "question": "Что такое цепочка вызовов функций (chaining)? Как реализовать такой подход?",
        "answer": "Цепочка вызовов функций (chaining) — это техника написания кода, при которой методы вызываются последовательно на одном и том же объекте, что позволяет уменьшить количество кода и сделать его более читаемым. Для реализации цепочки вызовов необходимо, чтобы каждый метод возвращал ссылку на измененный объект (this):\n\n```javascript\nlet obj = {\n  value: 0,\n  increment: function() {\n    this.value++;\n    return this; // возвращаем ссылку на измененный объект\n  },\n  double: function() {\n    this.value *= 2;\n    return this; // возвращаем ссылку на измененный объект\n  }\n};\n\nobj.increment().double().increment();\nconsole.log(obj.value); // 3\n```\n"
      },
      {
        "question": "Что такое необъявленная переменная?",
        "answer": "Необъявленная переменная — это переменная, к которой происходит обращение без предварительного объявления с использованием var, let или const. В таком случае JavaScript автоматически создает глобальную переменную (если не используется strict mode), что может привести к неожиданным ошибкам и поведению:\n\n```javascript\nfunction example() {\n  undeclaredVar = 10; // необъявленная переменная\n}\nexample();\nconsole.log(undeclaredVar); // 10 (переменная создана глобально)\n```\nИспользование необъявленных переменных не рекомендуется, так как это снижает читаемость и поддерживаемость кода."
      },
      {
        "question": "Как передаются параметры в функцию: по ссылке или по значению?",
        "answer": "В JavaScript параметры функции передаются по значению. Это означает, что при вызове функции создаются копии значений аргументов, которые затем используются внутри функции. Если аргумент является объектом или массивом, передается копия ссылки на объект, что позволяет изменять его свойства или элементы массива внутри функции:\n\n```javascript\nfunction example(x, arr) {\n  x = 10; // изменение значения x не влияет на оригинальный аргумент\n  arr.push(4); // изменение массива arr изменяет оригинальный массив\n}\n\nlet num = 5;\nlet myArray = [1, 2, 3];\nexample(num, myArray);\nconsole.log(num); // 5\nconsole.log(myArray); // [1, 2, 3, 4]\n```"
      },
      {
        "question": "Что такое прототип объекта в JavaScript?",
        "answer": "Прототип объекта — это скрытая ссылка, которая указывает на другой объект, который используется как образец для создания новых объектов. В JavaScript все объекты имеют прототип, который используется для наследования свойств и методов:\n\n1. Каждый объект связан с прототипом, изначально указывающим на Object.prototype.\n2. Прототипы позволяют объектам наследовать методы и свойства других объектов.\n3. Доступ к прототипу осуществляется через свойство __proto__ объекта или метод Object.getPrototypeOf().\n\nПример:\n\n```javascript\nlet person = { name: 'John' };\nconsole.log(person.__proto__ === Object.prototype); // true\n```\n"
      },
      {
        "question": "Как работает метод Object.create()?",
        "answer": "Метод Object.create() создает новый объект с указанным прототипом и опционально набором свойств. Прототип может быть любым объектом или null. Он позволяет создавать объекты с заданным прототипом без необходимости определения конструктора. Пример использования:\n\n```javascript\nconst proto = { greet() { console.log('Hello!'); } };\nconst obj = Object.create(proto);\nobj.greet(); // выводит 'Hello!'\n```\n"
      },
      {
        "question": "Разница между Object.freeze() и Object.seal()?",
        "answer": "Методы Object.freeze() и Object.seal() используются для защиты объектов от изменений, но есть разница:\n\n1. Object.freeze() делает объект полностью неизменяемым (immutable), запрещая добавление, удаление или изменение свойств объекта и его прототипов.\n\n2. Object.seal() запрещает добавление и удаление свойств объекта, но позволяет изменять существующие свойства (их значения).\n\nПримеры:\n\n```javascript\nlet obj = { prop: 1 };\nObject.freeze(obj);\nobj.prop = 2; // не приведет к изменению\nconsole.log(obj.prop); // 1\n\nObject.seal(obj);\nobj.prop = 2; // можно изменять значение\nconsole.log(obj.prop); // 2\n```\n"
      },
      {
        "question": "Разница между методами .slice() и .splice()?",
        "answer": "Методы .slice() и .splice() используются для работы с массивами, но имеют различное поведение:\n\n1. .slice() создает новый массив, содержащий копию элементов от исходного массива, начиная с указанного индекса до конечного индекса (не включая его). Оригинальный массив не изменяется.\n\n```javascript\nlet arr = [1, 2, 3, 4, 5];\nlet sliced = arr.slice(1, 3); // [2, 3]\nconsole.log(arr); // [1, 2, 3, 4, 5]\n```\n\n2. .splice() изменяет исходный массив, удаляя, заменяя или добавляя элементы и возвращает массив удаленных элементов. Он изменяет массив на месте.\n\n```javascript\nlet arr = [1, 2, 3, 4, 5];\nlet removed = arr.splice(1, 2, 'a', 'b'); // удалит [2, 3], добавит ['a', 'b']\nconsole.log(arr); // [1, 'a', 'b', 4, 5]\n```\n"
      },
      {
        "question": "Как работают методы .find(), .findIndex() и .indexOf()?",
        "answer": "Методы .find(), .findIndex() и .indexOf() используются для поиска элементов в массиве, но имеют различное поведение:\n\n1. .find(callback) возвращает первый элемент массива, удовлетворяющий условию, заданному в callback-функции.\n\n```javascript\nlet arr = [1, 2, 3, 4, 5];\nlet found = arr.find(item => item > 3); // 4 (первый элемент больше 3)\n```\n\n2. .findIndex(callback) возвращает индекс первого элемента массива, удовлетворяющего условию, заданному в callback-функции.\n\n```javascript\nlet arr = [1, 2, 3, 4, 5];\nlet foundIndex = arr.findIndex(item => item > 3); // 3 (индекс первого элемента больше 3)\n```\n\n3. .indexOf(searchElement) возвращает первый индекс элемента, равного searchElement, или -1, если элемент не найден.\n\n```javascript\nlet arr = [1, 2, 3, 4, 5];\nlet index = arr.indexOf(3); // 2 (индекс элемента со значением 3)\n```\n"
      },
      {
        "question": "Плюсы и минусы использования use strict?",
        "answer": "use strict — это директива, введенная в ECMAScript 5, которая позволяет писать более строгий и безопасный код. Вот основные плюсы и минусы использования use strict:\n\nПлюсы:\n- Запрещает использование необъявленных переменных.\n- Запрещает удаление переменных, функций и аргументов функций.\n- Вызов eval() выполняется в отдельной области видимости.\n- Запрещает использование некоторых потенциально опасных функций (например, with).\n\nМинусы:\n- Не поддерживается старыми браузерами (поддержка начинается с IE10 и других современных версий).\n- Может нарушить совместимость с старыми скриптами, написанными без использования строгого режима.\n"
      },
      {
        "question": "Разница между методами .push(), .pop(), .shift() и .unshift()?",
        "answer": "Методы .push(), .pop(), .shift() и .unshift() используются для работы с концом или началом массива:\n\n1. .push(item) добавляет элемент в конец массива и возвращает новую длину массива.\n\n```javascript\nlet arr = [1, 2, 3];\nlet length = arr.push(4); // 4 (новая длина массива)\nconsole.log(arr); // [1, 2, 3, 4]\n```\n\n2. .pop() удаляет последний элемент из массива и возвращает его значение.\n\n```javascript\nlet arr = [1, 2, 3];\nlet lastElement = arr.pop(); // 3 (удаленный элемент)\nconsole.log(arr); // [1, 2]\n```\n\n3. .shift() удаляет первый элемент из массива и возвращает его значение.\n\n```javascript\nlet arr = [1, 2, 3];\nlet firstElement = arr.shift(); // 1 (удаленный элемент)\nconsole.log(arr); // [2, 3]\n```\n\n4. .unshift(item) добавляет элемент в начало массива и возвращает новую длину массива.\n\n```javascript\nlet arr = [1, 2, 3];\nlet length = arr.unshift(0); // 4 (новая длина массива)\nconsole.log(arr); // [0, 1, 2, 3]\n```\n"
      },
      {
        "question": "Плюсы и минусы иммутабельности? Как достичь иммутабельности в JS?",
        "answer": "Иммутабельность (неизменяемость) — это концепция, при которой объект или его состояние не может быть изменено после создания. Вот основные плюсы и минусы иммутабельности:\n\nПлюсы:\n- Упрощает отладку и предсказуемость программы.\n- Улучшает производительность, так как не требует множественных копий объектов.\n- Предотвращает несанкционированные изменения.\n\nМинусы:\n- Может потребовать больше памяти для создания новых объектов.\n- Требует дополнительных усилий для реализации в некоторых случаях.\n\nДля достижения иммутабельности в JavaScript можно использовать следующие методы:\n- Использование методов массивов, которые возвращают новый массив вместо изменения существующего (например, .concat(), .slice()).\n- Использование Object.freeze() для замораживания объекта.\n- Использование библиотек или фреймворков, поддерживающих неизменяемость данных.\n"
      },
      {
        "question": "Типы всплывающих окон в JavaScript?",
        "answer": "В JavaScript есть несколько типов всплывающих окон:\n\n1. Alert: окно с сообщением для пользователя, останавливающее выполнение скрипта до его закрытия.\n\n```javascript\nalert('Hello, world!');\n```\n\n2. Confirm: окно с сообщением и кнопками подтверждения (OK/Cancel). Возвращает true при нажатии OK и false при нажатии Cancel.\n\n```javascript\nlet result = confirm('Are you sure?');\nconsole.log(result); // true/false\n```\n\n3. Prompt: окно с сообщением и полем для ввода текста. Возвращает введенное значение или null, если нажат Cancel.\n\n```javascript\nlet name = prompt('Enter your name:');\nconsole.log(name); // введенное имя или null\n```\n\nЭти методы являются частью объекта window и доступны в браузерной среде."
      },
      {
        "question": "Типы объектов JavaScript?",
        "answer": "В JavaScript существует несколько типов объектов:\n\n1. Встроенные объекты (Built-in Objects): например, Object, Array, Date, Function, RegExp и другие.\n\n2. Хост-объекты (Host Objects): предоставляются окружением выполнения JavaScript, таким как браузер или Node.js.\n\n3. Пользовательские объекты (User-defined Objects): созданные пользователем с помощью функций-конструкторов или классов.\n\nКаждый тип объекта имеет свои методы и свойства, определенные для работы с соответствующими данными и функциональностью."
      },
      {
        "question": "Парадигмы программирования в JavaScript?",
        "answer": "JavaScript поддерживает несколько парадигм программирования:\n\n1. Процедурное программирование: организация кода в процедуры или функции для выполнения определенных задач.\n\n2. Объектно-ориентированное программирование (ООП): создание объектов, которые могут содержать данные (поля) и методы для работы с этими данными.\n\n3. Функциональное программирование: фокус на функциях как на основных строительных блоках программы, поддержка замыканий и функций высшего порядка.\n\n4. Событийно-ориентированное программирование: обработка событий и асинхронных действий, таких как клики, загрузки и таймеры.\n\nЭти парадигмы могут использоваться отдельно или в комбинации для создания сложных приложений в JavaScript."
      },
      {
        "question": "Типы ошибок в JavaScript?",
        "answer": "Ошибки в JavaScript делятся на несколько основных типов:\n\n1. SyntaxError: ошибка синтаксиса, возникающая при нарушении правил языка (например, отсутствие закрывающей скобки).\n\n2. ReferenceError: ошибка, возникающая при попытке доступа к несуществующей переменной или объекту.\n\n3. TypeError: ошибка, возникающая при операциях с несовместимыми типами данных (например, попытка вызвать метод у null или undefined).\n\n4. RangeError: ошибка, возникающая при выходе за границы допустимого диапазона значений (например, при передаче слишком большого значения в функцию).\n\n5. EvalError: редко используемая ошибка, связанная с функцией eval(), когда возникают проблемы при выполнении скрипта, переданного в виде строки.\n\n6. URIError: ошибка, возникающая при некорректном использовании URI-функций (например, decodeURIComponent при неверно закодированном URI).\n\nКаждый тип ошибки предоставляет информацию о том, в каком месте кода произошла ошибка, что помогает разработчику быстрее ее исправить."
      },
      {
        "question": "Разница между typeof и instanceof?",
        "answer": "Разница между операторами typeof и instanceof в JavaScript:\n\n1. typeof: оператор, возвращающий тип операнда в виде строки. Он может быть использован для определения типа примитивных данных и функций, а также для определения, существует ли переменная.\n\n```javascript\ntypeof 42; // 'number'\ntypeof 'Hello'; // 'string'\ntypeof true; // 'boolean'\ntypeof undefined; // 'undefined'\ntypeof null; // 'object'\ntypeof {}; // 'object'\ntypeof []; // 'object'\ntypeof function() {}; // 'function'\n```\n\n2. instanceof: оператор, проверяющий, принадлежит ли объект к определенному классу (типу). Он основан на прототипах и используется для проверки наследования.\n\n```javascript\nlet arr = [];\narr instanceof Array; // true\narr instanceof Object; // true, так как Array наследует от Object\n```\n\nРазница в том, что typeof возвращает тип данных, в то время как instanceof проверяет принадлежность объекта к конкретному типу."
      },
      {
        "question": "JavaScript статически, или динамически типизированный язык?",
        "answer": "JavaScript является динамически типизированным языком программирования. Это означает, что типы данных переменных определяются автоматически во время выполнения программы, а не во время компиляции. Переменные в JavaScript могут хранить значения разных типов и могут изменять свой тип во время выполнения.\n\nПримеры:\n\n```javascript\nlet x = 42; // x является числом\nx = 'Hello'; // теперь x является строкой\n```\n\nСтатически типизированные языки, например, Java или C#, требуют явного указания типов переменных при их объявлении и проверяют типы на этапе компиляции."
      },
      {
        "question": "Что такое регулярное выражение (Regular Expression)?",
        "answer": "Регулярное выражение (или regexp) — это последовательность символов, используемая для поиска и манипуляций с текстом на основе шаблона. В JavaScript регулярные выражения представлены объектами класса RegExp и используются с методами строк для поиска и замены текста.\n\nПримеры использования:\n\n```javascript\nlet pattern = /test/; // простое регулярное выражение\nlet str = 'Testing JavaScript';\nconsole.log(pattern.test(str)); // true, если 'test' найдено в строке\nconsole.log(str.match(pattern)); // ['test'], массив с найденными совпадениями\n```\n\nРегулярные выражения позволяют выполнять сложные операции поиска и замены, такие как поиск всех email-адресов или проверка валидности ввода пользователей."
      },
      {
        "question": "Что такое рекурсия?",
        "answer": "Рекурсия — это процесс, в котором функция вызывает саму себя напрямую или через другие функции. В JavaScript рекурсия является мощным инструментом для решения задач, которые могут быть разделены на более маленькие подзадачи того же типа. Рекурсивные функции состоят из двух частей:\n\n1. Базовый случай (Base Case): условие, при котором функция прекращает рекурсивные вызовы и возвращает конечный результат.\n\n2. Рекурсивный случай (Recursive Case): условие, при котором функция вызывает саму себя для решения более маленькой подзадачи.\n\nПример вычисления факториала с использованием рекурсии:\n\n```javascript\nfunction factorial(n) {\n  if (n === 0) {\n    return 1; // базовый случай\n  } else {\n    return n * factorial(n - 1); // рекурсивный случай\n  }\n}\nconsole.log(factorial(5)); // 120\n```\n\nРекурсия должна быть использована осторожно, чтобы избежать бесконечных циклов и ненужного расхода памяти."
      },
      {
        "question": "Что такое прототип (Prototype) объекта?",
        "answer": "Прототип объекта в JavaScript — это механизм, который позволяет объектам наследовать свойства и методы от других объектов. У каждого объекта в JavaScript есть ссылка на свой прототип, и если свойство или метод не найдены в самом объекте, JavaScript ищет их в прототипе. Прототипное наследование позволяет создавать иерархии объектов без использования классов, как это делается в классическом наследовании."
      },
      {
        "question": "Какие методы используются в регулярных выражениях?",
        "answer": "В JavaScript для работы с регулярными выражениями используются следующие методы:\n1. **test()**: проверяет, совпадает ли регулярное выражение с указанной строкой, возвращая true или false.\n2. **exec()**: выполняет поиск совпадений регулярного выражения в строке и возвращает найденное совпадение в виде массива.\n3. **match()**: возвращает массив совпадений строки с регулярным выражением.\n4. **search()**: возвращает позицию первого совпадения регулярного выражения в строке, или -1, если совпадений нет.\n5. **replace()**: заменяет совпадения регулярного выражения в строке на указанную подстроку или результат выполнения функции.\n6. **split()**: разделяет строку на массив строк по совпадениям с регулярным выражением."
      },
      {
        "question": "Что такое полифил (polyfill)?",
        "answer": "Полифил (polyfill) — это программный код, написанный на JavaScript, который обеспечивает реализацию функциональности, недоступной в старых версиях языка или окружения. Полифил позволяет использовать новые возможности JavaScript (или API) в более старых браузерах или средах, которые их не поддерживают нативно. Например, полифил может реализовывать методы массивов, которые были добавлены в более поздних версиях ECMAScript, чтобы они работали в старых версиях браузеров, не поддерживающих эти методы."
      },
      {
        "question": "Что такое switch/case? Правила использования switch/case?",
        "answer": "switch/case — это конструкция в JavaScript, которая позволяет проверять значение выражения на соответствие определенным кейсам (случаям). Она предоставляет более удобную замену для последовательного использования оператора if/else.\n\nПравила использования switch/case:\n1. Выражение в switch должно вычисляться в одно значение (обычно строка или число).\n2. Кейсы (case) содержат константные значения, которые сравниваются с выражением switch.\n3. Каждый кейс может содержать блок кода (statements), который выполняется при совпадении значения выражения с кейсом.\n4. Оператор break используется для выхода из switch после выполнения блока кода кейса. Если break опущен, выполнение продолжится с следующего кейса (fall-through).\n5. Конструкция default задает блок кода, который выполняется, если ни один из кейсов не совпал с выражением switch."
      },
      {
        "question": "Типы функций по способности принимать другие функции?",
        "answer": "Функции в JavaScript могут быть классифицированы по способности принимать другие функции:\n1. **Функции высшего порядка (Higher Order Functions)**: функции, которые принимают другие функции в качестве аргументов или возвращают функцию как результат. Примеры: функции обратного вызова (callback functions), функции высшего порядка из стандартных методов массивов (например, map, filter).\n2. **Функции обратного вызова (Callback Functions)**: функции, передаваемые в другие функции в качестве аргумента, чтобы быть вызванными в будущем (часто асинхронно).\n3. **Функции первого класса (First-Class Functions)**: функции, которые могут быть присвоены переменной, переданы в другую функцию или возвращены из функции как результат."
      },
      {
        "question": "Что такое выражения (expression) и инструкции (statement) в JavaScript?",
        "answer": "В JavaScript выражение (expression) — это фрагмент кода, который вычисляется в значение. Выражения могут быть простыми (например, числа или строки) или составными (например, арифметические операции, вызовы функций, условные выражения).\n\nИнструкция (statement) — это инструкция или команда, которая выполняет какое-либо действие. Она может включать в себя выражения, условия, циклы или вызовы функций. Инструкции могут быть простыми (например, присваивание переменной) или составными (например, блок кода в функции или цикле).\n\nПримеры:\n- Выражения: `5 + 3`, `myFunction()`, `(a > b) ? a : b`\n- Инструкции: `let x = 5;`, `if (x === 5) { alert('Equal'); }`, `for (let i = 0; i < 10; i++) { console.log(i); }`\n\nВыражения могут быть частью инструкций, но не каждая инструкция является выражением."
      },
      {
        "question": "Разница между .some() и .every()?",
        "answer": "Разница между методами .some() и .every() в JavaScript:\n\n1. **.some()**: проверяет, удовлетворяет ли хотя бы один элемент массива условию, заданному в переданной функции обратного вызова. Возвращает true, если хотя бы один элемент удовлетворяет условию, иначе false.\n\n2. **.every()**: проверяет, удовлетворяют ли все элементы массива условию, заданному в переданной функции обратного вызова. Возвращает true, если все элементы удовлетворяют условию, иначе false.\n\nПримеры использования:\n```javascript\nlet numbers = [10, 20, 30, 40, 50];\nlet isAnyEven = numbers.some(num => num % 2 === 0); // true, так как есть четное число\nlet allEven = numbers.every(num => num % 2 === 0); // false, так как не все числа четные\n```"
      },
      {
        "question": "Как сгенерировать случайное число в JavaScript?",
        "answer": "Для генерации случайного числа в JavaScript используется метод Math.random(). Этот метод возвращает псевдослучайное число с плавающей запятой в диапазоне от 0 (включительно) до 1 (исключительно).\n\nДля генерации случайного целого числа в определенном диапазоне можно использовать следующую формулу:\n```javascript\nfunction getRandomInt(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n```\nЭта функция возвращает случайное целое число между min (включительно) и max (включительно)."
      },
      {
        "question": "Типы операторов в JavaScript?",
        "answer": "В JavaScript существует несколько типов операторов:\n\n1. **Арифметические операторы**: +, -, *, /, %, ++, -- (например, сложение, вычитание, умножение, деление, остаток от деления, инкремент, декремент).\n\n2. **Сравнительные операторы**: ==, !=, ===, !==, >, <, >=, <= (например, равенство, неравенство, строгое равенство, строгое неравенство, больше, меньше, больше или равно, меньше или равно).\n\n3. **Логические операторы**: &&, ||, ! (например, логическое И, логическое ИЛИ, логическое НЕ).\n\n4. **Операторы присваивания**: =, +=, -=, *=, /=, %= (например, присваивание, присваивание с добавлением, присваивание с вычитанием, присваивание с умножением, присваивание с делением, присваивание с остатком).\n\n5. **Операторы побитовых операций**: &, |, ^, ~, <<, >>, >>> (например, побитовое И, побитовое ИЛИ, побитовое исключающее ИЛИ, побитовое НЕ, побитовый сдвиг влево, побитовый сдвиг вправо, побитовый сдвиг вправо с заполнением нулями).\n\n6. **Тернарный оператор**: ? : (например, условный оператор, возвращающий одно из двух значений в зависимости от условия).\n\n7. **Операторы типа**: typeof, instanceof (например, определение типа переменной, проверка принадлежности объекта к определенному классу).\n\n8. **Другие операторы**: delete, void, in, new, this (например, удаление свойства объекта, возвращение undefined, проверка наличия свойства в объекте, создание нового экземпляра объекта, доступ к текущему контексту)."
      },
      {
        "question": "Разница между параметром и аргументом функции?",
        "answer": "Параметры и аргументы функций часто используются как взаимозаменяемые термины, но между ними есть различие:\n\n- **Параметры**: переменные, указанные в объявлении функции и принимающие значения при вызове функции. Они представляют собой «место» для значений, которые функция ожидает получить. Пример: в объявлении `function sum(a, b)`, `a` и `b` — параметры.\n- **Аргументы**: фактические значения, передаваемые функции при ее вызове. Пример: в вызове `sum(5, 10)`, `5` и `10` — аргументы.\n\nТаким образом, параметры — это переменные, определенные в функции, а аргументы — это значения, передаваемые при вызове функции."
      },
      {
        "question": "Правила задания имён для переменных и функций в JavaScript?",
        "answer": "Правила именования переменных и функций в JavaScript включают:\n\n1. **Буквы и цифры**: имена могут содержать буквы, цифры, символы `$` и `_`, но не могут начинаться с цифры.\n2. **Регистрозависимость**: имена переменных и функций чувствительны к регистру, например, `myVar` и `myvar` — разные имена.\n3. **Зарезервированные слова**: нельзя использовать зарезервированные слова JavaScript (например, `if`, `for`, `class`) в качестве имен переменных или функций.\n4. **Читабельность и ясность**: используйте описательные имена, которые четко указывают на предназначение переменной или функции.\n5. **CamelCase**: для многословных имен обычно используется camelCase, например, `myVariableName` или `calculateTotalSum`."
      },
      {
        "question": "Разница между явным и неявным преобразованием (Implicit and Explicit Coercion)?",
        "answer": "В JavaScript преобразование типов может быть явным (explicit) и неявным (implicit):\n\n- **Явное преобразование (Explicit Coercion)**: когда разработчик явно указывает преобразование одного типа данных в другой с помощью встроенных функций или операторов. Примеры: `Number('123')`, `String(456)`, `Boolean(0)`.\n- **Неявное преобразование (Implicit Coercion)**: происходит автоматически, когда JavaScript предполагает, что нужно преобразовать тип данных для выполнения операции. Примеры: `123 + '456'` (результат будет строкой '123456'), `true + 1` (результат будет числом 2).\n\nЯвное преобразование более контролируемое и предсказуемое, в то время как неявное может привести к неожиданным результатам."
      },
      {
        "question": "Для чего применяется метод Array.from()?",
        "answer": "Метод `Array.from()` используется для создания нового массива из массивоподобных или итерируемых объектов. Он также может применять функцию для каждого элемента нового массива.\n\nПримеры использования:\n\n1. Преобразование строк в массив символов:\n```javascript\nlet str = 'hello';\nlet arr = Array.from(str); // ['h', 'e', 'l', 'l', 'o']\n```\n\n2. Преобразование объекта NodeList в массив:\n```javascript\nlet nodeList = document.querySelectorAll('div');\nlet arr = Array.from(nodeList);\n```\n\n3. Применение функции к каждому элементу нового массива:\n```javascript\nlet numbers = Array.from([1, 2, 3], x => x * 2); // [2, 4, 6]\n```"
      },
      {
        "question": "Назовите способы преобразования массива в объект?",
        "answer": "Существует несколько способов преобразования массива в объект в JavaScript:\n\n1. **Использование метода reduce()**:\n```javascript\nlet arr = ['a', 'b', 'c'];\nlet obj = arr.reduce((acc, cur, index) => {\n  acc[index] = cur;\n  return acc;\n}, {});\n// {0: 'a', 1: 'b', 2: 'c'}\n```\n\n2. **Использование метода Object.assign()**:\n```javascript\nlet arr = ['a', 'b', 'c'];\nlet obj = Object.assign({}, arr);\n// {0: 'a', 1: 'b', 2: 'c'}\n```\n\n3. **Использование метода Object.fromEntries()**:\n```javascript\nlet arr = [['key1', 'value1'], ['key2', 'value2']];\nlet obj = Object.fromEntries(arr);\n// {key1: 'value1', key2: 'value2'}\n```"
      },
      {
        "question": "Разница между Object и Map?",
        "answer": "Разница между `Object` и `Map` в JavaScript:\n\n1. **Ключи**:\n   - В `Object` ключи всегда преобразуются в строки. Это значит, что ключи, например, числа, будут преобразованы в строки.\n   - В `Map` ключи могут быть любого типа, включая объекты, функции и примитивные значения.\n\n2. **Порядок ключей**:\n   - В `Object` порядок ключей не гарантируется и зависит от реализации движка JavaScript.\n   - В `Map` порядок ключей сохраняется в порядке их вставки.\n\n3. **Итерация**:\n   - Для итерации по `Object` необходимо использовать методы `Object.keys()`, `Object.values()` или `Object.entries()`.\n   - `Map` поддерживает методы итерации напрямую, такие как `map.keys()`, `map.values()`, `map.entries()`.\n\n4. **Производительность**:\n   - `Map` оптимизирован для частых операций добавления и удаления элементов, особенно когда используются сложные ключи."
      },
      {
        "question": "Что такое каррирование?",
        "answer": "Каррирование (Currying) — это техника преобразования функции, принимающей несколько аргументов, в последовательность функций, каждая из которых принимает один аргумент и возвращает новую функцию, которая принимает следующий аргумент. Каррирование позволяет фиксировать некоторые аргументы функции, создавая частично применённые функции.\n\nПример каррирования:\n```javascript\nfunction add(a) {\n  return function(b) {\n    return a + b;\n  };\n}\n\nlet addFive = add(5);\nconsole.log(addFive(3)); // 8\n```\n\nВ этом примере функция `add` принимает один аргумент `a` и возвращает функцию, которая принимает второй аргумент `b` и возвращает сумму `a` и `b`."
      },
      {
        "question": "Для чего используются метод Object.seal()?",
        "answer": "Метод `Object.seal()` используется для запечатывания объекта, предотвращая добавление новых свойств и удаление существующих. При этом значения существующих свойств остаются изменяемыми.\n\nПример использования:\n```javascript\nlet obj = {a: 1, b: 2};\nObject.seal(obj);\n\nobj.a = 3; // Можно изменить существующее свойство\nobj.c = 4; // Нельзя добавить новое свойство (тихо игнорируется или вызывает ошибку в строгом режиме)\ndelete obj.b; // Нельзя удалить существующее свойство (тихо игнорируется или вызывает ошибку в строгом режиме)\n```\n\n`Object.seal()` полезен, когда нужно предотвратить расширение объекта, но при этом сохранить возможность изменения существующих свойств."
      },
      {
        "question": "Для чего используется свойство .dataset?",
        "answer": "Свойство `.dataset` используется для работы с пользовательскими атрибутами `data-*` в HTML-элементах. Оно предоставляет удобный интерфейс для получения и установки значений этих атрибутов.\n\nПример использования:\nHTML:\n```html\n<div id=\"myDiv\" data-user-id=\"123\" data-role=\"admin\"></div>\n```\nJavaScript:\n```javascript\nlet div = document.getElementById('myDiv');\nconsole.log(div.dataset.userId); // '123'\nconsole.log(div.dataset.role); // 'admin'\n\ndiv.dataset.role = 'user';\nconsole.log(div.dataset.role); // 'user'\n```\n\nСвойство `.dataset` автоматически преобразует имена атрибутов `data-*` в свойства объекта с camelCase-именованием. Это позволяет легко читать и изменять значения пользовательских атрибутов в JavaScript-коде."
      },
      {
        "question": "Каким образом можно обмениваться кодом между файлами?",
        "answer": "В JavaScript существует несколько способов обмена кодом между файлами:\n\n1. **Модули ES6**: Использование `import` и `export` для импорта и экспорта функций, объектов или переменных между файлами. Пример:\n```javascript\n// file1.js\nexport const myFunction = () => { ... };\n\n// file2.js\nimport { myFunction } from './file1.js';\nmyFunction();\n```\n\n2. **CommonJS**: Использование `module.exports` и `require` в Node.js. Пример:\n```javascript\n// file1.js\nmodule.exports = function() { ... };\n\n// file2.js\nconst myFunction = require('./file1');\nmyFunction();\n```\n\n3. **Использование глобальных переменных**: Объявление переменных в глобальной области видимости и доступ к ним из других файлов. Этот метод не рекомендуется из-за возможных конфликтов имён и проблем с поддержкой кода.\n\n4. **Бандлеры модулей**: Использование инструментов, таких как Webpack или Rollup, для объединения модулей в один файл, что облегчает управление зависимостями и обмен кодом."
      },
      {
        "question": "Как работает «сборщик мусора» в JavaScript?",
        "answer": "Сборщик мусора в JavaScript автоматически управляет памятью, освобождая её от объектов, которые больше не используются. Основной алгоритм сборки мусора — это сборка мусора с подсчетом ссылок и сборка мусора с отслеживанием. В браузерах часто используется второй подход — сборка мусора с отслеживанием, называемая «маркировка и очистка» (mark-and-sweep).\n\nРабота сборщика мусора включает следующие шаги:\n\n1. **Маркировка**: сборщик мусора просматривает все объекты, до которых можно добраться из корневых объектов (например, глобальных переменных и объектов стека вызовов).\n\n2. **Сборка**: объекты, которые не были отмечены как достижимые, считаются мусором и их память освобождается.\n\nЭтот процесс выполняется периодически и автоматически, что позволяет разработчикам не заботиться о явном управлении памятью."
      },
      {
        "question": "Что такое утечки памяти?",
        "answer": "Утечки памяти — это ситуации, когда программа потребляет больше памяти, чем необходимо, из-за того, что ненужные объекты продолжают существовать в памяти и не удаляются сборщиком мусора. Утечки памяти могут приводить к снижению производительности и даже к сбоям приложения из-за исчерпания памяти."
      },
      {
        "question": "Назовите основные типы утечек памяти в JavaScript?",
        "answer": "Основные типы утечек памяти в JavaScript включают:\n\n1. **Захваченные переменные**: когда замыкания захватывают переменные, которые больше не нужны, но не освобождаются.\n\n2. **Ссылки на DOM**: когда объекты DOM не удаляются должным образом и продолжают ссылаться на элементы, которые больше не нужны.\n\n3. **Глобальные переменные**: когда переменные объявляются в глобальной области видимости и не освобождаются после использования.\n\n4. **Забытые таймеры и обратные вызовы**: когда таймеры или обработчики событий не удаляются после их использования, продолжая ссылаться на объекты."
      },
      {
        "question": "Как работает контекст выполнения (execution context) в JavaScript?",
        "answer": "Контекст выполнения (execution context) в JavaScript — это среда, в которой выполняется код. Существует три типа контекста выполнения:\n\n1. **Глобальный контекст**: создаётся при загрузке страницы или выполнения скрипта. Он содержит глобальные объекты и функции.\n\n2. **Функциональный контекст**: создаётся при вызове каждой функции. Он включает локальные переменные, параметры и другие функции, объявленные внутри этой функции.\n\n3. **Контекст eval()**: создаётся при выполнении кода внутри функции `eval()`.\n\nКонтекст выполнения создаётся в три этапа:\n\n1. **Создание**: инициализация переменных, функции и параметров. Создание `this` и ссылки на внешний контекст (scope chain).\n\n2. **Исполнение**: присваивание значений переменным и выполнение кода.\n\n3. **Завершение**: после выполнения кода контекст выполнения уничтожается, за исключением глобального контекста."
      },
      {
        "question": "Разница между примитивом и объектом?",
        "answer": "В JavaScript примитивы и объекты имеют ключевые различия:\n\n- **Примитивы**: представляют собой простые значения, которые не имеют методов и свойств. Примитивы включают `string`, `number`, `boolean`, `null`, `undefined` и `symbol`. Они неизменяемы (immutable), что означает, что их значения нельзя изменять после создания.\n\n- **Объекты**: являются коллекциями свойств и методов. Они изменяемы (mutable), что означает, что их значения и структура могут изменяться после создания. Объекты включают массивы, функции и любые пользовательские объекты.\n\nПримитивы передаются по значению, тогда как объекты передаются по ссылке."
      },
      {
        "question": "Что значит текст max call stack size exceeded в консоли?",
        "answer": "Сообщение «max call stack size exceeded» в консоли означает, что стек вызовов (call stack) переполнен из-за слишком большого количества вызовов функций. Это часто происходит в результате бесконечной рекурсии или слишком глубокой вложенности вызовов функций.\n\nПример бесконечной рекурсии:\n```javascript\nfunction recursiveFunction() {\n  recursiveFunction();\n}\n\nrecursiveFunction(); // Приведет к max call stack size exceeded\n```\n\nДля предотвращения этой ошибки необходимо убедиться, что рекурсивные функции имеют базовый случай для завершения и избегать слишком глубокой вложенности вызовов."
      },
      {
        "question": "Как реализовать отложенную загрузку изображений?",
        "answer": "Отложенная загрузка изображений (lazy loading) позволяет загружать изображения только тогда, когда они становятся видимыми на экране. Это улучшает производительность и сокращает время загрузки страницы. Для реализации отложенной загрузки можно использовать атрибут `loading` или JavaScript.\n\n1. **С использованием атрибута loading** (поддерживается не всеми браузерами):\n```html\n<img src=\"image.jpg\" loading=\"lazy\" alt=\"Description\">\n```\n\n2. **С использованием JavaScript и Intersection Observer API**:\n```html\n<img data-src=\"image.jpg\" alt=\"Description\" class=\"lazy-load\">\n<script>\ndocument.addEventListener(\"DOMContentLoaded\", function() {\n  let lazyImages = document.querySelectorAll(\".lazy-load\");\n  let observer = new IntersectionObserver(function(entries, observer) {\n    entries.forEach(function(entry) {\n      if (entry.isIntersecting) {\n        let img = entry.target;\n        img.src = img.dataset.src;\n        img.classList.remove(\"lazy-load\");\n        observer.unobserve(img);\n      }\n    });\n  });\n  lazyImages.forEach(function(img) {\n    observer.observe(img);\n  });\n});\n</script>\n```"
      },
      {
        "question": "Чем отличаются события input и change?",
        "answer": "События `input` и `change` используются для отслеживания изменений в элементах формы, но они имеют различия:\n\n- **input**: срабатывает каждый раз, когда значение элемента формы изменяется. Это событие полезно для отслеживания мгновенных изменений, таких как ввод текста в текстовое поле.\n\nПример:\n```html\n<input type=\"text\" id=\"myInput\">\n<script>\ndocument.getElementById('myInput').addEventListener('input', function() {\n  console.log('Input event fired');\n});\n</script>\n```\n\n- **change**: срабатывает, когда элемент формы теряет фокус после изменения его значения. Это событие полезно для отслеживания завершенных изменений, таких как выбор значения из выпадающего списка или завершение ввода в текстовое поле.\n\nПример:\n```html\n<input type=\"text\" id=\"myInput\">\n<script>\ndocument.getElementById('myInput').addEventListener('change', function() {\n  console.log('Change event fired');\n});\n</script>\n```"
      },
      {
        "question": "Почему typeof null возвращает object?",
        "answer": "Результат `typeof null` возвращает `object` из-за бага в ранних версиях JavaScript, который был сохранен для совместимости с существующим кодом. В спецификации JavaScript `null` считается специальным значением, представляющим отсутствие какого-либо объекта. Однако из-за исторической ошибки тип `null` был определен как объект, и это поведение сохранилось.\n\nХотя это может быть запутанным, разработчики должны учитывать это поведение при проверке значений с помощью `typeof`."
      },
      {
        "question": "Зачем нужен конструктор Proxy?",
        "answer": "Конструктор `Proxy` в JavaScript позволяет создавать объекты-посредники, которые могут перехватывать и настраивать операции, такие как чтение и запись свойств, вызовы функций и другие низкоуровневые операции.\n\nПреимущества использования Proxy:\n\n1. **Перехват операций**: возможность перехватывать операции на объекте, такие как чтение (`get`), запись (`set`), удаление свойств (`deleteProperty`), вызов функций (`apply`) и другие.\n\n2. **Валидация и фильтрация**: возможность добавлять валидацию и фильтрацию при изменении или доступе к свойствам объекта.\n\n3. **Логирование**: возможность логировать операции на объекте для отладки и мониторинга.\n\nПример использования Proxy:\n```javascript\nlet handler = {\n  get: function(target, prop, receiver) {\n    console.log(`Getting property ${prop}`);\n    return Reflect.get(target, prop, receiver);\n  },\n  set: function(target, prop, value, receiver) {\n    console.log(`Setting property ${prop} to ${value}`);\n    return Reflect.set(target, prop, value, receiver);\n  }\n};\n\nlet target = {};\nlet proxy = new Proxy(target, handler);\n\nproxy.a = 1; // Лог: Setting property a to 1\nconsole.log(proxy.a); // Лог: Getting property a; Вывод: 1\n```\n\nProxy предоставляет мощный инструмент для управления и расширения поведения объектов в JavaScript."
      },
      {
        "question": "Что такое хвостовая рекурсия? Оптимизация рекурсии?",
        "answer": "Хвостовая рекурсия — это особый вид рекурсии, при котором рекурсивный вызов является последней операцией в функции. Это позволяет компилятору или интерпретатору оптимизировать выполнение рекурсивных вызовов, избегая наращивания стека вызовов.\n\nПример хвостовой рекурсии:\n```javascript\nfunction factorial(n, acc = 1) {\n  if (n <= 1) return acc;\n  return factorial(n - 1, n * acc);\n}\n```\n\nОптимизация рекурсии (tail call optimization) позволяет использовать постоянное количество памяти для выполнения хвостовых рекурсий, что предотвращает переполнение стека вызовов. Эта оптимизация автоматически применяется в некоторых современных интерпретаторах JavaScript, если функция написана в хвостовом стиле."
      },
      {
        "question": "Что такое и как работает debounce() и throttle() в JavaScript?",
        "answer": "`debounce()` и `throttle()` — это функции, которые помогают контролировать частоту выполнения других функций, особенно полезны для обработки событий, таких как прокрутка или изменение размеров окна.\n\n1. **debounce()**: откладывает выполнение функции до тех пор, пока не пройдет определённое время после последнего вызова. Если функция вызывается снова в течение этого времени, таймер сбрасывается.\n\nПример реализации debounce:\n```javascript\nfunction debounce(func, wait) {\n  let timeout;\n  return function(...args) {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func.apply(this, args), wait);\n  };\n}\n\nwindow.addEventListener('resize', debounce(() => {\n  console.log('Resize event handler called');\n}, 300));\n```\n\n2. **throttle()**: ограничивает количество вызовов функции, позволяя ей выполняться не чаще одного раза за указанный промежуток времени.\n\nПример реализации throttle:\n```javascript\nfunction throttle(func, limit) {\n  let inThrottle;\n  return function(...args) {\n    if (!inThrottle) {\n      func.apply(this, args);\n      inThrottle = true;\n      setTimeout(() => inThrottle = false, limit);\n    }\n  };\n}\n\nwindow.addEventListener('scroll', throttle(() => {\n  console.log('Scroll event handler called');\n}, 300));\n```\n\n`debounce` полезен, когда важно, чтобы функция выполнялась только после завершения серии событий (например, ввод текста), а `throttle` — когда необходимо выполнять функцию с фиксированной частотой (например, при прокрутке страницы)."
      },
      {
        "question": "Как в JavaScript работают декораторы? Как они могут быть использованы для модификации поведения классов и методов?",
        "answer": "Декораторы в JavaScript — это специальный синтаксис для аннотации и модификации классов и их свойств. Они позволяют добавлять функциональность к классам и методам без изменения их исходного кода. Декораторы являются экспериментальной функцией и могут потребовать использования транслятора, такого как Babel.\n\nДекоратор — это функция, которая принимает в качестве аргумента цель декорации (например, класс или метод) и возвращает измененную версию этой цели или заменяет её новой.\n\nПример декоратора для метода:\n```javascript\nfunction log(target, key, descriptor) {\n  const originalMethod = descriptor.value;\n  descriptor.value = function(...args) {\n    console.log(`Calling ${key} with arguments: ${args}`);\n    return originalMethod.apply(this, args);\n  };\n  return descriptor;\n}\n\nclass Example {\n  @log\n  sayHello(name) {\n    return `Hello, ${name}!`;\n  }\n}\n\nconst example = new Example();\nexample.sayHello('World'); // Лог: Calling sayHello with arguments: World\n```\n\nВ этом примере декоратор `@log` модифицирует метод `sayHello` класса `Example`, добавляя логирование перед вызовом исходного метода. Декораторы могут использоваться для множества целей, таких как валидация, кэширование, логирование и управление доступом."
      }
    ]
  },
  {
    "position": "junior",
    "topic": "nodejs",
    "questions": [
      {
        "question": "Что такое Node.js?",
        "answer": "Node.js — это среда выполнения JavaScript-кода, построенная на движке V8 от Google. Node.js позволяет выполнять JavaScript-код на стороне сервера, что делает его подходящим для создания серверных приложений и сетевых сервисов."
      },
      {
        "question": "Разница между Node.js и JavaScript?",
        "answer": "JavaScript — это язык программирования, который изначально был предназначен для выполнения в браузере. Node.js, с другой стороны, — это среда выполнения, которая позволяет запускать JavaScript вне браузера, на сервере. Node.js добавляет к стандартному JavaScript API для работы с файловой системой, сетевыми запросами и другими функциями сервера."
      },
      {
        "question": "Когда следует использовать Node.js?",
        "answer": "Node.js следует использовать, когда требуется создать высокопроизводительные, масштабируемые сетевые приложения, особенно с большим количеством одновременных подключений. Node.js также подходит для создания API, микросервисов и серверов, обрабатывающих события и данные в реальном времени."
      },
      {
        "question": "Плюсы Node.js?",
        "answer": "К плюсам Node.js относятся:\n1. Высокая производительность благодаря движку V8.\n2. Поддержка асинхронного программирования и неблокирующего ввода/вывода.\n3. Огромная экосистема npm с тысячами модулей и библиотек.\n4. Возможность использовать один и тот же язык (JavaScript) на сервере и клиенте.\n5. Активное сообщество разработчиков и поддержка крупных компаний."
      },
      {
        "question": "Что такое цикл событий (event loop)?",
        "answer": "Цикл событий (event loop) — это механизм в Node.js, который позволяет обрабатывать асинхронные операции. Он постоянно проверяет очередь задач (event queue) и исполняет задачи по мере их поступления, что позволяет Node.js эффективно управлять большим количеством асинхронных операций без блокировки основного потока."
      },
      {
        "question": "Разница между асинхронной и неблокирующей функциями?",
        "answer": "Асинхронные функции выполняются в фоновом режиме и не блокируют выполнение основного потока программы. Неблокирующие функции — это конкретный тип асинхронных функций, которые немедленно возвращают управление, не дожидаясь завершения операции, позволяя программе продолжать выполнение других задач."
      },
      {
        "question": "Преимущества однопоточного веб-сервера по сравнению с многопоточным?",
        "answer": "Однопоточные веб-серверы, такие как Node.js, более эффективны в работе с большим количеством одновременных подключений, так как они не создают новые потоки для каждого запроса. Это снижает потребление памяти и улучшает производительность в сценариях с высокой нагрузкой. Многопоточные серверы, напротив, могут испытывать сложности с управлением большим количеством потоков."
      },
      {
        "question": "Что такое поток (stream)? Типы потоков в Node.js?",
        "answer": "Потоки (streams) — это объекты, которые позволяют работать с данными по частям, что особенно полезно для работы с большими объемами данных, такими как файлы или сетевые запросы. В Node.js существуют четыре основных типа потоков:\n1. Чтения (Readable) — для чтения данных.\n2. Записи (Writable) — для записи данных.\n3. Дуплексные (Duplex) — для чтения и записи данных одновременно.\n4. Преобразующие (Transform) — для изменения данных во время их передачи."
      },
      {
        "question": "Разница между createReadStream и readFile?",
        "answer": "Функция `createReadStream` создает поток для чтения файла, что позволяет читать файл по частям, не загружая весь файл в память. Это эффективно для работы с большими файлами. Функция `readFile`, напротив, загружает весь файл в память перед его обработкой, что может быть неэффективно для больших файлов."
      },
      {
        "question": "Что такое REPL в Node.js?",
        "answer": "REPL (Read-Eval-Print Loop) — это интерактивная среда в Node.js, которая позволяет вводить команды JavaScript, выполнять их, и получать результаты в реальном времени. Это полезный инструмент для отладки, тестирования и быстрого выполнения кода."
      },
      {
        "question": "Что такое Continuation-passing Style (CPS)?",
        "answer": "Continuation-passing Style (CPS) — это стиль программирования, в котором функции не возвращают результат напрямую, а передают его через другую функцию (континуэйшн). В Node.js это часто используется для обработки асинхронных операций через колбэки, что позволяет управлять потоком выполнения программы."
      },
      {
        "question": "Как избежать Callback Hell?",
        "answer": "Чтобы избежать Callback Hell (ситуации, когда код становится трудно читаемым из-за вложенных колбэков), можно использовать следующие подходы:\n1. Промисы (Promises) — позволяют обрабатывать асинхронные операции более линейно.\n2. Async/Await — синтаксический сахар над промисами, делающий код более похожим на синхронный.\n3. Модули управления потоками, такие как `async.js`, которые помогают упорядочить выполнение асинхронных задач."
      },
      {
        "question": "Что такое модуль Cluster?",
        "answer": "Модуль Cluster в Node.js позволяет создавать кластеры процессов, которые могут использовать все доступные ядра процессора. Это повышает производительность Node.js приложений, так как позволяет обрабатывать больше запросов параллельно, распределяя нагрузку между разными процессами."
      },
      {
        "question": "Почему использование блокирующих, или синхронных операций является плохой практикой в Node.js?",
        "answer": "Использование блокирующих операций в Node.js может привести к тому, что основной поток выполнения будет заблокирован, что замедляет обработку других запросов и снижает производительность приложения. Node.js лучше всего работает с неблокирующими, асинхронными операциями, которые позволяют эффективно управлять ресурсами."
      },
      {
        "question": "Что такое npm?",
        "answer": "npm (Node Package Manager) — это менеджер пакетов для Node.js. Он позволяет устанавливать, управлять и публиковать пакеты (модули) JavaScript. npm также служит хранилищем для открытых пакетов, которые могут быть использованы разработчиками в их проектах."
      },
      {
        "question": "Разница между module.exports и exports?",
        "answer": "В Node.js `module.exports` и `exports` — это объекты, которые используются для экспорта функциональности из модуля. `module.exports` — это сам объект, который будет возвращен при `require` модуля, а `exports` — это сокращение для `module.exports`. Однако если `module.exports` будет присвоен новому значению, это разорвёт связь с `exports`, и модуль вернет только `module.exports`."
      },
      {
        "question": "Почему в модулях переменные верхнего уровня не являются глобальными?",
        "answer": "В Node.js каждый файл является модулем, и переменные, объявленные в верхнем уровне этого файла, доступны только внутри этого модуля. Это сделано для предотвращения конфликтов имен переменных и для обеспечения модульности кода, где каждый модуль имеет своё собственное пространство имен."
      },
      {
        "question": "Что такое циклические зависимости модулей в Node?",
        "answer": "Циклические зависимости возникают, когда два или более модуля зависят друг от друга, прямо или косвенно. В Node.js такие ситуации могут привести к неполной загрузке модулей или к неожиданным ошибкам. Чтобы избежать циклических зависимостей, можно реорганизовать код, разделить функциональность на более мелкие модули или использовать паттерны проектирования, такие как Dependency Injection."
      },
      {
        "question": "Подходы к масштабированию Node.js приложения?",
        "answer": "Существует несколько подходов к масштабированию Node.js приложений:\n1. Горизонтальное масштабирование — запуск нескольких экземпляров приложения на разных серверах или процессах с использованием балансировщика нагрузки.\n2. Вертикальное масштабирование — увеличение ресурсов сервера, таких как память и процессор.\n3. Использование кластера процессов для распараллеливания обработки запросов на всех ядрах процессора.\n4. Использование микросервисной архитектуры для разделения приложения на более мелкие, независимые сервисы."
      },
      {
        "question": "Что такое переменные окружения в Node.js? Как они используются?",
        "answer": "Переменные окружения (Environment Variables) — это ключи и значения, которые задаются вне программы и могут использоваться для конфигурации приложения. В Node.js они доступны через объект `process.env`. Переменные окружения позволяют безопасно хранить чувствительную информацию, такую как пароли и ключи API, а также настраивать приложение в зависимости от среды, например, для разработки, тестирования и продакшена."
      }
    ]
  }
]
