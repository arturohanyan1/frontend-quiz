[
  {
    "position": "middle",
    "topic": "general",
    "questions": [
      {
        "id": 1,
        "question": "Расскажите о пирамиде тестирования.",
        "answer": "Пирамида тестирования - это концепция, описывающая различные уровни тестов и их относительное количество. В основе пирамиды находятся unit-тесты, которых должно быть больше всего. На следующем уровне расположены интеграционные тесты, а на вершине пирамиды - end-to-end (E2E) тесты, которых должно быть наименьшее количество."
      },
      {
        "id": 2,
        "question": "Какие типы автоматизированных тестов выпадала возможность писать? Какие библиотеки при этом использовали? Каким инструментам отдаете предпочтение и почему?",
        "answer": "Приходилось писать различные типы тестов: unit-тесты, интеграционные тесты и end-to-end тесты. Для unit-тестов использовал Jest, для интеграционных - Testing Library, а для E2E - Cypress. Предпочитаю Jest и Cypress за их простоту в использовании и мощные возможности для тестирования."
      },
      {
        "id": 3,
        "question": "Что такое unit-тесты? Какое место в пирамиде тестирования занимают unit-тесты?",
        "answer": "Unit-тесты - это тесты, которые проверяют отдельные модули или функции в изоляции от остальной системы. Они занимают основание пирамиды тестирования, так как их должно быть больше всего из-за их скорости и простоты написания."
      },
      {
        "id": 4,
        "question": "Что такое code coverage? Обязательно 100% покрытие тестами кода?",
        "answer": "Code coverage - это метрика, показывающая, какая часть кода покрыта тестами. Стремление к 100% покрытию не всегда оправдано, так как не весь код требует тестирования (например, тривиальные геттеры и сеттеры), и это может привести к написанию ненужных тестов."
      },
      {
        "id": 5,
        "question": "Как запретить браузеру отдавать кэш на HTTP-запрос?",
        "answer": "Для запрета кэширования можно использовать HTTP-заголовки Cache-Control и Pragma. Например, Cache-Control: no-cache, no-store и Pragma: no-cache."
      },
      {
        "id": 6,
        "question": "Что такое XSS (Cross-Site Scripting)?",
        "answer": "XSS (Cross-Site Scripting) - это уязвимость, позволяющая злоумышленнику внедрить вредоносный скрипт в веб-страницу, который затем исполняется в браузере пользователя. Это может привести к краже данных или выполнению нежелательных действий от имени пользователя."
      },
      {
        "id": 7,
        "question": "Расскажите о паттернах Observer, Pub / Sub. Какая между ними разница? Приведите примеры реализации этих паттернов в известных фреймворках / библиотеках / браузерных API.",
        "answer": "Паттерн Observer позволяет объектам подписываться на изменения другого объекта и быть уведомленными о них. Pub/Sub (Publisher/Subscriber) - это паттерн, в котором отправители (publishers) отправляют сообщения, а получатели (subscribers) подписываются на их получение. Разница в том, что в Observer подписчики знают об издателе, а в Pub/Sub они не зависят друг от друга. Примеры: в React - паттерн Observer, а в Node.js - EventEmitter (реализация Pub/Sub)."
      },
      {
        "id": 8,
        "question": "С какой целью может быть использован event listener события fetch self.addEventListener('fetch', event => {})?",
        "answer": "Этот event listener используется в Service Worker для перехвата сетевых запросов и управления ими. Это позволяет кэшировать запросы, предоставлять оффлайн-доступ или изменять ответы на запросы."
      },
      {
        "id": 9,
        "question": "Что такое Event loop и как он работает? Расскажите о микрозадачах и макрозадачах.",
        "answer": "Event loop - это механизм, который управляет выполнением асинхронного кода в JavaScript. Он проверяет очередь задач (tasks), выполняет их и затем обрабатывает микрозадачи (microtasks), такие как промисы. Макрозадачи (macrotasks) включают setTimeout, setInterval и I/O операции. Event loop сначала выполняет одну макрозадачу, затем все микрозадачи, и только потом переходит к следующей макрозадаче."
      }
    ]
  },
  {
    "position": "middle",
    "topic": "jsCore",
    "questions": [
      {
        "id": 10,
        "question": "Какие типы данных бывают в JavaScript? Какой будет результат выполнения кода?\n\nlet firstObj = { name: 'Hello' };\n\nlet secondObj = firstObj;\n\nfirstObj = { name: 'Bye' };\n\nconsole.log(secondObj.name);",
        "answer": "В JavaScript существуют следующие типы данных: примитивные (undefined, null, boolean, number, string, symbol, bigint) и объекты (Object, Array, Function, Date и т.д.). Результат выполнения кода будет 'Hello', потому что `secondObj` всё ещё ссылается на исходный объект, даже после того, как `firstObj` присвоен новый объект."
      },
      {
        "id": 11,
        "question": "Что такое temporal dead zone?",
        "answer": "Temporal Dead Zone (TDZ) - это период времени, в течение которого переменная существует, но не инициализирована. Переменные, объявленные с помощью `let` или `const`, находятся в TDZ с момента входа в блок до строки, где они инициализируются."
      },
      {
        "id": 12,
        "question": "Как работает boxing / unboxing в JavaScript?",
        "answer": "Boxing - это процесс преобразования примитивных типов данных (например, number, boolean) в объектные оболочки (Number, Boolean). Unboxing - это обратный процесс преобразования объектных оболочек обратно в примитивные типы. Это происходит автоматически при необходимости."
      },
      {
        "id": 13,
        "question": "В чем разница между оператором in и методом hasOwnProperty?",
        "answer": "Оператор `in` проверяет наличие свойства в объекте и его прототипной цепочке, тогда как метод `hasOwnProperty` проверяет только наличие собственного свойства объекта."
      },
      {
        "id": 14,
        "question": "Опишите, с помощью чего в JS реализуются такие ООП-парадигмы, как инкапсуляция, полиморфизм, абстракция?",
        "answer": "Инкапсуляция реализуется с помощью замыканий и классов (private свойства). Полиморфизм достигается с помощью наследования и интерфейсов (duck typing). Абстракция достигается путем создания абстрактных классов и интерфейсов."
      },
      {
        "id": 15,
        "question": "Что такое прототип? Как работает прототипное наследование в JS? Объясните работу кода.\n\nfunction Main () {}\n\nMain.prototype = { protected: true };\n\nconst obj = new Main();\n\nMain.prototype = { protected: false };\n\nconsole.log('Object protection: ', obj.protected);",
        "answer": "Прототип - это объект, от которого другие объекты наследуют свойства и методы. В JS объекты наследуют от прототипов через прототипную цепочку. В приведенном коде `obj` наследует свойство `protected` от исходного прототипа `Main`, поэтому результат будет `true`."
      },
      {
        "id": 16,
        "question": "Какая разница между композицией и наследованием?",
        "answer": "Наследование подразумевает, что один класс наследует свойства и методы другого класса. Композиция подразумевает, что один класс содержит экземпляры других классов и делегирует им выполнение задач. Композиция более гибка и предпочтительнее в большинстве случаев."
      },
      {
        "id": 17,
        "question": "Почему не стоит использовать конструкторы типа new String?",
        "answer": "Использование конструкторов типа `new String` создает объектную обертку вокруг строкового значения, что может привести к непредсказуемому поведению и потере производительности. Лучше использовать примитивные строки."
      },
      {
        "id": 18,
        "question": "Расскажите о базовом устройстве и механизме работы Event loop.",
        "answer": "Event loop - это механизм, который позволяет JavaScript выполнять асинхронный код, не блокируя основной поток. Он проверяет очередь задач (tasks), выполняет одну задачу, затем все микрозадачи (microtasks), прежде чем вернуться к следующей задаче."
      },
      {
        "id": 19,
        "question": "Что такое записи (records) и кортежи (tuples)? Чем они отличаются от обычных объектов?",
        "answer": "Записи (records) и кортежи (tuples) - это неизменяемые структуры данных, введенные в ECMAScript. Записи похожи на объекты, но неизменяемы. Кортежи похожи на массивы, но также неизменяемы. Они обеспечивают лучшую производительность и надежность данных."
      },
      {
        "id": 20,
        "question": "Какие различия в поведении ES5 функции-конструктора и ES2015 класса?",
        "answer": "ES5 функции-конструкторы требуют использования прототипов для добавления методов, в то время как ES2015 классы позволяют объявлять методы внутри тела класса. Классы также поддерживают наследование с помощью ключевого слова `extends` и имеют более выразительный синтаксис."
      },
      {
        "id": 21,
        "question": "Как реализовать паттерн «Модуль»?",
        "answer": "Паттерн «Модуль» реализуется с использованием замыканий для создания приватных переменных и методов. Пример:\n\n```javascript\nconst Module = (function() {\n  let privateVar = 'I am private';\n  function privateMethod() {\n    console.log(privateVar);\n  }\n  return {\n    publicMethod: function() {\n      privateMethod();\n    }\n  };\n})();\nModule.publicMethod(); // 'I am private'\n```"
      },
      {
        "id": 22,
        "question": "Почему typeof null возвращает object?",
        "answer": "Это ошибка в языке JavaScript, которая существует с самого начала. null был задуман как отдельный тип данных, но `typeof null` возвращает 'object' из-за ошибки в реализации."
      },
      {
        "id": 23,
        "question": "Что такое приведение (преобразование) типов в JS?",
        "answer": "Приведение типов - это процесс преобразования значения из одного типа в другой. Оно может быть явным (когда разработчик явно указывает преобразование) и неявным (когда преобразование происходит автоматически)."
      },
      {
        "id": 24,
        "question": "Что такое явное и неявное приведение (преобразование) типов данных в JS? Как происходит преобразование типов в следующих примерах:\n\n{}+[]+{}+[1]\n\n!!\"false\" == !!\"true\"\n\n['x'] == 'x'",
        "answer": "Явное приведение типов - это когда разработчик явно указывает преобразование, например `Number('123')`. Неявное - когда преобразование происходит автоматически, например `1 + '2'` будет `12`.\n\n1. `{}+[]+{}+[1]` => \"[object Object][object Object]1\"\n2. `!!\"false\" == !!\"true\"` => `true` (обе строки истинные)\n3. `['x'] == 'x'` => `true` (массив приводится к строке)"
      },
      {
        "id": 25,
        "question": "Что такое Garbage Collector?",
        "answer": "Garbage Collector (GC) - это механизм управления памятью, который автоматически освобождает память, занятую объектами, которые больше не используются или недоступны."
      },
      {
        "id": 26,
        "question": "Опишите основные принципы работы «сборщика мусора» в JS-движках (engines).",
        "answer": "Основные принципы работы GC включают сборку мусора на основе подсчета ссылок и маркировку-сжатие. При подсчете ссылок GC освобождает объекты, на которые больше нет ссылок. Маркировка-сжатие включает в себя маркировку объектов, которые можно достичь из корневых объектов, и освобождение памяти для остальных объектов."
      },
      {
        "id": 27,
        "question": "Опишите назначение и принципы работы с коллекциями WeakMap и WeakSet? Чем они отличаются от коллекций Map и Set соответственно?",
        "answer": "WeakMap и WeakSet позволяют создавать коллекции, где ключи объектов могут быть сборными мусором, если на них больше нет других ссылок. Это полезно для хранения метаданных или кэшей, не влияя на процесс сборки мусора. Map и Set, наоборот, предотвращают сборку мусора для своих ключей и значений."
      },
      {
        "id": 28,
        "question": "Чем отличается Observable от Promise?",
        "answer": "Observable может передавать несколько значений с течением времени и предоставляет возможность отмены, тогда как Promise работает с одним значением и не может быть отменен. Observable позволяет работать с потоками данных, а Promise - с однократными асинхронными результатами."
      },
      {
        "id": 29,
        "question": "Что такое Promise? Назовите порядок выполнения then и catch в цепочке.\n\nPromise.resolve(10)\n\n  .then(e => console.log(e)) // ??\n\n  .then(e => Promise.resolve(e))\n\n  .then(console.log) // ??\n\n  .then(e => {\n\n    if (!e) {\n\n      throw 'Error caught';\n\n    }\n\n  })\n\n  .catch(e => {\n\n    console.log(e); // ??\n\n    return new Error('New error');\n\n  })\n\n  .then(e => {\n\n    console.log(e.message); // ??\n\n  })\n\n  .catch(e => {\n\n    console.log(e.message); // ??\n\n  });",
        "answer": "Promise - это объект, представляющий результат асинхронной операции, которая может быть выполнена, отвергнута или находиться в состоянии ожидания.\n\nПорядок выполнения then и catch в цепочке:\n\n1. Первое then: Выведет `10`.\n2. Второе then: Вернет предыдущий результат, не выводя ничего.\n3. Третье then: Выведет `undefined`, так как предыдущий then не возвращал значения.\n4. catch: Не выполнится, так как ошибки не было.\n5. Четвертое then: Ошибок нет, ничего не произойдет.\n6. Пятый then: Ошибка не была поймана, ничего не произойдет."
      },
      {
        "id": 30,
        "question": "Расскажите о последовательном и параллельном выполнении асинхронных функций. В чем разница между Promise.all() и Promise.allSettled()?",
        "answer": "При последовательном выполнении асинхронных функций каждая функция выполняется одна за другой, ожидая завершения предыдущей. Параллельное выполнение позволяет запускать несколько асинхронных функций одновременно.\n\n`Promise.all()` ожидает завершения всех переданных промисов и возвращает массив их результатов. Если хотя бы один промис отклонен, `Promise.all()` отклоняется.\n\n`Promise.allSettled()` возвращает массив результатов для всех промисов, независимо от их выполнения или отклонения, включая информацию о статусе каждого промиса."
      },
      {
        "id": 31,
        "question": "Что такое дескрипторы свойств объектов? Расскажите об их практическом применение.",
        "answer": "Дескрипторы свойств объектов позволяют управлять поведением свойств объектов. Они включают атрибуты `value`, `writable`, `enumerable` и `configurable`. Практическое применение включает в себя создание неизменяемых свойств или контроль их видимости."
      },
      {
        "id": 32,
        "question": "Назовите несколько способов создания постоянного (неизменного) объекта в JavaScript.",
        "answer": "1. Использование `Object.freeze()` для предотвращения изменения объекта.\n2. Использование `Object.defineProperty()` для создания свойств с `writable: false` и `configurable: false`.\n3. Использование `const` для объявления объекта, чтобы переменная не могла быть переназначена."
      },
      {
        "id": 33,
        "question": "Как создать свойство у объекта, которое нельзя будет изменить?",
        "answer": "Использовать `Object.defineProperty()` для создания свойства с `writable: false` и `configurable: false`:\n\n```javascript\nObject.defineProperty(obj, 'prop', {\n  value: 'constant',\n  writable: false,\n  configurable: false\n});\n```"
      },
      {
        "id": 34,
        "question": "Зачем нужен конструктор Proxy? Приведите пример использования.",
        "answer": "Proxy позволяет создавать объекты, которые перехватывают и настраивают основные операции (например, чтение/запись свойств, вызов функций). Пример использования: логирование доступа к свойствам объекта:\n\n```javascript\nconst handler = {\n  get: function(target, prop) {\n    console.log(`Getting ${prop}`);\n    return target[prop];\n  }\n};\nconst proxy = new Proxy(target, handler);\nproxy.name; // Лог: Getting name\n```"
      },
      {
        "id": 35,
        "question": "Что такое ArrayBuffer? В чем разница между Uint32Array и Float32Array? Каков результат выполнения кода?\n\nconst uint32Array = new Uint32Array();\n\nArray.isArray(uint32Array);",
        "answer": "ArrayBuffer - это объект, представляющий фиксированный размер блока необработанных бинарных данных. `Uint32Array` - это массив целых чисел без знака 32-битной длины, а `Float32Array` - массив чисел с плавающей запятой 32-битной длины. Результат выполнения кода будет `false`, так как `Uint32Array` не является массивом."
      },
      {
        "id": 36,
        "question": "Каким будет результат сравнения?\n\nconst url = “HTTPs://xyz.com/path<to>page.html”;\n\nencodeURI(url) == encodeURIComponent(url);",
        "answer": "Результат сравнения будет `false`, так как `encodeURI` кодирует только специальные символы, необходимые для URI, а `encodeURIComponent` кодирует все символы, кроме буквенно-цифровых, -_.!~*'()."
      },
      {
        "id": 37,
        "question": "Расскажите о генераторах и итераторах.",
        "answer": "Генераторы - это функции, которые могут приостанавливать и возобновлять своё выполнение. Итераторы - это объекты, которые предоставляют метод `next()`, возвращающий следующий элемент последовательности. Генераторы возвращают итераторы, что позволяет использовать их в циклах `for...of` и других итерационных контекстах."
      },
      {
        "id": 38,
        "question": "Объясните, что делает приведенный ниже код:\n\nfunction * fn(num) {\n\n  for (let i = 0; i < num; i += 1) {\n\n    yield console.log(i);\n\n  }\n}\n\nconst loop = fn(5);\n\nloop.next();\n\nloop.next();",
        "answer": "Этот код определяет генераторную функцию `fn`, которая выводит значения от 0 до `num` и приостанавливается после каждого вывода. Вызовы `loop.next()` возобновляют выполнение генератора. В данном случае, первый вызов выведет `0`, второй - `1`."
      },
      {
        "id": 39,
        "question": "Расскажите о типе данных Symbol и его практическом применении. Как перевести число с 10-разрядной системы в 16 (2,8) разрядную систему счисления?",
        "answer": "Symbol - это уникальный и неизменяемый тип данных, используемый для создания уникальных идентификаторов для свойств объектов. Практическое применение - создание скрытых свойств объектов, которые не конфликтуют с другими свойствами. Перевод числа в другую систему счисления осуществляется с помощью метода `toString(base)`, где `base` - основание системы счисления:\n\n```javascript\nlet num = 255;\nconsole.log(num.toString(16)); // 'ff'\nconsole.log(num.toString(2)); // '11111111'\n```"
      }
    ]
  },
  {
    "position": "middle",
    "topic": "functions",
    "questions": [
      {
        "id": 40,
        "question": "Объясните, что означает currying. Приведите пример использования на практике.",
        "answer": "Currying - это техника преобразования функции с множеством аргументов в цепочку функций, каждая из которых принимает один аргумент и возвращает новую функцию. Пример использования на практике:\n\n```javascript\nfunction multiply(a) {\n  return function(b) {\n    return function(c) {\n      return a * b * c;\n    };\n  };\n}\nconst result = multiply(2)(3)(4); // 24\n```"
      },
      {
        "id": 41,
        "question": "Приведите пример функции с мемоизацией. Когда следует применять эту технику?",
        "answer": "Мемоизация - это техника оптимизации, при которой результаты вызовов функции сохраняются и возвращаются из кеша при повторных вызовах с теми же аргументами. Пример функции с мемоизацией:\n\n```javascript\nfunction memoize(fn) {\n  const cache = {};\n  return function(...args) {\n    const key = JSON.stringify(args);\n    if (!cache[key]) {\n      cache[key] = fn(...args);\n    }\n    return cache[key];\n  };\n}\nconst factorial = memoize(function(n) {\n  return n <= 1 ? 1 : n * factorial(n - 1);\n});\nconsole.log(factorial(5)); // 120\nconsole.log(factorial(5)); // 120 (из кеша)\n```\nМемоизацию следует применять для функций с дорогими вычислениями и когда одни и те же вычисления повторяются с одинаковыми входными данными."
      },
      {
        "id": 42,
        "question": "Что такое чейнинг функций? Напишите пример с использованием этого подхода.",
        "answer": "Чейнинг функций - это техника вызова нескольких методов объекта последовательно в одной строке. Пример с использованием чейнинга функций:\n\n```javascript\nclass Calculator {\n  constructor(value = 0) {\n    this.value = value;\n  }\n  add(number) {\n    this.value += number;\n    return this;\n  }\n  subtract(number) {\n    this.value -= number;\n    return this;\n  }\n  multiply(number) {\n    this.value *= number;\n    return this;\n  }\n  divide(number) {\n    this.value /= number;\n    return this;\n  }\n  getResult() {\n    return this.value;\n  }\n}\nconst result = new Calculator()\n  .add(10)\n  .subtract(5)\n  .multiply(2)\n  .divide(3)\n  .getResult(); // 3.333...\n```"
      },
      {
        "id": 43,
        "question": "В чем разница между function и arrow function? Каким будет результат выполнения кода?\n\nconst pluckDeep = key => obj => key.split('.').reduce((accum, key) => accum[key], obj)\nconst compose = (...fns) => res => fns.reduce((accum, next) => next(accum), res)\n\nconst unfold = (f, seed) => {\n\n  const go = (f, seed, acc) => {\n\n    const res = f(seed)\n\n    return res ? go(f, res[1], acc.concat([res[0]])) : acc\n\n  }\n\n  return go(f, seed, [])\n}",
        "answer": "Разница между `function` и `arrow function`:\n\n1. Синтаксис: `function` имеет более длинный синтаксис, а `arrow function` короче.\n2. `this`: Arrow функции не имеют собственного `this` и наследуют его из родительской области видимости, в то время как обычные функции имеют свой собственный `this`.\n3. `arguments`: Arrow функции не имеют объекта `arguments`, а обычные функции имеют.\n\nРезультат выполнения кода зависит от вызова функции. Рассмотрим следующий пример использования:\n\n```javascript\nconst pluckDeep = key => obj => key.split('.').reduce((accum, key) => accum[key], obj);\nconst compose = (...fns) => res => fns.reduce((accum, next) => next(accum), res);\n\nconst unfold = (f, seed) => {\n  const go = (f, seed, acc) => {\n    const res = f(seed);\n    return res ? go(f, res[1], acc.concat([res[0]])) : acc;\n  }\n  return go(f, seed, []);\n};\n\nconst getUserName = pluckDeep('user.name');\nconst result = compose(\n  getUserName,\n  name => name.toUpperCase()\n)({ user: { name: 'John' } });\nconsole.log(result); // 'JOHN'\n\nconst sequence = unfold(n => n > 0 ? [n, n - 1] : null, 5);\nconsole.log(sequence); // [5, 4, 3, 2, 1]\n```"
      }
    ]
  },
  {
    "position": "middle",
    "topic": "frontend",
    "questions": [
      {
        "id": 44,
        "question": "В чем принципиальная разница между событиями mouseleave и mouseout?",
        "answer": "Основное отличие между событиями `mouseleave` и `mouseout` заключается в том, как они обрабатывают переход курсора мыши между элементами. \n\n- `mouseout` срабатывает, когда курсор мыши покидает элемент, но также срабатывает, когда курсор покидает один элемент и попадает на дочерний элемент. \n- `mouseleave` срабатывает только тогда, когда курсор мыши уходит с элемента в область вне него, игнорируя переходы на дочерние элементы.\n\nПример:\n```html\n<div id='parent'>\n  Parent\n  <div id='child'>Child</div>\n</div>\n<script>\n  document.getElementById('parent').addEventListener('mouseout', () => console.log('mouseout from parent'));\n  document.getElementById('parent').addEventListener('mouseleave', () => console.log('mouseleave from parent'));\n</script>\n```\nКогда курсор перемещается из родительского элемента в дочерний, `mouseout` сработает, но `mouseleave` не сработает."
      },
      {
        "id": 45,
        "question": "В каком порядке обрабатываются пользовательские события в DOM (click, mouseover и т.д.)? FIFO или LIFO?",
        "answer": "Пользовательские события в DOM обрабатываются в порядке FIFO (First In, First Out). Это означает, что события обрабатываются в том порядке, в котором они были добавлены в очередь событий. Таким образом, если одно событие зарегистрировано раньше другого, оно будет обработано первым."
      },
      {
        "id": 46,
        "question": "Что такое Event bubbling и Event capturing?",
        "answer": "Event bubbling и event capturing - это два механизма распространения событий в DOM.\n\n- **Event capturing (фаза перехвата):** Событие распространяется сверху вниз, начиная с корневого элемента (document) и идя к целевому элементу, на котором событие произошло.\n- **Event bubbling (фаза всплытия):** Событие распространяется снизу вверх, начиная с целевого элемента и поднимаясь к корневому элементу (document).\n\nПример кода, иллюстрирующий оба механизма:\n```html\n<div id='parent'>\n  Parent\n  <div id='child'>Child</div>\n</div>\n<script>\n  document.getElementById('parent').addEventListener('click', () => console.log('Parent capture'), true); // Capturing phase\n  document.getElementById('child').addEventListener('click', () => console.log('Child capture'), true); // Capturing phase\n  document.getElementById('parent').addEventListener('click', () => console.log('Parent bubble')); // Bubbling phase\n  document.getElementById('child').addEventListener('click', () => console.log('Child bubble')); // Bubbling phase\n</script>\n```\nПри клике на элемент Child вывод будет:\n1. Parent capture\n2. Child capture\n3. Child bubble\n4. Parent bubble"
      },
      {
        "id": 47,
        "question": "Сравните методы объекта event stopPropagation и stopImmediatePropagation.",
        "answer": "- `event.stopPropagation()`: Прекращает дальнейшее распространение текущего события в фазе всплытия или перехвата. Событие больше не будет передаваться родительским элементам, но другие обработчики текущего элемента продолжат выполняться.\n- `event.stopImmediatePropagation()`: Прекращает распространение события и немедленно прекращает выполнение других обработчиков текущего элемента.\n\nПример:\n```html\n<button id='btn'>Click me</button>\n<script>\n  document.getElementById('btn').addEventListener('click', () => console.log('First handler'));\n  document.getElementById('btn').addEventListener('click', (e) => {\n    e.stopImmediatePropagation();\n    console.log('Second handler');\n  });\n  document.getElementById('btn').addEventListener('click', () => console.log('Third handler'));\n</script>\n```\nПри клике на кнопку вывод будет:\n1. First handler\n2. Second handler\n\n`Third handler` не будет вызван из-за `stopImmediatePropagation` в обработчике `Second handler`."
      },
      {
        "id": 48,
        "question": "Какие есть подходы оптимизации производительности веб-страницы?",
        "answer": "Основные подходы оптимизации производительности веб-страницы включают:\n1. **Оптимизация изображений:** Использование современных форматов (WebP), сжатие, lazy loading.\n2. **Минификация и сжатие:** Минификация CSS, JavaScript, HTML и сжатие HTTP-ответов с помощью Gzip/Brotli.\n3. **Асинхронная загрузка ресурсов:** Использование атрибутов `async` и `defer` для скриптов.\n4. **Кеширование:** Использование HTTP-заголовков кеширования, Service Workers для кэширования на стороне клиента.\n5. **Оптимизация критического пути рендеринга:** Минимизация CSS и JS, влияющих на отрисовку, inline-критические стили.\n6. **Lazy loading:** Отложенная загрузка изображений, видео и тяжелых ресурсов.\n7. **Оптимизация запросов к серверу:** Объединение и минимизация HTTP-запросов, использование HTTP/2.\n8. **Оптимизация рендеринга:** Использование requestAnimationFrame для анимаций, минимизация reflows и repaints.\n9. **Использование CDN:** Распределение статического контента через Content Delivery Networks."
      },
      {
        "id": 49,
        "question": "Как реализован механизм same-origin policy в браузере? На какие браузерные API он распространяется?",
        "answer": "Same-origin policy - это механизм безопасности, который ограничивает взаимодействие веб-страниц и ресурсов, если они имеют разные источники (origin). Источник определяется комбинацией протокола, домена и порта.\n\nSame-origin policy применяется к следующим API:\n1. **XMLHttpRequest и Fetch:** Ограничение запросов на другие домены без CORS.\n2. **DOM:** Запрещает доступ к DOM элементам, созданным на другом источнике.\n3. **LocalStorage и SessionStorage:** Ограничен доступ к данным, сохраненным с другого источника.\n4. **Cookies:** Ограничение доступа к cookies других доменов.\n5. **Web Workers:** Ограничение взаимодействия между скриптами разных источников.\n\nПример использования CORS для обхода same-origin policy:\n```javascript\nfetch('https://api.example.com/data', {\n  method: 'GET',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  mode: 'cors'\n})\n.then(response => response.json())\n.then(data => console.log(data));\n```"
      },
      {
        "id": 50,
        "question": "Назовите способы хранения данных в браузере. Сравните их.",
        "answer": "Основные способы хранения данных в браузере:\n\n1. **Cookies:**\n   - Хранение небольших данных (до 4KB).\n   - Отправляются с каждым HTTP-запросом.\n   - Поддержка сроков действия, доступ по домену и пути.\n\n2. **LocalStorage:**\n   - Хранение данных без срока действия (доступны до явного удаления).\n   - Максимальный объем хранения ~5-10MB.\n   - Доступ только с того же источника.\n\n3. **SessionStorage:**\n   - Хранение данных на время сессии (удаляются при закрытии вкладки).\n   - Максимальный объем хранения ~5-10MB.\n   - Доступ только с того же источника.\n\n4. **IndexedDB:**\n   - Хранение больших объемов структурированных данных.\n   - Поддержка транзакций, запросов и индексов.\n   - Доступ только с того же источника.\n\n5. **Cache API:**\n   - Кэширование сетевых запросов для офлайн-доступа.\n   - Используется с Service Workers.\n   - Доступ только с того же источника.\n\nСравнение:\n- Cookies удобны для серверного взаимодействия, но ограничены по объему и передаются с каждым запросом, что может влиять на производительность.\n- LocalStorage и SessionStorage просты в использовании для хранения данных на клиенте, но имеют ограничения по объему.\n- IndexedDB подходит для сложных и объемных данных, поддерживает транзакции и запросы, но имеет более сложный API.\n- Cache API идеален для офлайн-приложений и кэширования сетевых запросов."
      },
      {
        "id": 51,
        "question": "Web worker`ы. Опишите особенности передачи данных между worker`ами и основным потоком, между разделенными worker`ами.",
        "answer": "Web Workers позволяют выполнять скрипты в фоновом потоке, отдельно от основного потока выполнения. Особенности передачи данных:\n\n1. **Между worker'ами и основным потоком:**\n   - Передача данных осуществляется через сообщения с использованием метода `postMessage` и обработчика события `message`.\n   - Пример:\n   ```javascript\n   // Основной поток\n   const worker = new Worker('worker.js');\n   worker.postMessage('Hello, worker');\n   worker.onmessage = function(event) {\n     console.log('Message from worker:', event.data);\n   };\n\n   // Worker (worker.js)\n   onmessage = function(event) {\n     console.log('Message from main thread:', event.data);\n     postMessage('Hello, main thread');\n   };\n   ```\n\n2. **Между разделенными worker'ами:**\n   - Использование `postMessage` для передачи данных между worker'ами.\n   - Пример:\n   ```javascript\n   // Worker A\n   const workerB = new Worker('workerB.js');\n   workerB.postMessage('Hello, worker B');\n   workerB.onmessage = function(event) {\n     console.log('Message from worker B:', event.data);\n   };\n\n   // Worker B (workerB.js)\n   onmessage = function(event) {\n     console.log('Message from worker A:', event.data);\n     postMessage('Hello, worker A');\n   };\n   ```"
      },
      {
        "id": 52,
        "question": "Что такое Transferable-объекты?",
        "answer": "Transferable-объекты - это объекты, которые можно передавать между основным потоком и worker'ами без копирования. Это позволяет значительно ускорить передачу данных. Основные типы Transferable-объектов:\n\n- **ArrayBuffer**\n- **MessagePort**\n- **ImageBitmap**\n\nПример передачи ArrayBuffer:\n```javascript\n// Основной поток\nconst worker = new Worker('worker.js');\nconst buffer = new ArrayBuffer(1024);\nworker.postMessage(buffer, [buffer]); // Передача buffer как Transferable\n\n// Worker (worker.js)\nonmessage = function(event) {\n  const buffer = event.data;\n  console.log(buffer.byteLength); // 1024\n};\n```\nПосле передачи буфера, оригинальный объект в основном потоке становится невалидным (его длина будет 0), что подтверждает передачу владения объектом."
      },
      {
        "id": 53,
        "question": "Расскажите о способах оптимизации выполнения ресурсоемких операций JS для улучшения производительности рендеринга контента на странице.",
        "answer": "Способы оптимизации выполнения ресурсоемких операций JS для улучшения производительности рендеринга:\n\n1. **Разделение задач на микрозадачи и макрозадачи:** Использование `setTimeout`, `setImmediate`, `requestAnimationFrame` для распределения больших задач на более мелкие.\n2. **Использование Web Workers:** Перенос тяжелых вычислений в фоновый поток.\n3. **Debouncing и Throttling:** Ограничение частоты выполнения функций, например, при обработке событий прокрутки или ввода.\n4. **Memoization:** Кеширование результатов функций для избегания повторных вычислений.\n5. **Оптимизация рендеринга:** Минимизация reflows и repaints, использование `requestAnimationFrame` для анимаций.\n6. **Lazy Loading:** Отложенная загрузка ресурсов, таких как изображения и скрипты.\n7. **Использование эффективных структур данных:** Например, использование Set и Map вместо массивов для частых операций поиска.\n8. **Асинхронные операции:** Использование промисов и async/await для асинхронных задач.\n9. **Оптимизация DOM-манипуляций:** Минимизация прямых манипуляций с DOM, использование DocumentFragment для групповых операций."
      },
      {
        "id": 54,
        "question": "Почему ResizeObserver вызывает события изменения размера до воспроизведения элемента, а не после?",
        "answer": "ResizeObserver вызывает события изменения размера до воспроизведения элемента, чтобы предотвратить возможные бесконечные циклы рендеринга. Если бы ResizeObserver вызывал события после изменения размера и рендеринга, это могло бы привести к ситуации, когда обработчик события снова изменяет размер элемента, что в свою очередь вызвало бы новое событие изменения размера, и так далее.\n\nТаким образом, вызов событий до рендеринга обеспечивает более предсказуемое и контролируемое поведение, позволяя разработчикам обрабатывать изменения размеров элементов и соответствующим образом адаптировать их перед следующим рендерингом."
      },
      {
        "id": 55,
        "question": "Расскажите, как вы понимаете Web Accessibility?",
        "answer": "Web Accessibility (веб-доступность) - это практика создания веб-сайтов и приложений, которые могут быть использованы всеми людьми, включая людей с ограниченными возможностями. Веб-доступность включает в себя:\n\n1. **Восприимчивость:** Обеспечение того, чтобы контент был воспринимаем всеми пользователями, включая использование альтернативного текста для изображений, субтитров для видео и семантической разметки.\n2. **Операбельность:** Обеспечение того, чтобы все функции были доступны с помощью клавиатуры, улучшение навигации и предотвращение всплывающих окон, блокирующих доступ к контенту.\n3. **Понятность:** Обеспечение ясности и предсказуемости интерфейсов, использование простого языка и предоставление инструкций и обратной связи.\n4. **Надежность:** Обеспечение совместимости контента с различными браузерами и вспомогательными технологиями.\n\nПример улучшения доступности:\n```html\n<label for='username'>Username:</label>\n<input type='text' id='username' aria-label='Username'>\n```\nИспользование атрибута `aria-label` помогает улучшить доступность для пользователей, использующих вспомогательные технологии."
      },
      {
        "id": 56,
        "question": "Опишите алгоритм создания функционала, который обеспечивает чтение содержимого .txt файла при перетаскивании его из файловой системы в окно браузера.",
        "answer": "Алгоритм создания функционала для чтения содержимого .txt файла при перетаскивании в окно браузера:\n\n1. **Добавить слушатели событий `dragover` и `drop` на элемент, куда будет происходить перетаскивание.**\n2. **Предотвратить действия по умолчанию в обработчике события `dragover`.**\n3. **В обработчике события `drop` извлечь файл из объекта события и прочитать его содержимое с помощью FileReader.**\n4. **Вывести содержимое файла на экран или обработать его по необходимости.**\n\nПример реализации:\n```html\n<div id='dropzone'>Перетащите файл сюда</div>\n<pre id='file-content'></pre>\n<script>\n  const dropzone = document.getElementById('dropzone');\n  const fileContent = document.getElementById('file-content');\n\n  dropzone.addEventListener('dragover', (event) => {\n    event.preventDefault();\n  });\n\n  dropzone.addEventListener('drop', (event) => {\n    event.preventDefault();\n    const file = event.dataTransfer.files[0];\n    if (file && file.type === 'text/plain') {\n      const reader = new FileReader();\n      reader.onload = (e) => {\n        fileContent.textContent = e.target.result;\n      };\n      reader.readAsText(file);\n    } else {\n      alert('Пожалуйста, перетащите текстовый файл.');\n    }\n  });\n</script>\n```"
      },
      {
        "id": 1000,
        "question": "Что такое Virtual DOM?",
        "answer": "Virtual DOM (виртуальное DOM) — это концепция, используемая в библиотеках пользовательского интерфейса для оптимизации производительности при обновлении DOM. Она заключается в том, что библиотека создает виртуальное представление DOM в памяти, которое синхронизируется с настоящим DOM только при необходимости. Это позволяет избежать лишних операций обновления и повысить скорость работы приложений."
      }
    ]
  },
  {
    "position": "middle",
    "topic": "css",
    "questions": [
      {
        "id": 57,
        "question": "Объясните разницу между единицами измерения px, em, rem.",
        "answer": "Единицы измерения в CSS отличаются друг от друга способом расчета размеров элементов. \n\n- **px**: пиксели, фиксированная единица измерения, зависящая от разрешения экрана.\n- **em**: относительная единица, которая зависит от размера шрифта родительского элемента. \n- **rem**: также относительная единица, но зависит от размера шрифта корневого элемента (html)."
      },
      {
        "id": 58,
        "question": "Для чего нужны CSS-переменные? Приведите несколько примеров использования.",
        "answer": "CSS-переменные позволяют хранить и переиспользовать значения свойств CSS. Они улучшают поддержку кода и упрощают изменение дизайна. Примеры использования:\n\n1. Определение цветовой схемы:\n```css\n:root {\n  --main-color: #3498db;\n  --secondary-color: #2ecc71;\n}\n.element {\n  background-color: var(--main-color);\n}\n```\n2. Адаптация размеров шрифтов:\n```css\n:root {\n  --base-font-size: 16px;\n}\n.body {\n  font-size: var(--base-font-size);\n}\n```\n3. Использование в анимациях:\n```css\n.element {\n  transition: transform 0.3s ease-out;\n}\n.element:hover {\n  transform: scale(1.1);\n}\n```"
      },
      {
        "id": 59,
        "question": "Что произойдет при добавлении следующего селектора?\n\n* { Box-sizing: border-box; }",
        "answer": "Этот селектор задает значение `box-sizing: border-box;` для всех элементов на странице. Это изменение повлияет на модель расчета размеров элементов, где ширина и высота элемента теперь будут включать границу и отступы, а не только содержимое."
      },
      {
        "id": 60,
        "question": "Как адаптировать страницу для печати?",
        "answer": "Для адаптации страницы для печати можно использовать медиа-запросы и специфичные CSS-стили для печати:\n\n1. Использование медиа-запросов для определения стилей для печати:\n```css\n@media print {\n  body {\n    font-size: 12pt;\n  }\n  .no-print {\n    display: none;\n  }\n}\n```\n2. Управление видимостью элементов при печати:\n```html\n<button class=\"no-print\" onclick=\"window.print()\">Печать</button>\n```\n3. Определение основных параметров печати в CSS:\n```css\n@media print {\n  @page {\n    size: A4 landscape;\n    margin: 1cm;\n  }\n}\n```"
      },
      {
        "id": 61,
        "question": "Опишите особенности кастомизации стилей стандартных элементов форм.",
        "answer": "Кастомизация стандартных элементов форм включает изменение внешнего вида элементов формы без изменения их стандартного поведения. Основные методы кастомизации включают:\n\n1. Использование псевдоэлементов (`::before`, `::after`) для добавления декоративных элементов.\n2. Настройка фонового изображения и цвета фона для элементов формы.\n3. Изменение размеров, отступов и выравнивания с помощью CSS.\n4. Применение анимаций и переходов для улучшения взаимодействия с пользователем."
      },
      {
        "id": 62,
        "question": "Что такое progressive рендеринг? Какие подходы используются?",
        "answer": "Progressive рендеринг — это стратегия загрузки и отображения контента на странице таким образом, чтобы пользователь мог начать взаимодействие с сайтом до полной загрузки всех ресурсов. Подходы включают:\n\n1. Постепенная загрузка изображений (lazy-loading).\n2. Отложенная загрузка скриптов и стилей.\n3. Использование кэширования и CDN для быстрой доставки контента.\n4. Разделение контента на части и загрузка по мере прокрутки страницы (infinite scroll)."
      },
      {
        "id": 63,
        "question": "Назовите несколько способов реализации lazy-loading медиаресурсов на странице.",
        "answer": "Lazy-loading позволяет откладывать загрузку медиаресурсов (изображений, видео, аудио) до момента их фактического использования пользователем. Способы реализации включают:\n\n1. Использование атрибута `loading` в теге `<img>` (доступно с HTML5).\n2. JavaScript-библиотеки, такие как LazyLoad.js.\n3. Intersection Observer API для отслеживания видимости элементов на странице.\n4. Реализация собственной логики с помощью событий прокрутки и загрузки."
      },
      {
        "id": 64,
        "question": "Назовите популярные шаблонизаторы для фронтенд-разработки. Опишите особенности их использования.",
        "answer": "Популярные шаблонизаторы для фронтенд-разработки включают:\n\n1. **Handlebars**: простой и мощный шаблонизатор с поддержкой частичных шаблонов и вложенных данных.\n2. **Mustache**: минималистичный шаблонизатор, поддерживающий множество языков программирования.\n3. **Pug (бывший Jade)**: шаблонизатор с упрощенным синтаксисом, позволяющим писать HTML в виде отступов и без тегов.\n\nОсобенности использования включают компиляцию шаблонов на стороне сервера или в браузере, поддержку логики и переменных, а также повторное использование компонентов."
      },
      {
        "id": 65,
        "question": "Назовите популярные CSS-методологии и их различия.",
        "answer": "Популярные CSS-методологии включают:\n\n1. **BEM (Block Element Modifier)**: методология, ориентированная на создание независимых блоков и элементов с четкими модификациями.\n2. **SMACSS (Scalable and Modular Architecture for CSS)**: методология, предлагающая подход к организации CSS-кода на основе пяти основных категорий.\n3. **Atomic CSS**: подход, при котором классы представляют отдельные стили (атомы), которые затем комбинируются для создания нужного визуального эффекта.\n\nРазличия заключаются в подходах к организации классов, уровне абстракции и гибкости в изменении стилей."
      },
      {
        "id": 66,
        "question": "Как работает CSS Grid?",
        "answer": "CSS Grid — это мощный механизм для создания сеток в веб-дизайне. Он позволяет задавать структуру макета, используя строки и столбцы, что упрощает распределение элементов на странице без необходимости использовать дополнительные контейнеры или фиксированные размеры.\n\nОсновные концепции CSS Grid:\n\n1. **Grid Container**: элемент, у которого установлено свойство `display: grid;`.\n2. **Grid Items**: дочерние элементы контейнера, которые могут быть размещены в сетке.\n3. **Grid Lines**: линии, разделяющие сетку на строки и столбцы.\n4. **Grid Tracks**: области между соседними линиями, которые могут быть явно заданы или автоматически сгенерированы.\n5. **Grid Areas**: именованные области, которые упрощают организацию содержимого в макете.\n\nПример использования:\n```css\n.grid-container {\n  display: grid;\n  grid-template-columns: 1fr 2fr;\n  grid-template-rows: auto;\n}\n.grid-item {\n  grid-column: 1 / 3;\n}\n```"
      },
      {
        "id": 67,
        "question": "Какие форматы изображений поддерживают анимацию?",
        "answer": "Форматы изображений, поддерживающие анимацию, включают:\n\n1. **GIF**: старый, но все еще широко используемый формат для анимированных изображений.\n2. **APNG (Animated Portable Network Graphics)**: формат PNG с поддержкой анимации, но его поддержка неоднозначна.\n3. **WebP**: современный формат, предложенный Google, поддерживает анимацию и обеспечивает лучшее сжатие по сравнению с GIF.\n4. **SVG (Scalable Vector Graphics)**: векторный формат, который поддерживает анимацию, основанную на SMIL (Synchronized Multimedia Integration Language).\n\nКаждый из этих форматов имеет свои особенности и подходит для различных сценариев использования."
      },
      {
        "id": 68,
        "question": "Как отследить прогресс / окончание CSS @keyframes анимаций или плавных переходов, реализованных с помощью transition, в JS?",
        "answer": "Для отслеживания прогресса и окончания CSS анимаций или плавных переходов можно использовать следующие методы:\n\n1. **События анимации**: `animationstart`, `animationend`, `animationiteration` для @keyframes анимаций.\n2. **События перехода**: `transitionstart` и `transitionend` для CSS переходов.\n\nПример использования событий анимации:\n```javascript\nconst element = document.getElementById('animated-element');\nelement.addEventListener('animationend', () => {\n  console.log('Анимация завершена');\n});\n```"
      },
      {
        "id": 69,
        "question": "Какие CSS-свойства могут быть обработаны непосредственно через GPU? Что такое композитные слои и почему большое их количество может привести к аварийному завершению работы браузера на мобильных устройствах?",
        "answer": "Некоторые CSS-свойства, которые могут быть обработаны через GPU, включают:\n\n1. `transform`: перемещение, масштабирование, вращение элементов.\n2. `opacity`: изменение прозрачности элементов.\n3. `filter`: применение фильтров (например, blur, grayscale).\n4. `backdrop-filter`: применение фильтров к заднему фону элемента.\n\nКомпозитные слои — это специальные слои, создаваемые браузером для обработки таких свойств на GPU. Их большое количество может привести к аварийному завершению работы браузера на мобильных устройствах из-за ограниченных ресурсов GPU и оперативной памяти."
      },
      {
        "id": 70,
        "question": "Как переиспользовать Инлайн SVG-элементы на странице?",
        "answer": "Для переиспользования инлайн SVG-элементов на странице можно использовать фрагменты SVG и элемент `<use>`:\n\n1. **Фрагменты SVG**: создание SVG-файлов с различными символами или иконками и их использование в качестве фрагментов в других SVG-файлах.\n2. **Элемент `<use>`**: ссылка на определенные элементы или символы из другого SVG-файла для их многократного использования.\n\nПример использования элемента `<use>`:\n```html\n<svg>\n  <use xlink:href=\"symbol.svg#icon\"></use>\n</svg>\n```"
      },
      {
        "id": 71,
        "question": "Опишите способы оптимизации SVG-файлов.",
        "answer": "Оптимизация SVG-файлов включает различные методы с целью уменьшения размера и повышения производительности загрузки:\n\n1. **Удаление ненужной информации**: удаление комментариев, метаданных, лишних атрибутов.\n2. **Сжатие путей**: использование инструментов для упрощения и сжатия сложных путей в SVG.\n3. **Преобразование в символы или датчики**: создание множественных элементов и ссылок на них через `<symbol>` и `<use>` для многократного использования.\n4. **Использование viewBox**: определение viewBox для оптимального масштабирования и отображения SVG-изображений на разных экранах."
      },
      {
        "id": 72,
        "question": "Как реализовать иконочный шрифт из определенного набора SVG-файлов?",
        "answer": "Для создания иконочного шрифта из набора SVG-файлов можно использовать следующие шаги:\n\n1. **Конвертация в SVG-шрифт**: использование специальных инструментов или онлайн-сервисов для объединения SVG-файлов в один шрифт.\n2. **Определение символов**: назначение символьных кодов каждому SVG-изображению в шрифте.\n3. **Использование CSS**: использование CSS для добавления иконочного шрифта к элементам страницы с помощью `@font-face` и `font-family`.\n\nПример использования иконочного шрифта:\n```css\n@font-face {\n  font-family: 'my-icon-font';\n  src: url('icons.woff2') format('woff2');\n}\n.icon {\n  font-family: 'my-icon-font';\n  /* указание символьного кода или псевдоэлемента для иконки */\n}\n```"
      },
      {
        "id": 73,
        "question": "Что такое ложное жирное или ложное курсивное (Faux) начертание шрифтов?",
        "answer": "Ложное жирное или ложное курсивное начертание шрифтов (Faux bold или Faux italic) — это эффект, при котором браузер пытается симулировать жирное или курсивное начертание для шрифта, если такие начертания не предусмотрены непосредственно шрифтом. Браузеры могут применять эти эффекты, если CSS-правила, такие как `font-weight` или `font-style`, устанавливаются на недоступные начертания шрифта."
      },
      {
        "id": 74,
        "question": "Что такое #shadow-root в инспекторе HTML-страницы?",
        "answer": "#shadow-root — это специальный элемент в инспекторе браузера, который представляет собой внутреннюю структуру Shadow DOM элемента. Shadow DOM позволяет создавать изолированные компоненты с собственной структурой и стилями, которые не влияют на внешний DOM страницы."
      },
      {
        "id": 75,
        "question": "Зачем нужны Custom Elements?",
        "answer": "Custom Elements — это механизм веб-компонентов, позволяющий создавать пользовательские HTML-элементы с пользовательской логикой и стилями. Они улучшают модульность и переиспользование кода, а также позволяют создавать собственные компоненты, которые могут быть повторно использованы в различных частях приложения."
      },
      {
        "id": 76,
        "question": "Почему удаление лишних символов пробелов / символов переноса в HTML не отражается на конечной производительности загрузки страницы?",
        "answer": "Удаление лишних символов пробелов и символов переноса (whitespace) в HTML не оказывает существенного влияния на производительность загрузки страницы, потому что браузеры игнорируют их при обработке HTML. Это означает, что удаление или добавление этих символов в HTML-код не изменит объем передаваемых данных или скорость обработки страницы браузером."
      },
      {
        "id": 77,
        "question": "Что такое контекст отображения canvas? Какие существуют типы контекста для рендеринга двумерной и трехмерной графики?",
        "answer": "Контекст отображения canvas (CanvasRenderingContext2D и WebGLRenderingContext) представляет собой интерфейс для рисования двумерной и трехмерной графики в элементе `<canvas>` в HTML5.\n\nТипы контекста:\n\n1. **CanvasRenderingContext2D**: контекст для рендеринга двумерной графики, поддерживающий рисование путей, текста, изображений и других элементов.\n2. **WebGLRenderingContext**: контекст для рендеринга трехмерной графики с использованием WebGL (Web Graphics Library), позволяющий создавать сложные 3D-сцены и эффекты, используя аппаратное ускорение."
      }
    ]
  },
  {
    "position": "middle",
    "topic": "angular",
    "questions": [
      {
        "id": 78,
        "question": "Как работает Dependency injection? Зачем это нужно? Расскажите об использовании кастомных инжекторов.",
        "answer": "Dependency injection (DI) — это паттерн проектирования, который используется для доставки зависимостей в объекты или функции вместо того, чтобы объекты создавали свои зависимости напрямую. Это улучшает модульность, управляемость и тестируемость кода, делая его более гибким. DI особенно полезен в крупных приложениях, где управление зависимостями может быть сложной задачей. Кастомные инжекторы позволяют настроить, какие зависимости и как они должны быть предоставлены компонентам приложения, что дает большую гибкость в управлении зависимостями."
      },
      {
        "id": 79,
        "question": "Что такое zone.js? Для чего Angular использует зоны? С какой целью можно использовать NgZone-сервис?",
        "answer": "zone.js — это библиотека, используемая Angular для управления зонами выполнения в JavaScript. Зоны позволяют отслеживать и перехватывать асинхронные операции, такие как обработка событий, выполнение таймеров и HTTP-запросов. Angular использует зоны для обнаружения изменений (change detection), что позволяет автоматически обновлять представление приложения при изменениях в его состоянии. NgZone-сервис предоставляет доступ к текущей зоне и позволяет запускать или выполнять код в определенной зоне, что полезно для оптимизации производительности и управления асинхронными операциями."
      },
      {
        "id": 80,
        "question": "Как работает Change detection? Как можно оптимизировать компонент с помощью схем Change detection? Какие еще есть приемы для оптимизации рендеринга (связанные с Change detection)?",
        "answer": "Change detection — это процесс, при котором Angular определяет, какие компоненты, директивы и пайпы должны быть перерисованы на основе изменений данных и событий в приложении. Оптимизация компонентов с помощью стратегий Change detection (OnPush) позволяет уменьшить количество проверок на изменения, снизить нагрузку на процессор и улучшить производительность приложения. Другие приемы для оптимизации включают уменьшение количества обращений к DOM, использование lazy loading для модулей и оптимизацию алгоритмов обновления данных."
      },
      {
        "id": 81,
        "question": "Как выполнить конфигурацию HTTP-сервиса? Зачем она нужна? Обработка HTTP-ошибок?",
        "answer": "Конфигурация HTTP-сервиса в Angular позволяет настраивать параметры, такие как базовый URL, интерцепторы HTTP-запросов, таймауты и обработку ошибок. Это нужно для централизованного управления настройками HTTP-запросов в приложении. Обработка HTTP-ошибок включает в себя использование операторов catchError в сервисах для обработки ошибок, возвращаемых сервером, и генерации пользовательских сообщений об ошибках для пользователя приложения."
      },
      {
        "id": 82,
        "question": "Какие есть подходы к организации работы с данными?",
        "answer": "Организация работы с данными включает различные подходы, такие как использование сервисов для доступа к данным, использование глобального состояния для хранения общих данных между компонентами, применение паттерна хранилища данных (например, Redux или NgRx в Angular), и использование HTTP-запросов для получения данных с сервера. Выбор подхода зависит от требований приложения, его масштаба и архитектурных решений."
      },
      {
        "id": 83,
        "question": "Как подготовить сборник к деплою?",
        "answer": "Подготовка сборки для деплоя включает в себя минимизацию и оптимизацию JavaScript и CSS файлов, удаление неиспользуемого кода, настройку параметров сборки (например, установка базового URL для продакшн окружения), проверку наличия всех необходимых ресурсов и файлов конфигурации, тестирование сборки на локальном или staging сервере, и деплой на целевой сервер или хостинг."
      },
      {
        "id": 84,
        "question": "Что такое NgRx? Когда стоит использовать?",
        "answer": "NgRx — это библиотека для управления состоянием в Angular приложениях с использованием паттерна Redux. NgRx позволяет централизованно хранить и изменять состояние приложения, что упрощает управление данными и делает приложение предсказуемым. NgRx стоит использовать в крупных приложениях с сложным состоянием, когда требуется четкое управление данными, отслеживание изменений и масштабируемость."
      },
      {
        "id": 85,
        "question": "В каких случаях лучше использовать Renderer-сервис вместо нативных методов? И наоборот?",
        "answer": "Renderer-сервис в Angular используется для безопасного манипулирования DOM элементами в обход Angular's зоны выполнения и предотвращения проблем с производительностью при изменении DOM. Он также предоставляет интерфейс для выполнения манипуляций DOM, которые будут работать вне зоны Angular. Нативные методы манипуляции DOM применяются в случаях, когда не требуется обход зоны и когда нужна прямая манипуляция с DOM элементами без дополнительных оберток и абстракций."
      },
      {
        "id": 86,
        "question": "Как работают и для чего нужны резолверы? Как получить данные, загруженные резолверами?",
        "answer": "Резолверы в Angular предназначены для предварительной загрузки данных перед активацией маршрута. Они позволяют выполнить асинхронные операции (например, загрузку данных с сервера) до того, как компонент маршрута будет активирован. Для получения данных, загруженных резолверами, компонент маршрута может использовать ActivatedRouteSnapshot.data или ActivatedRoute.data для доступа к предварительно загруженным данным."
      },
      {
        "id": 87,
        "question": "Как работают и зачем нужны динамические компоненты? Приведите примеры их целесообразного использования.",
        "answer": "Динамические компоненты в Angular позволяют динамически создавать и управлять компонентами во время выполнения. Они полезны в случаях, когда структура компонентов или их поведение зависят от условий или данных, полученных во время выполнения приложения. Примеры использования включают модальные окна, динамические формы, условную загрузку компонентов на основе прав доступа или пользовательских действий."
      },
      {
        "id": 88,
        "question": "Какая разница между @ViewChild и @ContentChild?",
        "answer": "@ViewChild используется для доступа к первому экземпляру дочернего компонента, найденного в представлении текущего компонента. @ContentChild используется для доступа к первому экземпляру дочернего компонента или элемента, найденного в контенте (projected content) текущего компонента. Разница в том, что @ViewChild работает с дочерними компонентами в текущем представлении, в то время как @ContentChild работает с контентом, который был проекционно добавлен в текущий компонент."
      },
      {
        "id": 89,
        "question": "Что делает код и как иначе можно связать класс компонента с переменной? @HostBinding ( 'class.valid') isValid;",
        "answer": "Декоратор @HostBinding используется для привязки значения свойства хост-элемента (element) к свойству класса компонента. В данном случае, класс компонента будет иметь класс 'valid', если значение переменной isValid равно true. Альтернативный способ связи класса компонента с переменной может включать использование ngClass директивы или прямого управления классами элемента с помощью Renderer2 сервиса."
      },
      {
        "id": 90,
        "question": "Как можно кэшировать данные, используя сервисы или RxJS?",
        "answer": "Для кэширования данных в Angular приложении можно использовать сервисы для хранения данных в памяти или локальном хранилище браузера, таком как LocalStorage или SessionStorage. RxJS предоставляет возможности для кэширования данных с использованием операторов like shareReplay или publishReplay, которые позволяют повторно использовать последнее значение Observable."
      },
      {
        "id": 91,
        "question": "Что такое асинхронная валидация форм? Когда применяется и как реализуется?",
        "answer": "Асинхронная валидация форм в Angular позволяет выполнять валидацию данных асинхронно, например, проверять уникальность поля на сервере или загружать дополнительные данные для проверки. Она применяется там, где валидация требует обращения к внешним источникам данных, которые могут быть загружены асинхронно. Реализуется с помощью асинхронных валидаторов, возвращающих Observable или Promise с результатом валидации."
      },
      {
        "id": 92,
        "question": "Зачем нужна forRoot-функция модуля?",
        "answer": "Функция forRoot в модуле используется для регистрации провайдеров сервисов и настройки модуля с использованием глобальных настроек. Она вызывается только в корневом модуле приложения (обычно AppModule) и позволяет передать параметры или настройки для всех экземпляров сервисов, предоставляемых этим модулем. Это позволяет избежать дублирования сервисов и обеспечить единство настроек для всего приложения."
      },
      {
        "id": 93,
        "question": "Какая разница между декларированием и экспортом компонента из модуля?",
        "answer": "Декларирование компонента в NgModule делается с помощью декоратора @Component или @Directive и позволяет Angular узнать о наличии компонента в текущем модуле. Экспорт компонента позволяет использовать компонент в других модулях, импортируя текущий модуль, который содержит этот компонент. Декларация компонента в NgModule обязательна для его использования в текущем модуле, в то время как экспорт делает его доступным для использования в других модулях."
      },
      {
        "id": 94,
        "question": "Почему плохо «провайдить» сервис с shared-модуля в lazy-loaded модуль? (Вопрос о scope модулей.)",
        "answer": "При «провайдинге» сервиса с shared-модуля в lazy-loaded модуль каждый раз создается новый экземпляр сервиса, что приводит к изолированности состояния сервиса между разными модулями. Это может привести к непредсказуемому поведению и потере состояния при переходах между модулями. Рекомендуется провайдить сервисы в корневом модуле (AppModule) или использовать forRoot() функцию для корректного предоставления сервисов."
      },
      {
        "id": 95,
        "question": "Что такое :: ng-deep и для чего используется?",
        "answer": "::ng-deep — это директива Angular, используемая для применения стилей к элементам вложенных компонентов, игнорируя ограничения средств Angular для стилизации вложенных компонентов. Это позволяет переопределить стили вложенных компонентов из родительского компонента без необходимости использовать /deep/ или >>> (deprecated). Однако использование ::ng-deep может привести к проблемам с поддержкой в будущих версиях Angular и рекомендуется применять осторожно."
      },
      {
        "id": 96,
        "question": "Какие тесты можно запустить для Angular-программы? Какие инструменты используют для тестирования Angular-программы?",
        "answer": "Для тестирования Angular-программы можно запустить unit-тесты, интеграционные тесты и end-to-end (e2e) тесты. Unit-тесты проверяют отдельные компоненты или сервисы без зависимостей, интеграционные тесты проверяют взаимодействие между компонентами или модулями, а e2e тесты проверяют работу приложения от начала до конца, как пользователь. Для тестирования Angular-программ используют такие инструменты, как Karma, Jasmine, Protractor, TestBed и другие."
      },
      {
        "id": 97,
        "question": "Как протестировать API-сервис?",
        "answer": "Для тестирования API-сервисов в Angular можно использовать mock-сервисы или HttpClientTestingModule для создания тестового окружения, изолированного от реального API. Mock-сервисы предоставляют заглушки для HTTP-запросов и ответов, что позволяет эмулировать поведение реального API. Также можно использовать HttpClientTestingModule для тестирования взаимодействия с HTTP-запросами без фактического вызова реального API."
      }
    ]
  },
  {
    "position": "middle",
    "topic": "react",
    "questions": [
      {
        "id": 98,
        "question": "Что такое JSX? Что лежит в его основе?",
        "answer": "JSX (JavaScript XML) — это расширение синтаксиса JavaScript, которое позволяет писать HTML-подобные структуры в коде React. Основа JSX — это возможность JavaScript генерировать HTML структуры через специальный синтаксис, который затем компилируется в обычные JavaScript вызовы функций."
      },
      {
        "id": 99,
        "question": "Как работает алгоритм Virtual DOM?",
        "answer": "Алгоритм Virtual DOM в React работает следующим образом: при изменении данных React строит новое дерево Virtual DOM, сравнивает его с предыдущим (diffing), определяет минимальное количество мутаций для обновления реального DOM и применяет эти изменения с минимальными затратами."
      },
      {
        "id": 100,
        "question": "Для чего нужно свойство key во время рендеринга списков?",
        "answer": "Свойство key в React используется для оптимизации производительности при рендеринге списков. Оно помогает React идентифицировать, какие элементы были изменены, добавлены или удалены. Это позволяет React переиспользовать существующие элементы DOM, минимизируя количество манипуляций с DOM и повышая производительность."
      },
      {
        "id": 101,
        "question": "В чем разница между функциональными и классовыми компонентами?",
        "answer": "Функциональные компоненты в React представляют собой чистые функции, которые получают props и возвращают React элементы. Они обычно более просты в написании и понимании. Классовые компоненты используют классы ES6 и имеют состояние (state) и жизненные циклы. Однако с появлением хуков (hooks) функциональные компоненты получили возможность использовать состояние и другие возможности, ранее доступные только классовым компонентам."
      },
      {
        "id": 102,
        "question": "Зачем и когда нужно передавать props в super() при использовании классовых компонентов?",
        "answer": "super(props) вызывается в конструкторе класса при расширении компонента от React.Component для передачи props в конструктор родительского класса. Это необходимо, если в конструкторе компонента нужно использовать props до вызова super(), например, при доступе к props в конструкторе."
      },
      {
        "id": 103,
        "question": "Почему нужно использовать setState() для обновления внутреннего состояния компонента?",
        "answer": "setState() в React используется для обновления состояния компонента. Это позволяет React узнать о необходимости обновления UI. Прямое изменение this.state в React не гарантирует перерисовку компонента, поэтому следует использовать setState(), чтобы уведомить React об изменениях и запустить процесс обновления UI."
      },
      {
        "id": 104,
        "question": "В чем заключается принцип «подъема состояния»?",
        "answer": "Принцип подъема состояния (lifting state up) в React заключается в перемещении состояния из дочерних компонентов в родительский компонент, когда несколько компонентов нужно иметь доступ к одному и тому же состоянию. Это позволяет обеспечить согласованность данных между компонентами и упростить управление состоянием приложения."
      },
      {
        "id": 105,
        "question": "Какие библиотеки менеджмента состояния React-приложения вы знаете? Зачем они нужны?",
        "answer": "В React для управления состоянием приложения используются такие библиотеки, как Redux, MobX, Recoil и другие. Они позволяют централизованно хранить и управлять состоянием приложения, делая его более предсказуемым и управляемым, особенно в случае сложных приложений с большим количеством компонентов."
      },
      {
        "id": 106,
        "question": "Когда следует использовать Redux? Какие есть альтернативы?",
        "answer": "Redux следует использовать, когда в приложении есть сложное состояние, которое требует централизованного управления. Альтернативами Redux являются MobX, Context API (с использованием хуков useContext) и другие менее распространенные библиотеки."
      },
      {
        "id": 107,
        "question": "Redux vs Mobx?",
        "answer": "Redux и MobX — два популярных инструмента для управления состоянием в React. Redux использует однонаправленный поток данных и имеет более строгие правила и большую предсказуемость. MobX предлагает более гибкий подход, где обновления состояния происходят автоматически при изменении данных. Выбор между ними зависит от конкретных потребностей проекта и предпочтений команды."
      },
      {
        "id": 108,
        "question": "Расскажите о базовом принципе работы React Hooks.",
        "answer": "React Hooks — это функции, которые позволяют вам использовать состояние и другие возможности React без написания классов. Основной принцип работы заключается в использовании хуков, таких как useState, useEffect, useContext и других, для добавления состояния и поведения в функциональные компоненты."
      },
      {
        "id": 109,
        "question": "В чем разница между createRef и useRef?",
        "answer": "createRef используется в классовых компонентах для создания ссылки на DOM элемент, а useRef — в функциональных компонентах для создания мутабельной переменной, которая сохраняет свое значение между рендерами."
      },
      {
        "id": 110,
        "question": "Когда следует использовать React refs? Когда не стоит?",
        "answer": "React refs следует использовать, когда нужен доступ к DOM элементу или компоненту для управления фокусом, измерениями или другими манипуляциями, которые невозможно сделать через props. Не следует использовать refs для решения задач, которые можно решить с использованием состояния или props компонентов."
      },
      {
        "id": 111,
        "question": "Какие недостатки библиотеки React видите?",
        "answer": "Среди недостатков React можно выделить изучение и поддержку большого количества хуков и их правильное использование, необходимость внимательного управления состоянием и жизненными циклами компонентов, а также сложность интеграции с некоторыми библиотеками, особенно теми, которые не используют функциональный подход."
      },
      {
        "id": 112,
        "question": "Какие паттерны используете вместе с React?",
        "answer": "Среди популярных паттернов использования в React можно выделить Container/Presentational, Render Props, Higher-Order Components (HOC), Compound Components и другие. Они помогают улучшить структуру кода, делая его более модульным и поддерживаемым."
      },
      {
        "id": 113,
        "question": "Как относитесь к типизации вместе с React?",
        "answer": "Типизация вместе с React (например, с использованием TypeScript или Flow) может значительно улучшить структуру и надежность кода, особенно в больших проектах. Она помогает предотвратить ошибки на этапе разработки и улучшить автодокументирование кода."
      },
      {
        "id": 114,
        "question": "Как построить хорошую архитектуру React-проекта?",
        "answer": "Хорошая архитектура React-проекта включает разделение на компоненты с единой ответственностью, использование контейнерных компонентов для управления состоянием, применение паттернов проектирования (например, MVC, Flux), оптимизацию производительности, правильную организацию файловой структуры и строгий учет правил разметки."
      },
      {
        "id": 115,
        "question": "Оптимизация React-приложений? Как измерить производительность программы?",
        "answer": "Оптимизация React-приложений включает в себя использование мемоизации с помощью useMemo и useCallback, оптимизацию рендеринга с помощью React.memo, асинхронную загрузку данных, разделение на ленивые загрузки, использование ключей для списков и многое другое. Производительность можно измерить с помощью инструментов разработчика браузера (например, Chrome DevTools) и профилировщиков производительности."
      },
      {
        "id": 116,
        "question": "Можно ли приложение на React встроить в другое приложение на React?",
        "answer": "Да, приложение на React можно встроить в другое приложение на React. Это достигается путем рендеринга одного приложения React как части другого приложения, используя контейнерные компоненты или специальные интеграционные библиотеки."
      }
    ]
  },
  {
    "position": "middle",
    "topic": "backend",
    "questions": [
      {
        "id": 117,
        "question": "Почему Node.js однопоточный, а не многопоточный?",
        "answer": "Node.js использует однопоточную модель событийного цикла (event loop), которая позволяет эффективно обрабатывать множество одновременных соединений. Это достигается благодаря асинхронным операциям ввода-вывода (IO), которые не блокируют основной поток выполнения. Такой подход позволяет использовать меньше ресурсов на управление потоками и более эффективно использовать вычислительные ресурсы системы."
      },
      {
        "id": 118,
        "question": "Что такое event driven development?",
        "answer": "Event-driven development (разработка, ориентированная на события) - это подход к разработке программного обеспечения, где основное внимание уделяется обработке событий. Программа реагирует на различные события, такие как клики пользователя, приход данных по сети и другие, вместо того чтобы последовательно выполнять инструкции в программе. Это позволяет создавать реактивные и отзывчивые приложения, которые могут адаптироваться к изменяющемуся окружению и вводу от пользователя."
      },
      {
        "id": 119,
        "question": "Сравните fork() и spawn() методы.",
        "answer": "В Node.js fork() и spawn() - это два метода для создания новых процессов. Метод fork() создает новый процесс, который копирует текущее состояние приложения, включая обработчики событий и память. Это особенно полезно для создания многопроцессорных приложений или при использовании кластеризации. С другой стороны, spawn() создает новый процесс, запуская указанную программу в новом процессе. Это можно использовать для запуска внешних программ или скриптов, которые необходимы для работы приложения."
      },
      {
        "id": 120,
        "question": "Расскажите о Node.js фреймворках, которые использовали. Какая между ними разница?",
        "answer": "Я использовал несколько фреймворков для Node.js, таких как Express.js, Koa.js и Nest.js. Express.js - это минималистичный и гибкий фреймворк для создания веб-приложений и API. Koa.js основан на промисах и предоставляет более современный подход к middleware и обработке запросов. Nest.js - это фреймворк, который стремится предоставить структурированный и расширяемый способ для создания серверных приложений на Node.js, используя TypeScript и объектно-ориентированные принципы."
      },
      {
        "id": 121,
        "question": "Опишите словами код ендпоинта, который должен сохранить с клиента файл размером 4 гигабайта и положить его на S3 или другой CDN.",
        "answer": "Код ендпоинта может выглядеть следующим образом:\n\n```javascript\nconst express = require('express');\nconst multer = require('multer'); // для обработки файлов\nconst AWS = require('aws-sdk'); // для работы с S3\n\nconst app = express();\nconst upload = multer({ dest: 'uploads/' });\n\nconst s3 = new AWS.S3({ /* конфигурация AWS */ });\n\napp.post('/upload', upload.single('file'), async (req, res) => {\n  const file = req.file;\n  const params = {\n    Bucket: 'bucket-name',\n    Key: file.originalname,\n    Body: file.buffer,\n  };\n\n  try {\n    const data = await s3.upload(params).promise();\n    res.json({ success: true, location: data.Location });\n  } catch (err) {\n    console.error('Error uploading file to S3:', err);\n    res.status(500).json({ error: 'Failed to upload file to S3' });\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});\n```\n\nЭтот код использует Express.js для создания сервера, Multer для обработки файлов и AWS SDK для работы с S3. Файл, полученный через POST запрос, загружается в S3 с помощью метода upload()."
      },
      {
        "id": 122,
        "question": "Что такое микросервисы, зачем их используют?",
        "answer": "Микросервисы - это подход к разработке программного обеспечения, где приложение разбивается на небольшие, автономные сервисы, каждый из которых выполняет определенную функцию. Эти сервисы взаимодействуют друг с другом через сетевые вызовы. Микросервисы используются для улучшения масштабируемости, гибкости и поддержки в разработке приложений. Они позволяют независимо разрабатывать, тестировать, развертывать и масштабировать отдельные части приложения."
      },
      {
        "id": 123,
        "question": "В каких случаях вы бы выбрали монолит, а в каких - микросервисы?",
        "answer": "Монолит следует выбирать, когда приложение маленькое, требует минимальной инфраструктуры и поддержки, а также когда скорость разработки имеет большее значение, чем масштабируемость. Микросервисы стоит выбирать в случаях, когда приложение большое и сложное, требует высокой гибкости и масштабируемости, а также когда различные части приложения могут разрабатываться, тестироваться и разворачиваться независимо друг от друга."
      },
      {
        "id": 124,
        "question": "Как понять, что приложение в определенный момент работает исправно?",
        "answer": "Для этого можно использовать мониторинг состояния приложения, системы логирования и метрики производительности. Основные показатели включают доступность приложения, время отклика на запросы, отсутствие ошибок и предупреждений в журналах логов."
      },
      {
        "id": 125,
        "question": "Как понять, что приложение за последние три дня работало исправно?",
        "answer": "Для анализа работы приложения за последние три дня можно использовать системы мониторинга и анализа логов. Важно отслеживать количество ошибок, время ответа на запросы, количество пользовательских сессий и другие метрики производительности."
      },
      {
        "id": 126,
        "question": "Как происходит проверка правильности пароля при использовании bcrypt?",
        "answer": "Bcrypt - это алгоритм хэширования паролей, который использует соль и медленные вычисления для защиты от атак перебора паролей. При проверке правильности пароля происходит следующее: хэш пароля, хранящийся в базе данных, сравнивается с хэшем введенного пользователем пароля. Bcrypt автоматически извлекает соль из хэша, что делает атаки перебора сложными и затратными в вычислительных ресурсах."
      },
      {
        "id": 127,
        "question": "Что такое JWT?",
        "answer": "JWT (JSON Web Token) - это стандарт для создания токенов доступа, которые могут содержать информацию в формате JSON и подписываться цифровой подписью. Токены JWT используются для аутентификации и обмена информацией между сторонами. Они могут быть подписаны ключом, что обеспечивает проверку подлинности данных и защиту от подмены."
      },
      {
        "id": 128,
        "question": "Джуниор прислал код на ревью. Что здесь не так? Как исправить?",
        "answer": "Проблема в том, что переменная `users` не определена в контексте данного обработчика. Для исправления нужно вернуть `user`, который был создан в базе данных, вместо неопределенной переменной `users`. Вот исправленный код:\n\n```javascript\nrouter.post('/users', async (req, res, next) => {\n  try {\n    const user = await db.createUser(req);\n    if (user) {\n      return res.json(user);\n    }\n    res.json({ error: 'cannot create user' });\n  } catch (err) {\n    console.error('Error creating user:', err);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n```\n\nТеперь код корректно возвращает созданного пользователя или сообщение об ошибке при неудачной попытке создания."
      }
    ]
  },
  {
    "position": "middle",
    "topic": "database",
    "questions": [
      {
        "id": 129,
        "question": "Что такое Redis и для чего его используют?",
        "answer": "Redis - это высокопроизводительная система управления данными, которая использует структуры данных в памяти для хранения информации. Его часто используют для кэширования данных, сеансового хранения, работы с очередями сообщений, реализации ленты активности и других задач, где необходима высокая производительность и быстродействие."
      },
      {
        "id": 130,
        "question": "Какие базы данных использовали? Какая разница между SQL и NoSQL?",
        "answer": "Я использовал различные базы данных, включая MySQL, PostgreSQL, MongoDB и Redis. Основная разница между SQL и NoSQL базами данных заключается в структуре данных и способе их хранения. SQL базы данных используют реляционную модель, где данные организованы в таблицы с жесткой схемой. NoSQL базы данных, такие как MongoDB, используют гибкую структуру данных без жесткой схемы, что облегчает масштабирование и работу с неструктурированными данными."
      },
      {
        "id": 131,
        "question": "Для двух таблиц - комментарии и пользователи - напишите запрос, который выбирает последние три комментария для каждого пользователя.",
        "answer": "SELECT * FROM (\n  SELECT *, ROW_NUMBER() OVER(PARTITION BY user_id ORDER BY created_at DESC) AS row_num\n  FROM comments\n) AS ranked\nWHERE row_num <= 3;"
      },
      {
        "id": 132,
        "question": "Я как заказчик прошу выбрать вас базу данных для нового проекта. Ваши действия?",
        "answer": "При выборе базы данных для нового проекта я бы учитывал следующие аспекты:\n\n1. **Требования проекта:** Важно понять, какие типы данных необходимо хранить, скорость доступа к данным, требования к масштабируемости и доступности.\n\n2. **Опыт команды:** Если команда имеет опыт работы с определенной базой данных, это может повлиять на выбор в пользу технологии, с которой разработчики знакомы лучше всего.\n\n3. **Сообщество и поддержка:** Важно учитывать активность сообщества вокруг выбранной базы данных, наличие документации и инструментов поддержки.\n\n4. **Производительность и масштабируемость:** Если проект требует высокой производительности и масштабируемости, то выбор может быть оправдан использованием NoSQL решений или баз данных, поддерживающих горизонтальное масштабирование.\n\nПосле анализа этих аспектов я бы предложил наилучший вариант базы данных для конкретных потребностей проекта заказчику."
      }
    ]
  },
  {
    "position": "middle",
    "topic": "tools",
    "questions": [
      {
        "id": 133,
        "question": "Для чего нужен package-lock.json?",
        "answer": "Файл package-lock.json используется npm для фиксации версий установленных пакетов в проекте. Он гарантирует, что все участники проекта будут использовать одни и те же версии зависимостей, что предотвращает несовместимости и обеспечивает повторяемость установки пакетов на разных системах."
      },
      {
        "id": 134,
        "question": "В чем разница между npm install и npm ci?",
        "answer": "npm install устанавливает зависимости, указанные в файле package.json, учитывая файл package-lock.json для версионирования пакетов. npm ci же используется для строгой установки зависимостей по файлу package-lock.json, игнорируя package.json. Это делает npm ci более предсказуемым и быстрым на этапе сборки проекта."
      },
      {
        "id": 135,
        "question": "Для чего нужны бандлеры?",
        "answer": "Бандлеры используются для объединения различных модулей JavaScript и их зависимостей в один или несколько бандлов (файлов). Это позволяет управлять зависимостями, улучшает производительность загрузки приложения, позволяет использовать новейшие возможности JavaScript и оптимизирует его для продакшн среды."
      },
      {
        "id": 136,
        "question": "Расскажите о модульном подключении скриптов. Приведите пример использования загрузчиков / бандлеров модулей.",
        "answer": "Модульное подключение скриптов позволяет организовать код на JavaScript в небольшие, независимые модули, которые затем могут быть подключены к странице при помощи модульных загрузчиков или бандлеров. Например, с использованием Webpack можно создать конфигурацию, которая позволяет импортировать модули и автоматически собирать их в один или несколько бандлов для размещения на веб-странице."
      },
      {
        "id": 137,
        "question": "Чем различаются git merge и git rebase?",
        "answer": "git merge объединяет изменения из одной ветки в другую, создавая новый коммит, который содержит слияние всех изменений. git rebase же перебазирует текущую ветку на другую ветку, перенося все коммиты текущей ветки поверх последнего коммита целевой ветки. Результат использования rebase - история коммитов становится линейной, что упрощает чтение истории проекта."
      },
      {
        "id": 138,
        "question": "Что такое staging area в git?",
        "answer": "Staging area (или индекс) в Git - это промежуточная область, где размещаются изменения файлов, которые будут включены в следующий коммит. Перед коммитом пользователь добавляет изменения в staging area с помощью команды git add, после чего они готовы к фиксации в репозитории с помощью git commit."
      },
      {
        "id": 139,
        "question": "Опишите процесс code review. Назовите основные правила, способы разрешения конфликтов и споров во время его проведения.",
        "answer": "Code review - это процесс проверки кода, написанного одним разработчиком, другим или группой разработчиков. Основные правила включают проверку стиля кода, архитектуры, безопасности и эффективности. Для разрешения конфликтов и споров полезно следовать принципам конструктивной критики, уважения мнения других участников и фокусироваться на улучшении кода. Полезным инструментом является использование систем для код-ревью, таких как GitHub Pull Requests или GitLab Merge Requests, которые позволяют обсуждать и комментировать изменения прямо в коде."
      }
    ]
  },
  {
    "position": "middle",
    "topic": "practical",
    "questions": [
      {
        "id": 140,
        "question": "Напишите функцию Sleep (ms), которая останавливает выполнение async-функции на заданный промежуток времени.",
        "answer": "async function sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}"
      },
      {
        "id": 141,
        "question": "Реализуйте один из методов массива (например, splice).",
        "answer": "Array.prototype.customSplice = function(start, deleteCount, ...items) {\n  const deleted = this.slice(start, start + deleteCount);\n  const afterDelete = this.slice(start + deleteCount);\n  this.length = start;\n  this.push(...items, ...afterDelete);\n  return deleted;\n};"
      },
      {
        "id": 142,
        "question": "Напишите функцию с RegExp для нахождения всех HTML-ссылок в строке.",
        "answer": "function findLinks(text) {\n  const regex = /<a\\s+(?:[^>]*?\\s+)?href=([\"'])(.*?)\\1/g;\n  const links = [];\n  let match;\n  while ((match = regex.exec(text)) !== null) {\n    links.push(match[2]);\n  }\n  return links;\n}"
      },
      {
        "id": 143,
        "question": "Реализуйте функцию, которая исполнит callback для всех элементов определенной ветви DOM-дерева.",
        "answer": "function traverseDOM(node, callback) {\n  callback(node);\n  node = node.firstElementChild;\n  while (node) {\n    traverseDOM(node, callback);\n    node = node.nextElementSibling;\n  }\n}"
      },
      {
        "id": 144,
        "question": "Реализуйте таблицу с виртуальным скролом.",
        "answer": "К сожалению, для полного ответа требуется больше информации о требованиях и окружении проекта."
      },
      {
        "id": 145,
        "question": "Реализуйте функцию преобразования URL query строки в JSON.",
        "answer": "function parseQueryString(url) {\n  const params = new URLSearchParams(url);\n  const obj = {};\n  for (const [key, value] of params) {\n    obj[key] = value;\n  }\n  return obj;\n}"
      },
      {
        "id": 146,
        "question": "Если есть проект с ограниченными сроками и некритичной производительностью, чем будете руководствоваться при выборе библиотек, подходов? Или все же будете обращать внимание на производительность? Или наоборот: сроки нелимитированные, производительность важна. Ваши действия?",
        "answer": "В проектах с ограниченными сроками и некритичной производительностью предпочтение отдается инструментам и подходам, которые обеспечивают быстрый старт разработки и простоту поддержки. Однако даже в таких проектах важно избегать явных узких мест и выбирать проверенные библиотеки с умеренным потреблением ресурсов."
      }
    ]
  }
]