[
  {
    "position": "junior",
    "topic": "Общие",
    "questions": [
      {
        "id": 1,
        "question": "Какие методы HTTP-запросов вы знаете?",
        "answer": "GET: для получения данных, POST: для отправки данных, PUT: для обновления данных, DELETE: для удаления данных, PATCH: для частичного обновления данных, OPTIONS: для получения поддерживаемых методов, HEAD: для получения заголовков ответа без тела."
      },
      {
        "id": 2,
        "question": "Какие версии HTTP-протокола вам известны?",
        "answer": "HTTP/1.0: начальная версия HTTP, HTTP/1.1: улучшенная версия с поддержкой персистентных соединений и кэширования, HTTP/2: версия с улучшенной производительностью и параллелизмом, HTTP/3: версия на основе протокола QUIC с улучшенной безопасностью и скоростью."
      },
      {
        "id": 3,
        "question": "Какие знаете коды ответа (состояния) HTTP?",
        "answer": "200 OK: успешный запрос, 301 Moved Permanently: ресурс перемещен на новый URL, 302 Found: временное перемещение ресурса, 400 Bad Request: неправильный запрос, 401 Unauthorized: требуется аутентификация, 403 Forbidden: доступ запрещен, 404 Not Found: ресурс не найден, 500 Internal Server Error: внутренняя ошибка сервера."
      },
      {
        "id": 4,
        "question": "Что такое Cross-Origin Resource Sharing? Как устранить проблемы с CORS?",
        "answer": "CORS (Cross-Origin Resource Sharing) — это механизм, позволяющий веб-приложениям запрашивать ресурсы с другого домена. Проблемы с CORS можно устранить, настроив сервер для отправки правильных заголовков, таких как Access-Control-Allow-Origin, и используя прокси-серверы."
      },
      {
        "id": 5,
        "question": "Что такое cookie?",
        "answer": "Cookie — это небольшой фрагмент данных, отправляемый сервером и хранящийся на стороне клиента. Он используется для сохранения состояния пользователя и управления сессиями."
      },
      {
        "id": 6,
        "question": "Какой максимальный размер cookie?",
        "answer": "Максимальный размер одного cookie составляет примерно 4096 байт, но это может зависеть от конкретного браузера и его версии."
      },
      {
        "id": 7,
        "question": "Что означает директива use strict?",
        "answer": "'use strict' — это директива, которая вводит строгий режим в JavaScript. Она помогает выявлять потенциальные ошибки и улучшать производительность кода, запрещая использование небезопасных функций и синтаксиса."
      },
      {
        "id": 8,
        "question": "Чем JS отличается при работе на front-end и back-end?",
        "answer": "На фронтенде JavaScript используется для создания интерактивных пользовательских интерфейсов и динамических веб-страниц. На бэкенде (например, с использованием Node.js) JavaScript используется для создания серверных приложений, обработки запросов и управления базами данных."
      },
      {
        "id": 9,
        "question": "Что такое статическая и динамическая типизации?",
        "answer": "Статическая типизация означает, что типы данных определяются на этапе компиляции (например, в языках Java или C++). Динамическая типизация означает, что типы данных определяются во время выполнения программы (например, в JavaScript или Python)."
      },
      {
        "id": 10,
        "question": "Как клиент взаимодействует с сервером?",
        "answer": "Клиент взаимодействует с сервером через HTTP-запросы. Клиент отправляет запросы (GET, POST, и т.д.) на сервер, а сервер обрабатывает эти запросы и отправляет ответы обратно клиенту."
      },
      {
        "id": 11,
        "question": "Что такое REST?",
        "answer": "REST (Representational State Transfer) — это архитектурный стиль для создания веб-сервисов. Он использует стандартные HTTP-методы (GET, POST, PUT, DELETE) и принципы, такие как статeless взаимодействие и использование ресурсов через URL."
      },
      {
        "id": 12,
        "question": "Объяснить понятие мутабельность/иммутабельность? Какие типы являются мутабельными и наоборот?",
        "answer": "Мутабельность означает возможность изменения объекта после его создания. В JavaScript объекты и массивы являются мутабельными. Иммутабельность означает невозможность изменения объекта после его создания. Примитивные типы данных (например, строки, числа) в JavaScript являются иммутабельными."
      },
      {
        "id": 13,
        "question": "Как искать ошибки в коде? Используете ли вы дебаггер?",
        "answer": "Ошибки в коде можно искать с помощью консольных сообщений (console.log), использования отладочных инструментов в браузере (debugger), написания тестов и применения статических анализаторов кода (например, ESLint)."
      },
      {
        "id": 14,
        "question": "Каких известных людей из мира JS знаете?",
        "answer": "Брендан Эйх (создатель JavaScript), Дуглас Крокфорд (разработчик JSON и автор 'JavaScript: The Good Parts'), Райан Дал (создатель Node.js), Джон Резиг (создатель jQuery)."
      }
    ]
  },
  {
    "position": "junior",
    "topic": "JS Core",
    "questions": [
      {
        "id": 15,
        "question": "Какие существуют типы данных в JS?",
        "answer": "Примитивные типы: String, Number, Boolean, Null, Undefined, Symbol, BigInt. Ссылочные типы: Object, Array, Function, Date, RegExp, Map, Set, WeakMap, WeakSet."
      },
      {
        "id": 16,
        "question": "Как проверить, является ли объект массивом?",
        "answer": "Используйте метод Array.isArray(obj)."
      },
      {
        "id": 17,
        "question": "Как проверить, является ли число конечным?",
        "answer": "Используйте метод Number.isFinite(value)."
      },
      {
        "id": 18,
        "question": "Как проверить, что переменная равна NaN?",
        "answer": "Используйте метод Number.isNaN(value)."
      },
      {
        "id": 19,
        "question": "Чем отличается поведение isNaN() и Number.isNaN()?",
        "answer": "isNaN() преобразует аргумент к числу перед проверкой, что может привести к ложноположительным результатам. Number.isNaN() не преобразует аргумент и проверяет только значения типа Number."
      },
      {
        "id": 20,
        "question": "Сравните ключевые слова var, let, const.",
        "answer": "var: глобальная или функциональная область видимости, может быть переназначена и повторно объявлена; let: блочная область видимости, может быть переназначена, но не повторно объявлена; const: блочная область видимости, не может быть переназначена или повторно объявлена."
      },
      {
        "id": 21,
        "question": "Что такое область видимости?",
        "answer": "Область видимости — это контекст, в котором переменные и функции доступны. В JavaScript существует глобальная, функциональная и блочная области видимости."
      },
      {
        "id": 22,
        "question": "Что такое деструктуризация?",
        "answer": "Деструктуризация — это синтаксис, который позволяет распаковывать значения из массивов или свойства из объектов в отдельные переменные."
      },
      {
        "id": 23,
        "question": "Для чего предназначены методы setTimeout и setInterval?",
        "answer": "setTimeout: вызывает функцию один раз через определенное время. setInterval: вызывает функцию повторно через заданные промежутки времени."
      },
      {
        "id": 24,
        "question": "Сравните подходы работы с асинхронным кодом: сallbacks vs promises vs async / await.",
        "answer": "Callbacks: функции, переданные в другие функции в качестве аргументов для выполнения после завершения операции. Promises: объекты, представляющие завершение или неудачу асинхронной операции, более удобные и читаемые чем callbacks. async/await: синтаксический сахар для работы с промисами, позволяющий писать асинхронный код в синхронном стиле."
      },
      {
        "id": 25,
        "question": "Можно ли записывать новые свойства / функции в прототипы стандартных классов (Array, Object и т. д.)? Почему нет? В каких случаях это делать можно? Как обезопасить себя, если нужно расширить прототип?",
        "answer": "Записывать новые свойства в прототипы стандартных классов можно, но это может привести к конфликтам и поломкам в коде, особенно при использовании сторонних библиотек. Делать это можно только в крайних случаях, при этом следует использовать Object.defineProperty() с установкой enumerable в false, чтобы минимизировать риски."
      },
      {
        "id": 26,
        "question": "Назовите методы массивов, какие помните, и скажите, для чего они нужны.",
        "answer": "push: добавляет элемент в конец массива; pop: удаляет последний элемент из массива; shift: удаляет первый элемент из массива; unshift: добавляет элемент в начало массива; map: создаёт новый массив, вызывая функцию для каждого элемента; filter: создаёт новый массив с элементами, прошедшими проверку функции; reduce: применяет функцию к аккумулятору и каждому элементу массива (слева направо) и сводит к одному значению; forEach: выполняет функцию для каждого элемента массива."
      },
      {
        "id": 27,
        "question": "Какие методы перебора массива знаете? В чем их отличие?",
        "answer": "forEach: выполняет функцию для каждого элемента массива, не возвращает новый массив; map: создаёт новый массив, вызывая функцию для каждого элемента; filter: создаёт новый массив с элементами, прошедшими проверку функции; reduce: применяет функцию к аккумулятору и каждому элементу массива и сводит к одному значению."
      },
      {
        "id": 28,
        "question": "Как работают операторы присваивания / сравнения / строчные / арифметические / битовые и т. д.?",
        "answer": "Операторы присваивания ( =, +=, -=, и т.д.): присваивают значение переменной; операторы сравнения (==, ===, !=, !==, >, <, и т.д.): сравнивают два значения и возвращают true или false; строчные операторы (+): объединяют строки; арифметические операторы (+, -, *, /, %): выполняют математические операции; битовые операторы (&, |, ^, ~, <<, >>, >>>): выполняют операции над битами чисел."
      },
      {
        "id": 29,
        "question": "Опишите назначение и принципы работы с коллекциями Map и Set.",
        "answer": "Map: коллекция, хранящая пары ключ-значение, где ключи могут быть любого типа. Методы: set, get, delete, has, clear. Set: коллекция уникальных значений, где каждое значение может появляться только один раз. Методы: add, delete, has, clear."
      },
      {
        "id": 30,
        "question": "Что означает глубокая (deep) и поверхностная (shallow) копия объекта? Как сделать каждую из них?",
        "answer": "Поверхностная копия: копирует только верхний уровень объекта, вложенные объекты остаются ссылками (Object.assign, spread оператор). Глубокая копия: копирует весь объект вместе со всеми вложенными объектами (рекурсивный метод, JSON.parse(JSON.stringify(obj)), библиотеки, такие как lodash)."
      }
    ]
  },
  {
    "position": "junior",
    "topic": "Функции",
    "questions": [
      {
        "id": 31,
        "question": "Какая разница между декларацией функции (function declaration) и функциональным выражением (function expression)?",
        "answer": "Function declaration (декларация функции) объявляется с ключевым словом function и может быть вызвана до своего объявления благодаря hoisting. Function expression (функциональное выражение) создаётся внутри выражения (например, присваивания переменной) и не поднимается (не подвергается hoisting), поэтому может быть вызвано только после своего объявления."
      },
      {
        "id": 32,
        "question": "Что такое анонимная функция?",
        "answer": "Анонимная функция — это функция без имени. Она часто используется как аргумент при вызове других функций или как значение переменной. Например, function() { return 'Hello, world!'; }."
      },
      {
        "id": 33,
        "question": "Расскажите о стрелочных функциях (arrow function). В чем заключаются отличия стрелочных функций от обычных?",
        "answer": "Стрелочные функции — это сокращенный синтаксис для создания функций. Основные отличия: не имеют своего контекста (this), не имеют arguments объекта, не могут быть использованы как конструкторы (нельзя использовать с new). Пример: const add = (a, b) => a + b."
      },
      {
        "id": 34,
        "question": "Что такое и для чего используют IIFE (Immediately Invoked Function Expression)?",
        "answer": "IIFE (Immediately Invoked Function Expression) — это функция, которая вызывается сразу после своего создания. Используется для создания локальной области видимости, чтобы избежать загрязнения глобальной области. Пример: (function() { console.log('IIFE'); })();"
      },
      {
        "id": 35,
        "question": "Что такое hoisting, как он работает для переменных и функций?",
        "answer": "Hoisting (поднятие) — это поведение JavaScript, при котором объявления переменных и функций поднимаются в начало их области видимости. Функции (function declarations) поднимаются полностью, а объявления переменных (var) поднимаются без их инициализации. let и const также поднимаются, но не инициализируются."
      },
      {
        "id": 36,
        "question": "Что такое замыкание (closure) и какие сценарии его использования?",
        "answer": "Замыкание — это функция, которая имеет доступ к переменным из своей внешней (содержащей) функции даже после того, как эта внешняя функция завершила выполнение. Замыкания часто используются для создания приватных переменных и функций, а также для реализации функций с состоянием."
      },
      {
        "id": 37,
        "question": "Как вы понимаете замыкания? Что будет выведено в консоли в этом случае?\n\nvar f = function() {\n\n  console.log(1);\n\n}\n\nvar execute = function(f) {\n\n  setTimeout(f, 1000);\n\n}\n\nexecute(f); // что выведет в консоль и почему\n\nf = function() {\n\n  console.log(2);\n\n}",
        "answer": "В данном случае в консоли будет выведено 2. Когда функция передается в setTimeout, она сохраняет ссылку на переменную f. На момент выполнения функции по таймеру переменная f уже будет указывать на новую функцию, которая выводит 2."
      },
      {
        "id": 38,
        "question": "Что такое рекурсия?",
        "answer": "Рекурсия — это способ определения функции, при котором функция вызывает саму себя. Рекурсия часто используется для решения задач, которые можно разбить на более мелкие однотипные подзадачи. Важно иметь базовый случай, чтобы избежать бесконечной рекурсии."
      },
      {
        "id": 39,
        "question": "Что означает ключевое слово this?",
        "answer": "this — это ключевое слово в JavaScript, которое указывает на текущий контекст выполнения. В глобальной области видимости this ссылается на глобальный объект (window в браузере), внутри методов объекта this ссылается на объект, внутри функции — зависит от способа вызова функции (обычно undefined в строгом режиме)."
      },
      {
        "id": 40,
        "question": "Что такое потеря контекста, когда происходит и как ее предотвратить?",
        "answer": "Потеря контекста происходит, когда значение this изменяется непреднамеренно. Это может случиться при передаче метода объекта в качестве колбэка или при использовании функций высшего порядка. Предотвратить потерю контекста можно с помощью методов bind, call, apply или стрелочных функций, которые сохраняют контекст родительской функции."
      },
      {
        "id": 41,
        "question": "Методы функций bind / call / apply - зачем и в чем разница?",
        "answer": "call и apply вызывают функцию с указанным this и переданными аргументами. Разница в том, что call принимает аргументы через запятую, а apply — в виде массива. bind возвращает новую функцию с указанным this и фиксированными аргументами, но не вызывает её сразу."
      }
    ]
  },
  {
    "position": "junior",
    "topic": "Front-end",
    "questions": [
      {
        "id": 42,
        "question": "Что такое DOM?",
        "answer": "DOM (Document Object Model) — это объектная модель документа, которая представляет структуру HTML или XML документа в виде дерева. Каждый элемент документа представлен как объект (узел), который можно программно изменять, добавлять или удалять. DOM позволяет взаимодействовать с содержимым веб-страницы через JavaScript."
      },
      {
        "id": 43,
        "question": "Сравните атрибуты подключения скрипта async и defer в HTML-документе.",
        "answer": "Атрибут async загружает скрипт асинхронно и выполняет его сразу после загрузки, не дожидаясь загрузки всей страницы. Атрибут defer также загружает скрипт асинхронно, но выполняет его только после полной загрузки и парсинга HTML-документа. Оба атрибута используются для улучшения производительности загрузки страницы."
      },
      {
        "id": 44,
        "question": "Какая разница между свойствами HTML-элементов innerHTML и innerText?",
        "answer": "innerHTML возвращает или устанавливает HTML-содержимое элемента, включая HTML-теги. innerText возвращает или устанавливает текстовое содержимое элемента, исключая HTML-теги и учитывая стили (например, скрытые элементы не будут включены в innerText)."
      },
      {
        "id": 45,
        "question": "Опишите процесс всплытия (bubbling) событий в DOM.",
        "answer": "Всплытие событий (event bubbling) — это процесс, при котором событие сначала обрабатывается на самом вложенном элементе (target), а затем последовательно всплывает вверх по дереву DOM к родительским элементам, вызывая обработчики событий на каждом уровне. Это позволяет обрабатывать события на родительских элементах."
      },
      {
        "id": 46,
        "question": "Как остановить всплытие (bubbling) события?",
        "answer": "Для остановки всплытия события используется метод stopPropagation() объекта Event. Вызов этого метода в обработчике события предотвращает дальнейшее распространение события вверх по дереву DOM."
      },
      {
        "id": 47,
        "question": "Как остановить дефолтную обработку события?",
        "answer": "Для остановки дефолтной обработки события используется метод preventDefault() объекта Event. Этот метод предотвращает выполнение стандартного действия, ассоциированного с событием (например, переход по ссылке при клике)."
      },
      {
        "id": 48,
        "question": "Чему равен this в обработчике событий (event handler)?",
        "answer": "В обработчике событий this ссылается на элемент, на котором было вызвано событие. Например, если событие клика привязано к кнопке, this будет ссылаться на эту кнопку."
      },
      {
        "id": 49,
        "question": "Что такое LocalStorage и SessionStorage? Какой максимальный размер LocalStorage?",
        "answer": "LocalStorage и SessionStorage — это веб-хранилища, которые позволяют сохранять данные в браузере. LocalStorage сохраняет данные без срока действия (пока пользователь не очистит хранилище вручную), а SessionStorage сохраняет данные только на время текущей сессии (до закрытия вкладки). Максимальный размер LocalStorage составляет примерно 5 МБ на домен."
      },
      {
        "id": 50,
        "question": "Как получить высоту блока? Его положение относительно границ документа?",
        "answer": "Для получения высоты блока можно использовать свойства clientHeight, offsetHeight или getBoundingClientRect().height. Для получения положения блока относительно границ документа можно использовать метод getBoundingClientRect(), который возвращает объект с координатами элемента относительно окна, и затем добавить значение scrollY и scrollX для получения координат относительно документа."
      },
      {
        "id": 51,
        "question": "Что такое webpack?",
        "answer": "Webpack — это популярный модульный сборщик для JavaScript приложений. Он позволяет объединять различные модули в единый бандл, поддерживает обработку и транспиляцию файлов (например, CSS, изображений, TypeScript), а также обеспечивает оптимизацию кода (минификация, tree shaking) для повышения производительности."
      },
      {
        "id": 52,
        "question": "Чем отличается dev-сборник от prod?",
        "answer": "Dev-сборник (development build) предназначен для разработки. Он включает исходные карты (source maps) для отладки, более подробные сообщения об ошибках и не минифицирует код для удобства чтения. Prod-сборник (production build) предназначен для развёртывания на боевых серверах. Он минифицирован, оптимизирован и не включает исходные карты для уменьшения размера и повышения производительности."
      }
    ]
  },
  {
    "position": "junior",
    "topic": "Верстка",
    "questions": [
      {
        "id": 53,
        "question": "Что такое блочная модель CSS?",
        "answer": "Блочная модель CSS описывает как HTML элементы отображаются и взаимодействуют в браузере. Каждый элемент представлен как прямоугольник, состоящий из четырех частей: контент, внутренний отступ (padding), граница (border) и внешний отступ (margin)."
      },
      {
        "id": 54,
        "question": "Какие способы центрирования блочного контента по горизонтали и вертикали знаете?",
        "answer": "Горизонтальное центрирование: margin: 0 auto; text-align: center; использование flexbox: justify-content: center. Вертикальное центрирование: использование flexbox: align-items: center; использование CSS Grid: align-items: center; использование позиционирования и трансформации: position: absolute; top: 50%; transform: translateY(-50%)."
      },
      {
        "id": 55,
        "question": "Какие подходы в верстке вам известны (float, flex, grid, etc.)?",
        "answer": "Существуют несколько подходов в верстке: float — старый метод создания макетов, с плавающими элементами; flexbox — современный метод, обеспечивающий гибкое расположение элементов в одном измерении (горизонтально или вертикально); CSS Grid — мощный инструмент для создания макетов в двух измерениях (по горизонтали и вертикали); inline-block — метод, позволяющий размещать блоки в строку, как текстовые элементы; таблицы (table) — устаревший метод для создания макетов, используется в основном для табличных данных."
      },
      {
        "id": 56,
        "question": "Как сделать приложение responsive?",
        "answer": "Для создания responsive (адаптивного) приложения используются медиа-запросы (media queries) для изменения стилей в зависимости от размера экрана; flexbox и CSS Grid для создания гибких и адаптивных макетов; относительные единицы измерения (проценты, em, rem) вместо абсолютных (px); использование viewport units (vw, vh); адаптивные изображения (srcset, sizes); mobile-first подход — сначала создаются стили для мобильных устройств, затем для более крупных экранов."
      },
      {
        "id": 57,
        "question": "Какие есть принципы семантической верстки?",
        "answer": "Семантическая верстка использует HTML-теги, которые точно описывают содержание и структуру документа. Принципы включают: использование правильных тегов (article, section, header, footer, nav, aside и т.д.) для описания структуры; использование тегов заголовков (h1, h2, и т.д.) для организации содержимого; использование тегов для цитат (blockquote, q), списков (ul, ol, li), таблиц (table, th, tr, td); атрибуты aria для улучшения доступности контента."
      },
      {
        "id": 58,
        "question": "Зачем нужны префиксы для некоторых CSS-свойств (-webkit-, -moz- и т. д.)?",
        "answer": "Префиксы используются для обеспечения совместимости новых CSS-свойств в разных браузерах до их окончательной стандартизации. Они позволяют разработчикам использовать новые возможности CSS, даже если они ещё не полностью поддерживаются всеми браузерами."
      },
      {
        "id": 59,
        "question": "Как упростить написание кросс-браузерных стилей?",
        "answer": "Для упрощения написания кросс-браузерных стилей можно использовать CSS препроцессоры (Sass, LESS); CSS автопрефиксер (Autoprefixer) для автоматического добавления префиксов; normalize.css или reset.css для сброса или нормализации стилей по умолчанию; современные фреймворки и библиотеки (Bootstrap, Foundation); тестирование стилей в разных браузерах и на разных устройствах; использование feature queries (@supports) для проверки поддержки CSS-свойств."
      },
      {
        "id": 60,
        "question": "Практические задачи: прокомментировать и исправить пример плохого CSS или HTML.",
        "answer": "Пример плохого CSS:\n```css\n.bad-style {\n  font-size: 18px;\n  color: blue;\n  margin: 10px;\n  padding: 5px;\n  border: 1px solid black;\n  background-color: yellow;\n}\n```\n\nКомментарий и исправление:\n\n1. Не использованы семантические имена классов.\n2. Нет комментариев для объяснения назначения стилей.\n3. Стили не организованы.\n\nИсправленный CSS:\n```css\n.primary-button {\n  font-size: 1rem;\n  color: #007bff;\n  margin: 0.625rem;\n  padding: 0.3125rem;\n  border: 1px solid #000;\n  background-color: #ff0;\n}\n```\n\nИспользование относительных единиц и семантических имен улучшает код."
      },
      {
        "id": 61,
        "question": "Что такое CSS-препроцессоры? С какими работали? Что нового они приносят в стандартный CSS?",
        "answer": "CSS-препроцессоры (Sass, LESS, Stylus) добавляют дополнительные возможности к стандартному CSS, такие как переменные, вложенные правила, миксины, функции и операции. Они упрощают написание и поддержку CSS, делая код более модульным и удобочитаемым. Препроцессоры компилируются в обычный CSS, который понимают браузеры."
      }
    ]
  },
  {
    "position": "junior",
    "topic": "Angular",
    "questions": [
      {
        "id": 62,
        "question": "Перечислите основные компоненты фреймворка (модуль, роут, директива и т .п.).",
        "answer": "Основные компоненты фреймворка включают: модули (modules) для организации кода и функциональности; компоненты (components) для создания пользовательских интерфейсов; директивы (directives) для изменения поведения элементов DOM; маршруты (routes) для навигации между страницами; сервисы (services) для выполнения бизнес-логики и взаимодействия с API; пайпы (pipes) для преобразования данных в шаблонах."
      },
      {
        "id": 63,
        "question": "В чем разница между компонентом и директивой?",
        "answer": "Компонент — это директива с шаблоном, который определяет пользовательский интерфейс. Директива — это класс, который изменяет поведение или внешний вид элементов DOM, но не обязательно имеет шаблон."
      },
      {
        "id": 64,
        "question": "Расскажите о жизненном цикле компонента.",
        "answer": "Жизненный цикл компонента включает этапы создания, изменения и уничтожения. Основные этапы: инициализация (ngOnInit), изменение данных входных параметров (ngOnChanges), проверка изменений (ngDoCheck), завершение обновления представления (ngAfterContentInit, ngAfterContentChecked, ngAfterViewInit, ngAfterViewChecked), уничтожение (ngOnDestroy)."
      },
      {
        "id": 65,
        "question": "Перечислите часто используемые хуки жизненного цикла компонента и расскажите, для чего они нужны?",
        "answer": "ngOnInit — выполняется один раз после инициализации компонента; ngOnChanges — вызывается при изменении входных данных; ngDoCheck — вызывается при проверке изменений; ngAfterContentInit — вызывается после вставки контента в представление; ngAfterContentChecked — вызывается после каждой проверки контента; ngAfterViewInit — вызывается после инициализации представления; ngAfterViewChecked — вызывается после каждой проверки представления; ngOnDestroy — вызывается перед уничтожением компонента."
      },
      {
        "id": 66,
        "question": "В чем разница между конструктором и ngOnInit-хуком?",
        "answer": "Конструктор используется для инициализации зависимостей и создания экземпляра класса компонента. ngOnInit используется для выполнения логики инициализации, которая требует завершения создания компонента и его зависимостей."
      },
      {
        "id": 67,
        "question": "Как защитить роут от несанкционированного доступа? Какие механизмы предоставляет для этого фреймворк?",
        "answer": "Для защиты маршрутов используются Guards (CanActivate, CanDeactivate, CanLoad, CanActivateChild), которые проверяют условия доступа к маршрутам. Эти Guards могут выполнять проверку аутентификации, авторизации или других условий перед разрешением перехода к маршруту."
      },
      {
        "id": 68,
        "question": "Что такое Lazy loading, как и для чего используется?",
        "answer": "Lazy loading — это отложенная загрузка модулей или компонентов, которая происходит только при необходимости (например, при переходе к определенному маршруту). Это улучшает производительность приложения, уменьшая начальный размер бандла и ускоряя загрузку страниц."
      },
      {
        "id": 69,
        "question": "Какое назначение RouterOutlet?",
        "answer": "RouterOutlet — это директива, которая указывает Angular, где отображать компоненты, соответствующие активным маршрутам. Это точка вставки для компонентов, отображаемых при навигации по приложению."
      },
      {
        "id": 70,
        "question": "Как компоненты могут взаимодействовать друг с другом?",
        "answer": "Компоненты могут взаимодействовать через: входные (@Input) и выходные (@Output) параметры; общие сервисы для обмена данными; использование родительских и дочерних компонентов для передачи данных и вызова методов; использование RxJS Subjects для обмена данными и событий."
      },
      {
        "id": 71,
        "question": "Как создать two-way binding свойство для компонента?",
        "answer": "Для создания two-way binding свойства используется комбинация @Input и @Output параметров. @Input параметр используется для получения значения, а @Output с EventEmitter для отправки изменений обратно. Декоратор @Input декорирует свойство компонента, принимающее значение, а @Output — метод, который генерирует событие с новым значением."
      },
      {
        "id": 72,
        "question": "Какие типы форм у фреймворка? В каких случаях и что лучше использовать?",
        "answer": "Фреймворк предоставляет два типа форм: Template-driven forms, которые используют директивы в шаблонах для создания форм (подходящи для простых форм и быстрой разработки); Reactive forms, которые используют реактивные объекты и классы для создания форм (подходящи для сложных форм, требующих высокой гибкости и тестируемости)."
      },
      {
        "id": 73,
        "question": "Какие состояния у формы и как это можно применить?",
        "answer": "Состояния формы включают: pristine (форма не изменена), dirty (форма изменена), valid (форма валидна), invalid (форма невалидна), touched (элемент формы был посещен), untouched (элемент формы не был посещен). Эти состояния используются для валидации, отображения сообщений об ошибках и управления состоянием кнопок."
      },
      {
        "id": 74,
        "question": "Зачем нужны сервисы? Как с ними работать?",
        "answer": "Сервисы используются для инкапсуляции бизнес-логики и взаимодействия с API, а также для обмена данными между компонентами. Они регистрируются в инжекторе и могут быть внедрены в компоненты через конструктор с помощью механизма Dependency Injection."
      },
      {
        "id": 75,
        "question": "Что такое singleton-сервисы? Каково их назначение? Способ создания?",
        "answer": "Singleton-сервисы — это сервисы, которые существуют в единственном экземпляре в течение всего времени работы приложения. Они создаются и управляются Angular Dependency Injection и регистрируются в корневом модуле (providers: [ServiceName]) или с помощью декоратора @Injectable({ providedIn: 'root' })."
      },
      {
        "id": 76,
        "question": "Какие есть способы объявления сервисов?",
        "answer": "Сервисы могут быть объявлены: в секции providers модуля; в секции providers компонента; с использованием декоратора @Injectable({ providedIn: 'root' }) для автоматической регистрации в корневом модуле."
      },
      {
        "id": 77,
        "question": "Для чего нужны модули? Сколько их должно быть в проекте?",
        "answer": "Модули (NgModules) организуют код и функциональность приложения, делая его структурированным и модульным. Они позволяют разбивать приложение на логические части и повторно использовать их. Количество модулей зависит от размера и сложности проекта; рекомендуется создавать отдельные модули для функциональных областей и общих ресурсов."
      },
      {
        "id": 78,
        "question": "Зачем нужны общие модули (shared)?",
        "answer": "Общие модули (shared modules) содержат компоненты, директивы и пайпы, которые используются в нескольких местах приложения. Это позволяет избежать дублирования кода и облегчить его поддержку, обеспечивая централизованное место для общих ресурсов."
      },
      {
        "id": 79,
        "question": "Какие преимущества типизации в TypeScript?",
        "answer": "Типизация в TypeScript обеспечивает: обнаружение ошибок на этапе компиляции; улучшенную поддержку редакторов кода и автодополнения; явную документацию кода через типы; улучшенную читаемость и поддерживаемость кода; возможность использования интерфейсов и типовых параметров для создания более гибких и безопасных программных конструкций."
      },
      {
        "id": 80,
        "question": "Какие возможности TypeScript можно использовать для типизации (здесь имеются в виду интерфейсы, типы, enum и т. д.)?",
        "answer": "TypeScript предоставляет различные возможности для типизации: интерфейсы (interface) для определения контрактов объектов; типы (type) для создания алиасов типов и объединений; перечисления (enum) для определения наборов связанных значений; типовые параметры (generic) для создания обобщенных классов, функций и интерфейсов; модули (namespace) для организации кода и предотвращения конфликтов имен."
      },
      {
        "id": 81,
        "question": "Какая разница между интерфейсом и классом?",
        "answer": "Интерфейс описывает структуру объекта, определяя его свойства и методы, но не содержит реализации. Класс определяет как структуру, так и реализацию объекта, включая методы и свойства. Класс может реализовывать один или несколько интерфейсов."
      },
      {
        "id": 82,
        "question": "В чем разница между интерфейсом и абстрактным классом?",
        "answer": "Интерфейс определяет только сигнатуры методов и свойств без реализации. Абстрактный класс может содержать как абстрактные методы (без реализации), так и методы с реализацией. Классы могут наследоваться от одного абстрактного класса, но могут реализовывать несколько интерфейсов."
      },
      {
        "id": 83,
        "question": "Какая разница между интерфейсом и типом?",
        "answer": "Интерфейсы используются для определения структуры объектов, тогда как типы (type) могут использоваться для создания алиасов любых типов, включая объединения (union) и пересечения (intersection). Типы более гибкие и могут описывать более сложные конструкции, чем интерфейсы."
      },
      {
        "id": 84,
        "question": "Что такое RxJS? Как он используется во фреймворке? Какие компоненты фреймворка тесно связаны с ним?",
        "answer": "RxJS (Reactive Extensions for JavaScript) — библиотека для работы с асинхронными данными с использованием Observable-паттерна. В Angular RxJS используется для управления асинхронными операциями, такими как HTTP-запросы и события. RxJS тесно связан с HttpClient и FormControl, а также используется в сервисах и компонентах для обработки потоков данных."
      },
      {
        "id": 85,
        "question": "Чем отличаются Observable и Promise?",
        "answer": "Observable — это поток данных, который может генерировать несколько значений во времени и может быть отменен. Promise — это единичное значение, которое асинхронно возвращается и не может быть отменено. Observable предоставляет больше возможностей для управления асинхронными операциями и реактивного программирования."
      },
      {
        "id": 86,
        "question": "Для чего нужны Subjects? Какие типы Subjects существуют?",
        "answer": "Subjects в RxJS — это специальные Observable, которые позволяют мультикастинг (отправку данных нескольким подписчикам). Существуют разные типы Subjects: Subject, BehaviorSubject, ReplaySubject и AsyncSubject. BehaviorSubject хранит текущее значение и отправляет его новым подписчикам; ReplaySubject сохраняет историю значений и отправляет её новым подписчикам; AsyncSubject отправляет последнее значение только после завершения выполнения."
      },
      {
        "id": 87,
        "question": "Как сделать несколько последовательных запросов к API с помощью HTTP-сервиса и RxJS?",
        "answer": "Для выполнения нескольких последовательных запросов к API используются операторы RxJS, такие как concatMap, switchMap или mergeMap. Они позволяют управлять потоком данных и выполнять запросы последовательно, сохраняя порядок выполнения и обработки ответов."
      },
      {
        "id": 88,
        "question": "Какая разница между switchMap, concatMap, mergeMap?",
        "answer": "switchMap отменяет предыдущий запрос при получении нового значения; concatMap выполняет запросы последовательно, сохраняя порядок; mergeMap выполняет запросы параллельно, объединяя результаты."
      },
      {
        "id": 89,
        "question": "Как можно конфигурировать Angular-приложение?",
        "answer": "Angular-приложение можно конфигурировать с помощью environment-файлов для разных сред (development, production), использование injection tokens для настройки зависимостей, настройка роутинга и модулей через декораторы и параметры."
      },
      {
        "id": 90,
        "question": "Зачем нужны environment-файлы? Когда их лучше не использовать?",
        "answer": "Environment-файлы используются для хранения конфигурации приложения для разных сред (например, URL-адреса API, ключи и флаги). Их лучше не использовать для хранения чувствительной информации, такой как пароли или ключи безопасности, которые должны быть защищены другими методами."
      },
      {
        "id": 91,
        "question": "В чем разница между «умным» (smart) и «глупым» (dumb) компонентами? В каких случаях применяется каждый из них?",
        "answer": "«Умные» компоненты (smart) управляют состоянием приложения и бизнес-логикой, взаимодействуют с сервисами и API. «Глупые» компоненты (dumb) отвечают только за отображение данных и пользовательский интерфейс, получая данные через входные параметры. Использование «умных» компонентов позволяет разделить логику приложения и UI, улучшая модульность и тестируемость."
      },
      {
        "id": 92,
        "question": "В чем разница между NgForm, FormGroup и FormControl и как их применяют для построения форм?",
        "answer": "NgForm используется для создания шаблонных форм; FormGroup объединяет несколько FormControl в логическую группу; FormControl представляет отдельное поле формы. В реативных формах используется FormGroup и FormControl для построения и управления состоянием формы и её валидацией."
      },
      {
        "id": 93,
        "question": "Зачем нужен и как работает async pipe?",
        "answer": "Async pipe используется для автоматического подписывания и отписывания от Observable или Promise в шаблонах. Он упрощает управление асинхронными данными, автоматически обновляя шаблон при получении новых данных и освобождая ресурсы при уничтожении компонента."
      },
      {
        "id": 94,
        "question": "Как следить за развитием фреймворка? Каких известных людей, связанных с Angular, знаете / читаете?",
        "answer": "Следить за развитием фреймворка можно через официальные блоги, репозитории на GitHub, конференции и сообщества. Известные люди в сообществе Angular: Мишко Хевери (Misko Hevery), Брэд Грин (Brad Green), Виктор Савкин (Victor Savkin), Стивен Флюин (Stephen Fluin), Джон Папа (John Papa)."
      }
    ]
  },
  {
    "position": "junior",
    "topic": "React",
    "questions": [
      {
        "id": 95,
        "question": "Работали ли вы с классовыми компонентами? В чем их особенность?",
        "answer": "Да, классовые компоненты в React используют классы ES6 для определения компонентов. Основные особенности классовых компонентов включают использование жизненного цикла React (componentDidMount, componentDidUpdate и т. д.), возможность использования состояния (state), их способность хранить внутреннее состояние и использование метода render() для возвращения JSX."
      },
      {
        "id": 96,
        "question": "Какие данные лучше хранить в состоянии компонента, а какие передавать через пропсы?",
        "answer": "В состоянии компонента лучше хранить данные, которые могут изменяться в процессе работы компонента и влияют на его внутреннее состояние или отображение. Примеры включают данные, введенные пользователем в форме или текущее состояние загрузки данных. Пропсы (props) следует использовать для передачи данных от родительского компонента к дочернему. Это может быть информация о конфигурации, которая не меняется внутри компонента, или функции обратного вызова, которые компонент может вызывать при определенных событиях."
      },
      {
        "id": 97,
        "question": "Ознакомлены ли вы с хуками? В чем их преимущества? Приходилось ли делать свои и с какой целью?",
        "answer": "Да, хуки (hooks) в React представляют собой функции, позволяющие использовать состояние и другие возможности React без написания классов. Их преимущества включают улучшенную читаемость и повторное использование кода, более простую организацию логики компонента и возможность использования функциональных возможностей React в функциональных компонентах. Я использовал стандартные хуки, такие как useState и useEffect, и создавал свои хуки для абстрагирования логики, которая может повторно использоваться в разных компонентах."
      },
      {
        "id": 98,
        "question": "Знакомы ли вы с фрагментами и порталами? Зачем они нужны?",
        "answer": "Да, фрагменты (fragments) позволяют группировать дочерние элементы без добавления лишних узлов в DOM. Они полезны для возврата нескольких элементов из компонента без оборачивания их в дополнительный узел. Порталы (portals) используются для рендеринга дочерних элементов в DOM-узлы, которые находятся вне иерархии DOM-дерева родительского компонента. Это позволяет контролировать местоположение дочерних элементов и решать проблемы z-index приложений."
      },
      {
        "id": 99,
        "question": "Когда и для чего используют рефы?",
        "answer": "Рефы (refs) используются для получения ссылки на DOM-узел или экземпляр компонента в React. Они полезны в случаях, когда требуется изменить фокус, измерить размер элемента, анимировать компонент или интегрировать сторонние библиотеки, несовместимые с React. Рефы также используются для вызова методов компонента напрямую или для работы с внешними DOM-элементами, такими как формы или анимации."
      },
      {
        "id": 100,
        "question": "Какие вы знаете методы жизненного цикла компонента?",
        "answer": "Основные методы жизненного цикла компонента в React включают: componentDidMount, componentDidUpdate, componentWillUnmount, shouldComponentUpdate, getDerivedStateFromProps, componentDidCatch. Каждый из этих методов выполняет определенные действия в процессе жизненного цикла компонента, такие как инициализация, обновление, удаление и обработка ошибок."
      },
      {
        "id": 101,
        "question": "В каком методе жизненного цикла компонента лучше делать запросы на сервер? Почему?",
        "answer": "Лучше всего делать запросы на сервер в методе componentDidMount. Этот метод вызывается после монтирования компонента в DOM, что делает его подходящим местом для инициализации загрузки данных с сервера. Вызов метода в этом жизненном цикле также предотвращает избыточные запросы на сервер при обновлении компонента."
      },
      {
        "id": 102,
        "question": "В каком методе жизненного цикла компонента лучше делать подписку и отписку от листенера? Почему? Зачем отписываться?",
        "answer": "Подписку на листенеры лучше всего выполнять в методе componentDidMount, а отписку — в componentWillUnmount. Это связано с тем, что componentDidMount вызывается после того, как компонент отрендерен в DOM, и является подходящим местом для инициализации слушателей событий. Отписка в componentWillUnmount важна для предотвращения утечек памяти и избыточного использования ресурсов браузера при удалении компонента из DOM."
      },
      {
        "id": 103,
        "question": "Был ли опыт работы с контекстом? Когда его стоит использовать?",
        "answer": "Да, контекст в React используется для передачи данных через дерево компонентов без необходимости передачи пропсов через каждый уровень. Он стоит использовать, когда данные должны быть доступны множеству компонентов на разных уровнях вложенности, например, информация о текущем пользователе или тема приложения."
      },
      {
        "id": 104,
        "question": "В чем особенность PureComponent?",
        "answer": "PureComponent — это классовый компонент в React, который реализует метод shouldComponentUpdate с поверхностным сравнением пропсов и состояния перед рендерингом. Это позволяет избежать лишних перерисовок компонента, если его пропсы и состояние не изменились. PureComponent следует использовать вместо обычного компонента, если он рендерит одни и те же результаты при одних и тех же пропсах и состояниях, чтобы оптимизировать производительность."
      },
      {
        "id": 105,
        "question": "Работали ли вы с мемоизоваными селекторами (memoized selectors)? Для чего их используют и какой принцип работы?",
        "answer": "Да, мемоизированные селекторы используются для кэширования результатов вычислений, основанных на входных данных. Они помогают избежать повторных вычислений в компонентах React и повышают производительность, сохраняя результаты предыдущих вычислений для одинаковых входных данных. Принцип работы заключается в том, что селектор запоминает аргументы и возвращает закэшированное значение, если аргументы не изменились, или вычисляет новое значение, если аргументы изменились."
      },
      {
        "id": 106,
        "question": "В чем видите преимущества библиотеки React?",
        "answer": "React предлагает множество преимуществ, включая декларативный подход к созданию пользовательского интерфейса, компонентную архитектуру для повторного использования кода, виртуальный DOM для оптимизации производительности, поддержку серверного рендеринга, широкую экосистему библиотек и инструментов, а также активное сообщество разработчиков."
      },
      {
        "id": 107,
        "question": "Почему библиотека React быстрая? Что такое Virtual DOM и Shadow DOM?",
        "answer": "React достигает высокой производительности благодаря виртуальному DOM (Virtual DOM). Виртуальный DOM — это внутреннее представление DOM-структуры приложения, которое React использует для эффективного сравнения и обновления реального DOM. Он позволяет минимизировать количество манипуляций с DOM и повышает скорость рендеринга. Shadow DOM — это часть стандарта веб-компонентов, который позволяет изолировать структуру DOM и стили компонента от внешнего контента страницы."
      },
      {
        "id": 108,
        "question": "Зачем в списках ключи? Можно ли делать ключами индексы элементов массива? Когда это оправдано?",
        "answer": "Ключи (keys) в списках React помогают идентифицировать каждый элемент списка во время рендеринга. Это позволяет React эффективно обновлять только измененные элементы, а не перерисовывать весь список. Использование индексов элементов массива в качестве ключей не рекомендуется, так как это может привести к проблемам при изменении порядка или удалении элементов списка. Оправдано использование индексов только в случае, если порядок элементов не меняется и список статичен."
      },
      {
        "id": 109,
        "question": "В чем основная идея Redux?",
        "answer": "Основная идея Redux заключается в централизованном хранении состояния приложения и управлении им с помощью предсказуемых и чистых функций редукторов. Redux позволяет управлять сложными состояниями приложения и обеспечивает однонаправленный поток данных."
      },
      {
        "id": 110,
        "question": "Работа со стилями в React.",
        "answer": "Стили в React можно управлять различными способами: встроенные стили через объекты JavaScript, использование CSS-модулей для локальной области видимости стилей, использование CSS-in-JS библиотек (например, styled-components или emotion), подключение внешних CSS или препроцессоров через Webpack."
      },
      {
        "id": 111,
        "question": "React - это библиотека или фреймворк? Какая разница между этими двумя понятиями.",
        "answer": "React — это библиотека для создания пользовательских интерфейсов (UI), а не полноценный фреймворк. Основная разница между библиотекой и фреймворком заключается в уровне контроля и внутренней архитектуре. Библиотека предоставляет набор инструментов для решения конкретных задач (например, отрисовка UI), тогда как фреймворк определяет структуру приложения и управляет всем его жизненным циклом."
      },
      {
        "id": 112,
        "question": "Можно ли использовать jQuery вместе с React? Почему да / нет?",
        "answer": "Технически можно использовать jQuery вместе с React, но это не рекомендуется. React и jQuery используют разные подходы к управлению DOM и состоянием. Использование jQuery может привести к конфликтам между обновлением DOM React и jQuery, что может вызвать неожиданное поведение или ухудшение производительности приложения. Вместо этого лучше использовать альтернативы, такие как нативные методы JavaScript или библиотеки, совместимые с React, например, lodash."
      },
      {
        "id": 113,
        "question": "Что такое codemod?",
        "answer": "Codemod — это программный скрипт, который автоматически преобразует исходный код одного формата в другой. Они часто используются для обновления кодовой базы при изменениях в языке программирования, библиотеках или стандартах кодирования."
      },
      {
        "id": 114,
        "question": "Приходилось ли вам настраивать проект React с нуля? С помощью каких инструментов вы это делали?",
        "answer": "Да, приходилось настраивать проект React с нуля. Для этого я использовал инструменты такие как Create React App для быстрого старта проекта с предустановленной конфигурацией, Webpack для настройки сборки и управления зависимостями, Babel для транспиляции JavaScript и поддержки современных функций языка."
      },
      {
        "id": 115,
        "question": "Перечислите все библиотеки, которые использовали в связке с React.",
        "answer": "В связке с React я использовал различные библиотеки в зависимости от требований проекта, включая Redux для управления состоянием, React Router для навигации, Axios для работы с HTTP-запросами, Formik для управления формами, Styled-components для CSS-in-JS и другие."
      },
      {
        "id": 116,
        "question": "Что самое сложное вам приходилось реализовывать с помощью React?",
        "answer": "Одной из самых сложных задач, с которыми мне приходилось сталкиваться в React, было создание сложных форм с динамически изменяющейся структурой и валидацией данных. Это требовало глубокого понимания управления состоянием в React, работы с асинхронными операциями, а также использования различных библиотек для форм и валидации."
      }
    ]
  },
  {
    "position": "junior",
    "topic": "Back-end",
    "questions": [
      {
        "id": 117,
        "question": "Что такое REPL?",
        "answer": "REPL (Read-Eval-Print Loop) — это интерактивная среда, которая позволяет вводить команды (обычно на языке программирования), которые сразу же исполняются, и выводить результаты. Примеры REPL включают Node.js REPL, Python REPL (интерпретатор Python), и другие."
      },
      {
        "id": 118,
        "question": "Что такое streams в Node.js?",
        "answer": "Streams в Node.js представляют собой объекты, которые позволяют читать или записывать данные побайтово (или кусочно), вместо того чтобы загружать их полностью в память. Это особенно полезно при работе с большими объемами данных или при работе с сетевыми запросами."
      },
      {
        "id": 119,
        "question": "Что такое middleware?",
        "answer": "Middleware — это функции, которые выполняются последовательно в цепочке при обработке HTTP-запросов во фреймворках, таких как Express.js. Они могут модифицировать запрос, ответ или просто выполнять какие-то действия перед тем, как передать управление следующему middleware или обработчику маршрута."
      },
      {
        "id": 120,
        "question": "Для чего используют функцию setImmediate?",
        "answer": "Функция setImmediate используется в Node.js для планирования выполнения кода после завершения текущего цикла событий. Она гарантирует, что колбэк будет вызван немедленно после завершения текущей операции, даже если есть другие задачи в очереди."
      },
      {
        "id": 121,
        "question": "Зачем нужен app.param() в express?",
        "answer": "Метод app.param() в Express.js используется для определения middleware, которые будут выполнены перед обработкой маршрутов, содержащих указанный параметр. Это позволяет предварительно обработать параметры маршрутов и выполнить определенные действия, например, проверку наличия объекта в базе данных по заданному идентификатору."
      },
      {
        "id": 122,
        "question": "Что такое token based authentication?",
        "answer": "Token based authentication — это метод аутентификации, при котором клиент получает токен (часто JWT — JSON Web Token) после успешной аутентификации. Этот токен используется для авторизации последующих запросов к серверу. Токен содержит информацию о пользователе и может быть проверен на сервере без необходимости хранения состояния аутентификации на сервере."
      }
    ]
  },
  {
    "position": "junior",
    "topic": "Базы данных",
    "questions": [
      {
        "id": 123,
        "question": "Напишите простой запрос для вычисления трех авторов, у которых больше всего книг.",
        "answer": "SELECT author_id, COUNT(*) as book_count FROM books GROUP BY author_id ORDER BY book_count DESC LIMIT 3;"
      },
      {
        "id": 124,
        "question": "Напишите запрос, который выбирает последние три комментария для конкретного пользователя для двух таблиц: комментарии и пользователи.",
        "answer": "SELECT comments.* FROM comments JOIN users ON comments.user_id = users.id WHERE users.id = ? ORDER BY comments.created_at DESC LIMIT 3;"
      },
      {
        "id": 125,
        "question": "Спроектируйте простую схему базы данных для библиотеки.",
        "answer": "Схема базы данных для библиотеки может выглядеть так:\n- Таблица books (id, title, author_id, genre, published_date)\n- Таблица authors (id, name, birth_date, death_date)\n- Таблица users (id, name, email, membership_date)\n- Таблица loans (id, user_id, book_id, loan_date, return_date)"
      },
      {
        "id": 126,
        "question": "Для чего используют SQL-оператор HAVING?",
        "answer": "Оператор HAVING используется для фильтрации результатов, полученных после применения оператора GROUP BY. Он позволяет задавать условия для агрегатных функций, таких как COUNT, SUM и AVG."
      },
      {
        "id": 127,
        "question": "Зачем используют SQL-оператор LEFT JOIN?",
        "answer": "Оператор LEFT JOIN используется для объединения двух таблиц, включая все записи из левой таблицы и соответствующие записи из правой таблицы. Если в правой таблице нет соответствующих записей, результат все равно будет включать все записи из левой таблицы с NULL значениями для столбцов из правой таблицы."
      },
      {
        "id": 128,
        "question": "Чем отличается embed- от reference-связи в MongoDB?",
        "answer": "В MongoDB embed-связи означают, что вложенные документы хранятся внутри родительского документа, что позволяет быстро получать всю связанную информацию. Reference-связи означают, что документы содержат ссылки на другие документы, что экономит место и позволяет использовать нормализацию данных, но требует дополнительных запросов для получения связанной информации."
      },
      {
        "id": 129,
        "question": "В одном проекте программисты сохраняют данные в MongoDB-коллекции комментариев, используя такие типы данных (смотрите ниже). Что плохого в этом решении?\nid: ObjectID\ntext: string\nauthor_id: string\ncreated_at: Date",
        "answer": "Проблема в том, что author_id сохраняется как строка вместо ObjectID. Это может вызвать проблемы с производительностью и целостностью данных. Лучше использовать ObjectID для хранения author_id, чтобы поддерживать ссылочную целостность и улучшить производительность запросов."
      },
      {
        "id": 130,
        "question": "В проекте понадобилось внести изменения в структуру таблиц, добавить несколько полей и индексы. Как программисты будут делать это на продакшене?",
        "answer": "Программисты будут использовать миграции базы данных для внесения изменений в структуру таблиц на продакшене. Миграции позволяют последовательно применять изменения схемы базы данных, добавлять поля, создавать индексы и т.д., что помогает поддерживать согласованность данных и минимизировать простои."
      }
    ]
  },
  {
    "position": "junior",
    "topic": "Инструменты",
    "questions": [
      {
        "id": 131,
        "question": "Каждый раз, когда вы делаете pull, почему-то случается конфликт в последней строке во всех файлах, которые вы редактировали. Что происходит?",
        "answer": "Конфликты на последней строке файлов часто возникают из-за различий в формате перевода строки (LF vs CRLF) между операционными системами. Например, Unix-подобные системы используют LF, тогда как Windows использует CRLF. Использование консистентного формата перевода строки и конфигурации git, такой как .gitattributes, может помочь избежать таких конфликтов."
      },
      {
        "id": 132,
        "question": "Что делает команда git fetch?",
        "answer": "Команда git fetch загружает изменения из удаленного репозитория в ваш локальный репозиторий, но не сливает их с вашими текущими изменениями. Это позволяет вам видеть обновления на удаленном репозитории без изменения вашего рабочего состояния."
      },
      {
        "id": 133,
        "question": "Какой git hygiene подходы вы знаете?",
        "answer": "К git hygiene подходам относятся:\n- Регулярные коммиты с осмысленными сообщениями.\n- Использование веток для разработки новых фич и исправления багов.\n- Регулярное слияние или ребейз веток, чтобы минимизировать конфликты.\n- Проверка кода перед слиянием (code review).\n- Использование .gitignore для исключения временных или ненужных файлов."
      },
      {
        "id": 134,
        "question": "Что такое CI / CD? Для чего это нужно?",
        "answer": "CI (Continuous Integration) - это практика регулярной интеграции изменений в основной код, с автоматическим тестированием каждого изменения. CD (Continuous Delivery/Continuous Deployment) - это практика автоматического развертывания проверенного кода в производственную среду. Эти практики помогают обнаруживать ошибки на ранних стадиях разработки, обеспечивают стабильность и ускоряют выпуск новых версий."
      }
    ]
  },
  {
    "position": "junior",
    "topic": "Практические задания",
    "questions": [
      {
        "id": 135,
        "question": "Расскажите, какие есть способы копирования простого объекта типа obj = {a: 1, b: 2, c: 3}",
        "answer": "Для копирования простого объекта можно использовать несколько способов:\n1. Object.assign: const newObj = Object.assign({}, obj);\n2. Spread operator: const newObj = {...obj};\n3. JSON.parse(JSON.stringify(obj)) - для глубокого копирования, но с ограничениями на работу с функциями и undefined."
      },
      {
        "id": 136,
        "question": "Напишите deep clone для объекта.",
        "answer": "Для глубокого клонирования объекта можно использовать рекурсивную функцию или библиотеку lodash:\nfunction deepClone(obj) {\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n  const copy = Array.isArray(obj) ? [] : {};\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      copy[key] = deepClone(obj[key]);\n    }\n  }\n  return copy;\n}\nconst clonedObj = deepClone(originalObj);"
      },
      {
        "id": 137,
        "question": "Назовите различные способы, как поменять местами значения двух переменных.",
        "answer": "Для замены значений двух переменных можно использовать несколько способов:\n1. С использованием временной переменной: let temp = a; a = b; b = temp;\n2. С использованием деструктуризации: [a, b] = [b, a];\n3. С использованием арифметических операций: a = a + b; b = a - b; a = a - b; (только для чисел)"
      },
      {
        "id": 138,
        "question": "Менеджер попросил в задаче поменять статусы из «active, inactive» на «active, removed», но в коде фигурируют только цифры и непонятно, какой статус соответствует какой цифре. Как помочь будущим программистам не лезть в документацию по коду? Вопрос ставят на конкретном примере с кодом.",
        "answer": "Чтобы упростить понимание статусов, можно использовать объект для хранения значений статусов и пояснительные комментарии:\nconst Status = {\n  ACTIVE: 1,\n  INACTIVE: 0, // Это статус будет удален\n  REMOVED: 2\n};\n// Пример использования\nlet userStatus = Status.ACTIVE;"
      },
      {
        "id": 139,
        "question": "Необходимо сделать мини проект - список пользователей с формой создания / редактирования пользователя:\nДля хранения пользователей используйте Firebase (это бесплатно).\nДля стилизации используйте Bootstrap.\nМинимальный набор полей пользователя:\nимя;\nфамилия;\nэлектронная почта;\nтелефон (в формате +380 (XX) XXX-XX-XX)\nдата рождения;\nбудет плюсом - добавление аватара и возможность crop-картинки.\nПользователи должны иметь возможность фильтрации и пагинацию.\nПроект должен содержать README-файл с шагами для запуска.",
        "answer": "Для реализации этого проекта можно использовать следующие шаги:\n1. Настройка проекта с использованием create-react-app.\n2. Подключение Firebase и настройка аутентификации и базы данных.\n3. Создание форм с использованием React Hook Form и стилизация с помощью Bootstrap.\n4. Реализация загрузки аватара с использованием Firebase Storage и библиотеки для обрезки изображений, такой как react-avatar-editor.\n5. Добавление функциональности фильтрации и пагинации с использованием React и библиотеки react-paginate.\n6. Написание README-файла с описанием шагов для установки и запуска проекта."
      }
    ]
  },
  {
    "position": "middle",
    "topic": "Общие",
    "questions": [
      {
        "id": 1,
        "question": "Расскажите о пирамиде тестирования.",
        "answer": "Пирамида тестирования - это концепция, описывающая различные уровни тестов и их относительное количество. В основе пирамиды находятся unit-тесты, которых должно быть больше всего. На следующем уровне расположены интеграционные тесты, а на вершине пирамиды - end-to-end (E2E) тесты, которых должно быть наименьшее количество."
      },
      {
        "id": 2,
        "question": "Какие типы автоматизированных тестов выпадала возможность писать? Какие библиотеки при этом использовали? Каким инструментам отдаете предпочтение и почему?",
        "answer": "Приходилось писать различные типы тестов: unit-тесты, интеграционные тесты и end-to-end тесты. Для unit-тестов использовал Jest, для интеграционных - Testing Library, а для E2E - Cypress. Предпочитаю Jest и Cypress за их простоту в использовании и мощные возможности для тестирования."
      },
      {
        "id": 3,
        "question": "Что такое unit-тесты? Какое место в пирамиде тестирования занимают unit-тесты?",
        "answer": "Unit-тесты - это тесты, которые проверяют отдельные модули или функции в изоляции от остальной системы. Они занимают основание пирамиды тестирования, так как их должно быть больше всего из-за их скорости и простоты написания."
      },
      {
        "id": 4,
        "question": "Что такое code coverage? Обязательно 100% покрытие тестами кода?",
        "answer": "Code coverage - это метрика, показывающая, какая часть кода покрыта тестами. Стремление к 100% покрытию не всегда оправдано, так как не весь код требует тестирования (например, тривиальные геттеры и сеттеры), и это может привести к написанию ненужных тестов."
      },
      {
        "id": 5,
        "question": "Как запретить браузеру отдавать кэш на HTTP-запрос?",
        "answer": "Для запрета кэширования можно использовать HTTP-заголовки Cache-Control и Pragma. Например, Cache-Control: no-cache, no-store и Pragma: no-cache."
      },
      {
        "id": 6,
        "question": "Что такое XSS (Cross-Site Scripting)?",
        "answer": "XSS (Cross-Site Scripting) - это уязвимость, позволяющая злоумышленнику внедрить вредоносный скрипт в веб-страницу, который затем исполняется в браузере пользователя. Это может привести к краже данных или выполнению нежелательных действий от имени пользователя."
      },
      {
        "id": 7,
        "question": "Расскажите о паттернах Observer, Pub / Sub. Какая между ними разница? Приведите примеры реализации этих паттернов в известных фреймворках / библиотеках / браузерных API.",
        "answer": "Паттерн Observer позволяет объектам подписываться на изменения другого объекта и быть уведомленными о них. Pub/Sub (Publisher/Subscriber) - это паттерн, в котором отправители (publishers) отправляют сообщения, а получатели (subscribers) подписываются на их получение. Разница в том, что в Observer подписчики знают об издателе, а в Pub/Sub они не зависят друг от друга. Примеры: в React - паттерн Observer, а в Node.js - EventEmitter (реализация Pub/Sub)."
      },
      {
        "id": 8,
        "question": "С какой целью может быть использован event listener события fetch self.addEventListener('fetch', event => {})?",
        "answer": "Этот event listener используется в Service Worker для перехвата сетевых запросов и управления ими. Это позволяет кэшировать запросы, предоставлять оффлайн-доступ или изменять ответы на запросы."
      },
      {
        "id": 9,
        "question": "Что такое Event loop и как он работает? Расскажите о микрозадачах и макрозадачах.",
        "answer": "Event loop - это механизм, который управляет выполнением асинхронного кода в JavaScript. Он проверяет очередь задач (tasks), выполняет их и затем обрабатывает микрозадачи (microtasks), такие как промисы. Макрозадачи (macrotasks) включают setTimeout, setInterval и I/O операции. Event loop сначала выполняет одну макрозадачу, затем все микрозадачи, и только потом переходит к следующей макрозадаче."
      }
    ]
  },
  {
    "position": "middle",
    "topic": "JS Core",
    "questions": [
      {
        "id": 10,
        "question": "Какие типы данных бывают в JavaScript? Какой будет результат выполнения кода?\n\nlet firstObj = { name: 'Hello' };\n\nlet secondObj = firstObj;\n\nfirstObj = { name: 'Bye' };\n\nconsole.log(secondObj.name);",
        "answer": "В JavaScript существуют следующие типы данных: примитивные (undefined, null, boolean, number, string, symbol, bigint) и объекты (Object, Array, Function, Date и т.д.). Результат выполнения кода будет 'Hello', потому что `secondObj` всё ещё ссылается на исходный объект, даже после того, как `firstObj` присвоен новый объект."
      },
      {
        "id": 11,
        "question": "Что такое temporal dead zone?",
        "answer": "Temporal Dead Zone (TDZ) - это период времени, в течение которого переменная существует, но не инициализирована. Переменные, объявленные с помощью `let` или `const`, находятся в TDZ с момента входа в блок до строки, где они инициализируются."
      },
      {
        "id": 12,
        "question": "Как работает boxing / unboxing в JavaScript?",
        "answer": "Boxing - это процесс преобразования примитивных типов данных (например, number, boolean) в объектные оболочки (Number, Boolean). Unboxing - это обратный процесс преобразования объектных оболочек обратно в примитивные типы. Это происходит автоматически при необходимости."
      },
      {
        "id": 13,
        "question": "В чем разница между оператором in и методом hasOwnProperty?",
        "answer": "Оператор `in` проверяет наличие свойства в объекте и его прототипной цепочке, тогда как метод `hasOwnProperty` проверяет только наличие собственного свойства объекта."
      },
      {
        "id": 14,
        "question": "Опишите, с помощью чего в JS реализуются такие ООП-парадигмы, как инкапсуляция, полиморфизм, абстракция?",
        "answer": "Инкапсуляция реализуется с помощью замыканий и классов (private свойства). Полиморфизм достигается с помощью наследования и интерфейсов (duck typing). Абстракция достигается путем создания абстрактных классов и интерфейсов."
      },
      {
        "id": 15,
        "question": "Что такое прототип? Как работает прототипное наследование в JS? Объясните работу кода.\n\nfunction Main () {}\n\nMain.prototype = { protected: true };\n\nconst obj = new Main();\n\nMain.prototype = { protected: false };\n\nconsole.log('Object protection: ', obj.protected);",
        "answer": "Прототип - это объект, от которого другие объекты наследуют свойства и методы. В JS объекты наследуют от прототипов через прототипную цепочку. В приведенном коде `obj` наследует свойство `protected` от исходного прототипа `Main`, поэтому результат будет `true`."
      },
      {
        "id": 16,
        "question": "Какая разница между композицией и наследованием?",
        "answer": "Наследование подразумевает, что один класс наследует свойства и методы другого класса. Композиция подразумевает, что один класс содержит экземпляры других классов и делегирует им выполнение задач. Композиция более гибка и предпочтительнее в большинстве случаев."
      },
      {
        "id": 17,
        "question": "Почему не стоит использовать конструкторы типа new String?",
        "answer": "Использование конструкторов типа `new String` создает объектную обертку вокруг строкового значения, что может привести к непредсказуемому поведению и потере производительности. Лучше использовать примитивные строки."
      },
      {
        "id": 18,
        "question": "Расскажите о базовом устройстве и механизме работы Event loop.",
        "answer": "Event loop - это механизм, который позволяет JavaScript выполнять асинхронный код, не блокируя основной поток. Он проверяет очередь задач (tasks), выполняет одну задачу, затем все микрозадачи (microtasks), прежде чем вернуться к следующей задаче."
      },
      {
        "id": 19,
        "question": "Что такое записи (records) и кортежи (tuples)? Чем они отличаются от обычных объектов?",
        "answer": "Записи (records) и кортежи (tuples) - это неизменяемые структуры данных, введенные в ECMAScript. Записи похожи на объекты, но неизменяемы. Кортежи похожи на массивы, но также неизменяемы. Они обеспечивают лучшую производительность и надежность данных."
      },
      {
        "id": 20,
        "question": "Какие различия в поведении ES5 функции-конструктора и ES2015 класса?",
        "answer": "ES5 функции-конструкторы требуют использования прототипов для добавления методов, в то время как ES2015 классы позволяют объявлять методы внутри тела класса. Классы также поддерживают наследование с помощью ключевого слова `extends` и имеют более выразительный синтаксис."
      },
      {
        "id": 21,
        "question": "Как реализовать паттерн «Модуль»?",
        "answer": "Паттерн «Модуль» реализуется с использованием замыканий для создания приватных переменных и методов. Пример:\n\n```javascript\nconst Module = (function() {\n  let privateVar = 'I am private';\n  function privateMethod() {\n    console.log(privateVar);\n  }\n  return {\n    publicMethod: function() {\n      privateMethod();\n    }\n  };\n})();\nModule.publicMethod(); // 'I am private'\n```"
      },
      {
        "id": 22,
        "question": "Почему typeof null возвращает object?",
        "answer": "Это ошибка в языке JavaScript, которая существует с самого начала. null был задуман как отдельный тип данных, но `typeof null` возвращает 'object' из-за ошибки в реализации."
      },
      {
        "id": 23,
        "question": "Что такое приведение (преобразование) типов в JS?",
        "answer": "Приведение типов - это процесс преобразования значения из одного типа в другой. Оно может быть явным (когда разработчик явно указывает преобразование) и неявным (когда преобразование происходит автоматически)."
      },
      {
        "id": 24,
        "question": "Что такое явное и неявное приведение (преобразование) типов данных в JS? Как происходит преобразование типов в следующих примерах:\n\n{}+[]+{}+[1]\n\n!!\"false\" == !!\"true\"\n\n['x'] == 'x'",
        "answer": "Явное приведение типов - это когда разработчик явно указывает преобразование, например `Number('123')`. Неявное - когда преобразование происходит автоматически, например `1 + '2'` будет `12`.\n\n1. `{}+[]+{}+[1]` => \"[object Object][object Object]1\"\n2. `!!\"false\" == !!\"true\"` => `true` (обе строки истинные)\n3. `['x'] == 'x'` => `true` (массив приводится к строке)"
      },
      {
        "id": 25,
        "question": "Что такое Garbage Collector?",
        "answer": "Garbage Collector (GC) - это механизм управления памятью, который автоматически освобождает память, занятую объектами, которые больше не используются или недоступны."
      },
      {
        "id": 26,
        "question": "Опишите основные принципы работы «сборщика мусора» в JS-движках (engines).",
        "answer": "Основные принципы работы GC включают сборку мусора на основе подсчета ссылок и маркировку-сжатие. При подсчете ссылок GC освобождает объекты, на которые больше нет ссылок. Маркировка-сжатие включает в себя маркировку объектов, которые можно достичь из корневых объектов, и освобождение памяти для остальных объектов."
      },
      {
        "id": 27,
        "question": "Опишите назначение и принципы работы с коллекциями WeakMap и WeakSet? Чем они отличаются от коллекций Map и Set соответственно?",
        "answer": "WeakMap и WeakSet позволяют создавать коллекции, где ключи объектов могут быть сборными мусором, если на них больше нет других ссылок. Это полезно для хранения метаданных или кэшей, не влияя на процесс сборки мусора. Map и Set, наоборот, предотвращают сборку мусора для своих ключей и значений."
      },
      {
        "id": 28,
        "question": "Чем отличается Observable от Promise?",
        "answer": "Observable может передавать несколько значений с течением времени и предоставляет возможность отмены, тогда как Promise работает с одним значением и не может быть отменен. Observable позволяет работать с потоками данных, а Promise - с однократными асинхронными результатами."
      },
      {
        "id": 29,
        "question": "Что такое Promise? Назовите порядок выполнения then и catch в цепочке.\n\nPromise.resolve(10)\n\n  .then(e => console.log(e)) // ??\n\n  .then(e => Promise.resolve(e))\n\n  .then(console.log) // ??\n\n  .then(e => {\n\n    if (!e) {\n\n      throw 'Error caught';\n\n    }\n\n  })\n\n  .catch(e => {\n\n    console.log(e); // ??\n\n    return new Error('New error');\n\n  })\n\n  .then(e => {\n\n    console.log(e.message); // ??\n\n  })\n\n  .catch(e => {\n\n    console.log(e.message); // ??\n\n  });",
        "answer": "Promise - это объект, представляющий результат асинхронной операции, которая может быть выполнена, отвергнута или находиться в состоянии ожидания.\n\nПорядок выполнения then и catch в цепочке:\n\n1. Первое then: Выведет `10`.\n2. Второе then: Вернет предыдущий результат, не выводя ничего.\n3. Третье then: Выведет `undefined`, так как предыдущий then не возвращал значения.\n4. catch: Не выполнится, так как ошибки не было.\n5. Четвертое then: Ошибок нет, ничего не произойдет.\n6. Пятый then: Ошибка не была поймана, ничего не произойдет."
      },
      {
        "id": 30,
        "question": "Расскажите о последовательном и параллельном выполнении асинхронных функций. В чем разница между Promise.all() и Promise.allSettled()?",
        "answer": "При последовательном выполнении асинхронных функций каждая функция выполняется одна за другой, ожидая завершения предыдущей. Параллельное выполнение позволяет запускать несколько асинхронных функций одновременно.\n\n`Promise.all()` ожидает завершения всех переданных промисов и возвращает массив их результатов. Если хотя бы один промис отклонен, `Promise.all()` отклоняется.\n\n`Promise.allSettled()` возвращает массив результатов для всех промисов, независимо от их выполнения или отклонения, включая информацию о статусе каждого промиса."
      },
      {
        "id": 31,
        "question": "Что такое дескрипторы свойств объектов? Расскажите об их практическом применение.",
        "answer": "Дескрипторы свойств объектов позволяют управлять поведением свойств объектов. Они включают атрибуты `value`, `writable`, `enumerable` и `configurable`. Практическое применение включает в себя создание неизменяемых свойств или контроль их видимости."
      },
      {
        "id": 32,
        "question": "Назовите несколько способов создания постоянного (неизменного) объекта в JavaScript.",
        "answer": "1. Использование `Object.freeze()` для предотвращения изменения объекта.\n2. Использование `Object.defineProperty()` для создания свойств с `writable: false` и `configurable: false`.\n3. Использование `const` для объявления объекта, чтобы переменная не могла быть переназначена."
      },
      {
        "id": 33,
        "question": "Как создать свойство у объекта, которое нельзя будет изменить?",
        "answer": "Использовать `Object.defineProperty()` для создания свойства с `writable: false` и `configurable: false`:\n\n```javascript\nObject.defineProperty(obj, 'prop', {\n  value: 'constant',\n  writable: false,\n  configurable: false\n});\n```"
      },
      {
        "id": 34,
        "question": "Зачем нужен конструктор Proxy? Приведите пример использования.",
        "answer": "Proxy позволяет создавать объекты, которые перехватывают и настраивают основные операции (например, чтение/запись свойств, вызов функций). Пример использования: логирование доступа к свойствам объекта:\n\n```javascript\nconst handler = {\n  get: function(target, prop) {\n    console.log(`Getting ${prop}`);\n    return target[prop];\n  }\n};\nconst proxy = new Proxy(target, handler);\nproxy.name; // Лог: Getting name\n```"
      },
      {
        "id": 35,
        "question": "Что такое ArrayBuffer? В чем разница между Uint32Array и Float32Array? Каков результат выполнения кода?\n\nconst uint32Array = new Uint32Array();\n\nArray.isArray(uint32Array);",
        "answer": "ArrayBuffer - это объект, представляющий фиксированный размер блока необработанных бинарных данных. `Uint32Array` - это массив целых чисел без знака 32-битной длины, а `Float32Array` - массив чисел с плавающей запятой 32-битной длины. Результат выполнения кода будет `false`, так как `Uint32Array` не является массивом."
      },
      {
        "id": 36,
        "question": "Каким будет результат сравнения?\n\nconst url = “HTTPs://xyz.com/path<to>page.html”;\n\nencodeURI(url) == encodeURIComponent(url);",
        "answer": "Результат сравнения будет `false`, так как `encodeURI` кодирует только специальные символы, необходимые для URI, а `encodeURIComponent` кодирует все символы, кроме буквенно-цифровых, -_.!~*'()."
      },
      {
        "id": 37,
        "question": "Расскажите о генераторах и итераторах.",
        "answer": "Генераторы - это функции, которые могут приостанавливать и возобновлять своё выполнение. Итераторы - это объекты, которые предоставляют метод `next()`, возвращающий следующий элемент последовательности. Генераторы возвращают итераторы, что позволяет использовать их в циклах `for...of` и других итерационных контекстах."
      },
      {
        "id": 38,
        "question": "Объясните, что делает приведенный ниже код:\n\nfunction * fn(num) {\n\n  for (let i = 0; i < num; i += 1) {\n\n    yield console.log(i);\n\n  }\n}\n\nconst loop = fn(5);\n\nloop.next();\n\nloop.next();",
        "answer": "Этот код определяет генераторную функцию `fn`, которая выводит значения от 0 до `num` и приостанавливается после каждого вывода. Вызовы `loop.next()` возобновляют выполнение генератора. В данном случае, первый вызов выведет `0`, второй - `1`."
      },
      {
        "id": 39,
        "question": "Расскажите о типе данных Symbol и его практическом применении. Как перевести число с 10-разрядной системы в 16 (2,8) разрядную систему счисления?",
        "answer": "Symbol - это уникальный и неизменяемый тип данных, используемый для создания уникальных идентификаторов для свойств объектов. Практическое применение - создание скрытых свойств объектов, которые не конфликтуют с другими свойствами. Перевод числа в другую систему счисления осуществляется с помощью метода `toString(base)`, где `base` - основание системы счисления:\n\n```javascript\nlet num = 255;\nconsole.log(num.toString(16)); // 'ff'\nconsole.log(num.toString(2)); // '11111111'\n```"
      }
    ]
  },
  {
    "position": "middle",
    "topic": "Функции",
    "questions": [
      {
        "id": 40,
        "question": "Объясните, что означает currying. Приведите пример использования на практике.",
        "answer": "Currying - это техника преобразования функции с множеством аргументов в цепочку функций, каждая из которых принимает один аргумент и возвращает новую функцию. Пример использования на практике:\n\n```javascript\nfunction multiply(a) {\n  return function(b) {\n    return function(c) {\n      return a * b * c;\n    };\n  };\n}\nconst result = multiply(2)(3)(4); // 24\n```"
      },
      {
        "id": 41,
        "question": "Приведите пример функции с мемоизацией. Когда следует применять эту технику?",
        "answer": "Мемоизация - это техника оптимизации, при которой результаты вызовов функции сохраняются и возвращаются из кеша при повторных вызовах с теми же аргументами. Пример функции с мемоизацией:\n\n```javascript\nfunction memoize(fn) {\n  const cache = {};\n  return function(...args) {\n    const key = JSON.stringify(args);\n    if (!cache[key]) {\n      cache[key] = fn(...args);\n    }\n    return cache[key];\n  };\n}\nconst factorial = memoize(function(n) {\n  return n <= 1 ? 1 : n * factorial(n - 1);\n});\nconsole.log(factorial(5)); // 120\nconsole.log(factorial(5)); // 120 (из кеша)\n```\nМемоизацию следует применять для функций с дорогими вычислениями и когда одни и те же вычисления повторяются с одинаковыми входными данными."
      },
      {
        "id": 42,
        "question": "Что такое чейнинг функций? Напишите пример с использованием этого подхода.",
        "answer": "Чейнинг функций - это техника вызова нескольких методов объекта последовательно в одной строке. Пример с использованием чейнинга функций:\n\n```javascript\nclass Calculator {\n  constructor(value = 0) {\n    this.value = value;\n  }\n  add(number) {\n    this.value += number;\n    return this;\n  }\n  subtract(number) {\n    this.value -= number;\n    return this;\n  }\n  multiply(number) {\n    this.value *= number;\n    return this;\n  }\n  divide(number) {\n    this.value /= number;\n    return this;\n  }\n  getResult() {\n    return this.value;\n  }\n}\nconst result = new Calculator()\n  .add(10)\n  .subtract(5)\n  .multiply(2)\n  .divide(3)\n  .getResult(); // 3.333...\n```"
      },
      {
        "id": 43,
        "question": "В чем разница между function и arrow function? Каким будет результат выполнения кода?\n\nconst pluckDeep = key => obj => key.split('.').reduce((accum, key) => accum[key], obj)\nconst compose = (...fns) => res => fns.reduce((accum, next) => next(accum), res)\n\nconst unfold = (f, seed) => {\n\n  const go = (f, seed, acc) => {\n\n    const res = f(seed)\n\n    return res ? go(f, res[1], acc.concat([res[0]])) : acc\n\n  }\n\n  return go(f, seed, [])\n}",
        "answer": "Разница между `function` и `arrow function`:\n\n1. Синтаксис: `function` имеет более длинный синтаксис, а `arrow function` короче.\n2. `this`: Arrow функции не имеют собственного `this` и наследуют его из родительской области видимости, в то время как обычные функции имеют свой собственный `this`.\n3. `arguments`: Arrow функции не имеют объекта `arguments`, а обычные функции имеют.\n\nРезультат выполнения кода зависит от вызова функции. Рассмотрим следующий пример использования:\n\n```javascript\nconst pluckDeep = key => obj => key.split('.').reduce((accum, key) => accum[key], obj);\nconst compose = (...fns) => res => fns.reduce((accum, next) => next(accum), res);\n\nconst unfold = (f, seed) => {\n  const go = (f, seed, acc) => {\n    const res = f(seed);\n    return res ? go(f, res[1], acc.concat([res[0]])) : acc;\n  }\n  return go(f, seed, []);\n};\n\nconst getUserName = pluckDeep('user.name');\nconst result = compose(\n  getUserName,\n  name => name.toUpperCase()\n)({ user: { name: 'John' } });\nconsole.log(result); // 'JOHN'\n\nconst sequence = unfold(n => n > 0 ? [n, n - 1] : null, 5);\nconsole.log(sequence); // [5, 4, 3, 2, 1]\n```"
      }
    ]
  },
  {
    "position": "middle",
    "topic": "Front-end",
    "questions": [
      {
        "id": 44,
        "question": "В чем принципиальная разница между событиями mouseleave и mouseout?",
        "answer": "Основное отличие между событиями `mouseleave` и `mouseout` заключается в том, как они обрабатывают переход курсора мыши между элементами. \n\n- `mouseout` срабатывает, когда курсор мыши покидает элемент, но также срабатывает, когда курсор покидает один элемент и попадает на дочерний элемент. \n- `mouseleave` срабатывает только тогда, когда курсор мыши уходит с элемента в область вне него, игнорируя переходы на дочерние элементы.\n\nПример:\n```html\n<div id='parent'>\n  Parent\n  <div id='child'>Child</div>\n</div>\n<script>\n  document.getElementById('parent').addEventListener('mouseout', () => console.log('mouseout from parent'));\n  document.getElementById('parent').addEventListener('mouseleave', () => console.log('mouseleave from parent'));\n</script>\n```\nКогда курсор перемещается из родительского элемента в дочерний, `mouseout` сработает, но `mouseleave` не сработает."
      },
      {
        "id": 45,
        "question": "В каком порядке обрабатываются пользовательские события в DOM (click, mouseover и т.д.)? FIFO или LIFO?",
        "answer": "Пользовательские события в DOM обрабатываются в порядке FIFO (First In, First Out). Это означает, что события обрабатываются в том порядке, в котором они были добавлены в очередь событий. Таким образом, если одно событие зарегистрировано раньше другого, оно будет обработано первым."
      },
      {
        "id": 46,
        "question": "Что такое Event bubbling и Event capturing?",
        "answer": "Event bubbling и event capturing - это два механизма распространения событий в DOM.\n\n- **Event capturing (фаза перехвата):** Событие распространяется сверху вниз, начиная с корневого элемента (document) и идя к целевому элементу, на котором событие произошло.\n- **Event bubbling (фаза всплытия):** Событие распространяется снизу вверх, начиная с целевого элемента и поднимаясь к корневому элементу (document).\n\nПример кода, иллюстрирующий оба механизма:\n```html\n<div id='parent'>\n  Parent\n  <div id='child'>Child</div>\n</div>\n<script>\n  document.getElementById('parent').addEventListener('click', () => console.log('Parent capture'), true); // Capturing phase\n  document.getElementById('child').addEventListener('click', () => console.log('Child capture'), true); // Capturing phase\n  document.getElementById('parent').addEventListener('click', () => console.log('Parent bubble')); // Bubbling phase\n  document.getElementById('child').addEventListener('click', () => console.log('Child bubble')); // Bubbling phase\n</script>\n```\nПри клике на элемент Child вывод будет:\n1. Parent capture\n2. Child capture\n3. Child bubble\n4. Parent bubble"
      },
      {
        "id": 47,
        "question": "Сравните методы объекта event stopPropagation и stopImmediatePropagation.",
        "answer": "- `event.stopPropagation()`: Прекращает дальнейшее распространение текущего события в фазе всплытия или перехвата. Событие больше не будет передаваться родительским элементам, но другие обработчики текущего элемента продолжат выполняться.\n- `event.stopImmediatePropagation()`: Прекращает распространение события и немедленно прекращает выполнение других обработчиков текущего элемента.\n\nПример:\n```html\n<button id='btn'>Click me</button>\n<script>\n  document.getElementById('btn').addEventListener('click', () => console.log('First handler'));\n  document.getElementById('btn').addEventListener('click', (e) => {\n    e.stopImmediatePropagation();\n    console.log('Second handler');\n  });\n  document.getElementById('btn').addEventListener('click', () => console.log('Third handler'));\n</script>\n```\nПри клике на кнопку вывод будет:\n1. First handler\n2. Second handler\n\n`Third handler` не будет вызван из-за `stopImmediatePropagation` в обработчике `Second handler`."
      },
      {
        "id": 48,
        "question": "Какие есть подходы оптимизации производительности веб-страницы?",
        "answer": "Основные подходы оптимизации производительности веб-страницы включают:\n1. **Оптимизация изображений:** Использование современных форматов (WebP), сжатие, lazy loading.\n2. **Минификация и сжатие:** Минификация CSS, JavaScript, HTML и сжатие HTTP-ответов с помощью Gzip/Brotli.\n3. **Асинхронная загрузка ресурсов:** Использование атрибутов `async` и `defer` для скриптов.\n4. **Кеширование:** Использование HTTP-заголовков кеширования, Service Workers для кэширования на стороне клиента.\n5. **Оптимизация критического пути рендеринга:** Минимизация CSS и JS, влияющих на отрисовку, inline-критические стили.\n6. **Lazy loading:** Отложенная загрузка изображений, видео и тяжелых ресурсов.\n7. **Оптимизация запросов к серверу:** Объединение и минимизация HTTP-запросов, использование HTTP/2.\n8. **Оптимизация рендеринга:** Использование requestAnimationFrame для анимаций, минимизация reflows и repaints.\n9. **Использование CDN:** Распределение статического контента через Content Delivery Networks."
      },
      {
        "id": 49,
        "question": "Как реализован механизм same-origin policy в браузере? На какие браузерные API он распространяется?",
        "answer": "Same-origin policy - это механизм безопасности, который ограничивает взаимодействие веб-страниц и ресурсов, если они имеют разные источники (origin). Источник определяется комбинацией протокола, домена и порта.\n\nSame-origin policy применяется к следующим API:\n1. **XMLHttpRequest и Fetch:** Ограничение запросов на другие домены без CORS.\n2. **DOM:** Запрещает доступ к DOM элементам, созданным на другом источнике.\n3. **LocalStorage и SessionStorage:** Ограничен доступ к данным, сохраненным с другого источника.\n4. **Cookies:** Ограничение доступа к cookies других доменов.\n5. **Web Workers:** Ограничение взаимодействия между скриптами разных источников.\n\nПример использования CORS для обхода same-origin policy:\n```javascript\nfetch('https://api.example.com/data', {\n  method: 'GET',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  mode: 'cors'\n})\n.then(response => response.json())\n.then(data => console.log(data));\n```"
      },
      {
        "id": 50,
        "question": "Назовите способы хранения данных в браузере. Сравните их.",
        "answer": "Основные способы хранения данных в браузере:\n\n1. **Cookies:**\n   - Хранение небольших данных (до 4KB).\n   - Отправляются с каждым HTTP-запросом.\n   - Поддержка сроков действия, доступ по домену и пути.\n\n2. **LocalStorage:**\n   - Хранение данных без срока действия (доступны до явного удаления).\n   - Максимальный объем хранения ~5-10MB.\n   - Доступ только с того же источника.\n\n3. **SessionStorage:**\n   - Хранение данных на время сессии (удаляются при закрытии вкладки).\n   - Максимальный объем хранения ~5-10MB.\n   - Доступ только с того же источника.\n\n4. **IndexedDB:**\n   - Хранение больших объемов структурированных данных.\n   - Поддержка транзакций, запросов и индексов.\n   - Доступ только с того же источника.\n\n5. **Cache API:**\n   - Кэширование сетевых запросов для офлайн-доступа.\n   - Используется с Service Workers.\n   - Доступ только с того же источника.\n\nСравнение:\n- Cookies удобны для серверного взаимодействия, но ограничены по объему и передаются с каждым запросом, что может влиять на производительность.\n- LocalStorage и SessionStorage просты в использовании для хранения данных на клиенте, но имеют ограничения по объему.\n- IndexedDB подходит для сложных и объемных данных, поддерживает транзакции и запросы, но имеет более сложный API.\n- Cache API идеален для офлайн-приложений и кэширования сетевых запросов."
      },
      {
        "id": 51,
        "question": "Web worker`ы. Опишите особенности передачи данных между worker`ами и основным потоком, между разделенными worker`ами.",
        "answer": "Web Workers позволяют выполнять скрипты в фоновом потоке, отдельно от основного потока выполнения. Особенности передачи данных:\n\n1. **Между worker'ами и основным потоком:**\n   - Передача данных осуществляется через сообщения с использованием метода `postMessage` и обработчика события `message`.\n   - Пример:\n   ```javascript\n   // Основной поток\n   const worker = new Worker('worker.js');\n   worker.postMessage('Hello, worker');\n   worker.onmessage = function(event) {\n     console.log('Message from worker:', event.data);\n   };\n\n   // Worker (worker.js)\n   onmessage = function(event) {\n     console.log('Message from main thread:', event.data);\n     postMessage('Hello, main thread');\n   };\n   ```\n\n2. **Между разделенными worker'ами:**\n   - Использование `postMessage` для передачи данных между worker'ами.\n   - Пример:\n   ```javascript\n   // Worker A\n   const workerB = new Worker('workerB.js');\n   workerB.postMessage('Hello, worker B');\n   workerB.onmessage = function(event) {\n     console.log('Message from worker B:', event.data);\n   };\n\n   // Worker B (workerB.js)\n   onmessage = function(event) {\n     console.log('Message from worker A:', event.data);\n     postMessage('Hello, worker A');\n   };\n   ```"
      },
      {
        "id": 52,
        "question": "Что такое Transferable-объекты?",
        "answer": "Transferable-объекты - это объекты, которые можно передавать между основным потоком и worker'ами без копирования. Это позволяет значительно ускорить передачу данных. Основные типы Transferable-объектов:\n\n- **ArrayBuffer**\n- **MessagePort**\n- **ImageBitmap**\n\nПример передачи ArrayBuffer:\n```javascript\n// Основной поток\nconst worker = new Worker('worker.js');\nconst buffer = new ArrayBuffer(1024);\nworker.postMessage(buffer, [buffer]); // Передача buffer как Transferable\n\n// Worker (worker.js)\nonmessage = function(event) {\n  const buffer = event.data;\n  console.log(buffer.byteLength); // 1024\n};\n```\nПосле передачи буфера, оригинальный объект в основном потоке становится невалидным (его длина будет 0), что подтверждает передачу владения объектом."
      },
      {
        "id": 53,
        "question": "Расскажите о способах оптимизации выполнения ресурсоемких операций JS для улучшения производительности рендеринга контента на странице.",
        "answer": "Способы оптимизации выполнения ресурсоемких операций JS для улучшения производительности рендеринга:\n\n1. **Разделение задач на микрозадачи и макрозадачи:** Использование `setTimeout`, `setImmediate`, `requestAnimationFrame` для распределения больших задач на более мелкие.\n2. **Использование Web Workers:** Перенос тяжелых вычислений в фоновый поток.\n3. **Debouncing и Throttling:** Ограничение частоты выполнения функций, например, при обработке событий прокрутки или ввода.\n4. **Memoization:** Кеширование результатов функций для избегания повторных вычислений.\n5. **Оптимизация рендеринга:** Минимизация reflows и repaints, использование `requestAnimationFrame` для анимаций.\n6. **Lazy Loading:** Отложенная загрузка ресурсов, таких как изображения и скрипты.\n7. **Использование эффективных структур данных:** Например, использование Set и Map вместо массивов для частых операций поиска.\n8. **Асинхронные операции:** Использование промисов и async/await для асинхронных задач.\n9. **Оптимизация DOM-манипуляций:** Минимизация прямых манипуляций с DOM, использование DocumentFragment для групповых операций."
      },
      {
        "id": 54,
        "question": "Почему ResizeObserver вызывает события изменения размера до воспроизведения элемента, а не после?",
        "answer": "ResizeObserver вызывает события изменения размера до воспроизведения элемента, чтобы предотвратить возможные бесконечные циклы рендеринга. Если бы ResizeObserver вызывал события после изменения размера и рендеринга, это могло бы привести к ситуации, когда обработчик события снова изменяет размер элемента, что в свою очередь вызвало бы новое событие изменения размера, и так далее.\n\nТаким образом, вызов событий до рендеринга обеспечивает более предсказуемое и контролируемое поведение, позволяя разработчикам обрабатывать изменения размеров элементов и соответствующим образом адаптировать их перед следующим рендерингом."
      },
      {
        "id": 55,
        "question": "Расскажите, как вы понимаете Web Accessibility?",
        "answer": "Web Accessibility (веб-доступность) - это практика создания веб-сайтов и приложений, которые могут быть использованы всеми людьми, включая людей с ограниченными возможностями. Веб-доступность включает в себя:\n\n1. **Восприимчивость:** Обеспечение того, чтобы контент был воспринимаем всеми пользователями, включая использование альтернативного текста для изображений, субтитров для видео и семантической разметки.\n2. **Операбельность:** Обеспечение того, чтобы все функции были доступны с помощью клавиатуры, улучшение навигации и предотвращение всплывающих окон, блокирующих доступ к контенту.\n3. **Понятность:** Обеспечение ясности и предсказуемости интерфейсов, использование простого языка и предоставление инструкций и обратной связи.\n4. **Надежность:** Обеспечение совместимости контента с различными браузерами и вспомогательными технологиями.\n\nПример улучшения доступности:\n```html\n<label for='username'>Username:</label>\n<input type='text' id='username' aria-label='Username'>\n```\nИспользование атрибута `aria-label` помогает улучшить доступность для пользователей, использующих вспомогательные технологии."
      },
      {
        "id": 56,
        "question": "Опишите алгоритм создания функционала, который обеспечивает чтение содержимого .txt файла при перетаскивании его из файловой системы в окно браузера.",
        "answer": "Алгоритм создания функционала для чтения содержимого .txt файла при перетаскивании в окно браузера:\n\n1. **Добавить слушатели событий `dragover` и `drop` на элемент, куда будет происходить перетаскивание.**\n2. **Предотвратить действия по умолчанию в обработчике события `dragover`.**\n3. **В обработчике события `drop` извлечь файл из объекта события и прочитать его содержимое с помощью FileReader.**\n4. **Вывести содержимое файла на экран или обработать его по необходимости.**\n\nПример реализации:\n```html\n<div id='dropzone'>Перетащите файл сюда</div>\n<pre id='file-content'></pre>\n<script>\n  const dropzone = document.getElementById('dropzone');\n  const fileContent = document.getElementById('file-content');\n\n  dropzone.addEventListener('dragover', (event) => {\n    event.preventDefault();\n  });\n\n  dropzone.addEventListener('drop', (event) => {\n    event.preventDefault();\n    const file = event.dataTransfer.files[0];\n    if (file && file.type === 'text/plain') {\n      const reader = new FileReader();\n      reader.onload = (e) => {\n        fileContent.textContent = e.target.result;\n      };\n      reader.readAsText(file);\n    } else {\n      alert('Пожалуйста, перетащите текстовый файл.');\n    }\n  });\n</script>\n```"
      },
      {
        "id": 1000,
        "question": "Что такое Virtual DOM?",
        "answer": "Virtual DOM (виртуальное DOM) — это концепция, используемая в библиотеках пользовательского интерфейса для оптимизации производительности при обновлении DOM. Она заключается в том, что библиотека создает виртуальное представление DOM в памяти, которое синхронизируется с настоящим DOM только при необходимости. Это позволяет избежать лишних операций обновления и повысить скорость работы приложений."
      }
    ]
  },
  {
    "position": "middle",
    "topic": "Верстка",
    "questions": [
      {
        "id": 57,
        "question": "Объясните разницу между единицами измерения px, em, rem.",
        "answer": "Единицы измерения в CSS отличаются друг от друга способом расчета размеров элементов. \n\n- **px**: пиксели, фиксированная единица измерения, зависящая от разрешения экрана.\n- **em**: относительная единица, которая зависит от размера шрифта родительского элемента. \n- **rem**: также относительная единица, но зависит от размера шрифта корневого элемента (html)."
      },
      {
        "id": 58,
        "question": "Для чего нужны CSS-переменные? Приведите несколько примеров использования.",
        "answer": "CSS-переменные позволяют хранить и переиспользовать значения свойств CSS. Они улучшают поддержку кода и упрощают изменение дизайна. Примеры использования:\n\n1. Определение цветовой схемы:\n```css\n:root {\n  --main-color: #3498db;\n  --secondary-color: #2ecc71;\n}\n.element {\n  background-color: var(--main-color);\n}\n```\n2. Адаптация размеров шрифтов:\n```css\n:root {\n  --base-font-size: 16px;\n}\n.body {\n  font-size: var(--base-font-size);\n}\n```\n3. Использование в анимациях:\n```css\n.element {\n  transition: transform 0.3s ease-out;\n}\n.element:hover {\n  transform: scale(1.1);\n}\n```"
      },
      {
        "id": 59,
        "question": "Что произойдет при добавлении следующего селектора?\n\n* { Box-sizing: border-box; }",
        "answer": "Этот селектор задает значение `box-sizing: border-box;` для всех элементов на странице. Это изменение повлияет на модель расчета размеров элементов, где ширина и высота элемента теперь будут включать границу и отступы, а не только содержимое."
      },
      {
        "id": 60,
        "question": "Как адаптировать страницу для печати?",
        "answer": "Для адаптации страницы для печати можно использовать медиа-запросы и специфичные CSS-стили для печати:\n\n1. Использование медиа-запросов для определения стилей для печати:\n```css\n@media print {\n  body {\n    font-size: 12pt;\n  }\n  .no-print {\n    display: none;\n  }\n}\n```\n2. Управление видимостью элементов при печати:\n```html\n<button class=\"no-print\" onclick=\"window.print()\">Печать</button>\n```\n3. Определение основных параметров печати в CSS:\n```css\n@media print {\n  @page {\n    size: A4 landscape;\n    margin: 1cm;\n  }\n}\n```"
      },
      {
        "id": 61,
        "question": "Опишите особенности кастомизации стилей стандартных элементов форм.",
        "answer": "Кастомизация стандартных элементов форм включает изменение внешнего вида элементов формы без изменения их стандартного поведения. Основные методы кастомизации включают:\n\n1. Использование псевдоэлементов (`::before`, `::after`) для добавления декоративных элементов.\n2. Настройка фонового изображения и цвета фона для элементов формы.\n3. Изменение размеров, отступов и выравнивания с помощью CSS.\n4. Применение анимаций и переходов для улучшения взаимодействия с пользователем."
      },
      {
        "id": 62,
        "question": "Что такое progressive рендеринг? Какие подходы используются?",
        "answer": "Progressive рендеринг — это стратегия загрузки и отображения контента на странице таким образом, чтобы пользователь мог начать взаимодействие с сайтом до полной загрузки всех ресурсов. Подходы включают:\n\n1. Постепенная загрузка изображений (lazy-loading).\n2. Отложенная загрузка скриптов и стилей.\n3. Использование кэширования и CDN для быстрой доставки контента.\n4. Разделение контента на части и загрузка по мере прокрутки страницы (infinite scroll)."
      },
      {
        "id": 63,
        "question": "Назовите несколько способов реализации lazy-loading медиаресурсов на странице.",
        "answer": "Lazy-loading позволяет откладывать загрузку медиаресурсов (изображений, видео, аудио) до момента их фактического использования пользователем. Способы реализации включают:\n\n1. Использование атрибута `loading` в теге `<img>` (доступно с HTML5).\n2. JavaScript-библиотеки, такие как LazyLoad.js.\n3. Intersection Observer API для отслеживания видимости элементов на странице.\n4. Реализация собственной логики с помощью событий прокрутки и загрузки."
      },
      {
        "id": 64,
        "question": "Назовите популярные шаблонизаторы для фронтенд-разработки. Опишите особенности их использования.",
        "answer": "Популярные шаблонизаторы для фронтенд-разработки включают:\n\n1. **Handlebars**: простой и мощный шаблонизатор с поддержкой частичных шаблонов и вложенных данных.\n2. **Mustache**: минималистичный шаблонизатор, поддерживающий множество языков программирования.\n3. **Pug (бывший Jade)**: шаблонизатор с упрощенным синтаксисом, позволяющим писать HTML в виде отступов и без тегов.\n\nОсобенности использования включают компиляцию шаблонов на стороне сервера или в браузере, поддержку логики и переменных, а также повторное использование компонентов."
      },
      {
        "id": 65,
        "question": "Назовите популярные CSS-методологии и их различия.",
        "answer": "Популярные CSS-методологии включают:\n\n1. **BEM (Block Element Modifier)**: методология, ориентированная на создание независимых блоков и элементов с четкими модификациями.\n2. **SMACSS (Scalable and Modular Architecture for CSS)**: методология, предлагающая подход к организации CSS-кода на основе пяти основных категорий.\n3. **Atomic CSS**: подход, при котором классы представляют отдельные стили (атомы), которые затем комбинируются для создания нужного визуального эффекта.\n\nРазличия заключаются в подходах к организации классов, уровне абстракции и гибкости в изменении стилей."
      },
      {
        "id": 66,
        "question": "Как работает CSS Grid?",
        "answer": "CSS Grid — это мощный механизм для создания сеток в веб-дизайне. Он позволяет задавать структуру макета, используя строки и столбцы, что упрощает распределение элементов на странице без необходимости использовать дополнительные контейнеры или фиксированные размеры.\n\nОсновные концепции CSS Grid:\n\n1. **Grid Container**: элемент, у которого установлено свойство `display: grid;`.\n2. **Grid Items**: дочерние элементы контейнера, которые могут быть размещены в сетке.\n3. **Grid Lines**: линии, разделяющие сетку на строки и столбцы.\n4. **Grid Tracks**: области между соседними линиями, которые могут быть явно заданы или автоматически сгенерированы.\n5. **Grid Areas**: именованные области, которые упрощают организацию содержимого в макете.\n\nПример использования:\n```css\n.grid-container {\n  display: grid;\n  grid-template-columns: 1fr 2fr;\n  grid-template-rows: auto;\n}\n.grid-item {\n  grid-column: 1 / 3;\n}\n```"
      },
      {
        "id": 67,
        "question": "Какие форматы изображений поддерживают анимацию?",
        "answer": "Форматы изображений, поддерживающие анимацию, включают:\n\n1. **GIF**: старый, но все еще широко используемый формат для анимированных изображений.\n2. **APNG (Animated Portable Network Graphics)**: формат PNG с поддержкой анимации, но его поддержка неоднозначна.\n3. **WebP**: современный формат, предложенный Google, поддерживает анимацию и обеспечивает лучшее сжатие по сравнению с GIF.\n4. **SVG (Scalable Vector Graphics)**: векторный формат, который поддерживает анимацию, основанную на SMIL (Synchronized Multimedia Integration Language).\n\nКаждый из этих форматов имеет свои особенности и подходит для различных сценариев использования."
      },
      {
        "id": 68,
        "question": "Как отследить прогресс / окончание CSS @keyframes анимаций или плавных переходов, реализованных с помощью transition, в JS?",
        "answer": "Для отслеживания прогресса и окончания CSS анимаций или плавных переходов можно использовать следующие методы:\n\n1. **События анимации**: `animationstart`, `animationend`, `animationiteration` для @keyframes анимаций.\n2. **События перехода**: `transitionstart` и `transitionend` для CSS переходов.\n\nПример использования событий анимации:\n```javascript\nconst element = document.getElementById('animated-element');\nelement.addEventListener('animationend', () => {\n  console.log('Анимация завершена');\n});\n```"
      },
      {
        "id": 69,
        "question": "Какие CSS-свойства могут быть обработаны непосредственно через GPU? Что такое композитные слои и почему большое их количество может привести к аварийному завершению работы браузера на мобильных устройствах?",
        "answer": "Некоторые CSS-свойства, которые могут быть обработаны через GPU, включают:\n\n1. `transform`: перемещение, масштабирование, вращение элементов.\n2. `opacity`: изменение прозрачности элементов.\n3. `filter`: применение фильтров (например, blur, grayscale).\n4. `backdrop-filter`: применение фильтров к заднему фону элемента.\n\nКомпозитные слои — это специальные слои, создаваемые браузером для обработки таких свойств на GPU. Их большое количество может привести к аварийному завершению работы браузера на мобильных устройствах из-за ограниченных ресурсов GPU и оперативной памяти."
      },
      {
        "id": 70,
        "question": "Как переиспользовать Инлайн SVG-элементы на странице?",
        "answer": "Для переиспользования инлайн SVG-элементов на странице можно использовать фрагменты SVG и элемент `<use>`:\n\n1. **Фрагменты SVG**: создание SVG-файлов с различными символами или иконками и их использование в качестве фрагментов в других SVG-файлах.\n2. **Элемент `<use>`**: ссылка на определенные элементы или символы из другого SVG-файла для их многократного использования.\n\nПример использования элемента `<use>`:\n```html\n<svg>\n  <use xlink:href=\"symbol.svg#icon\"></use>\n</svg>\n```"
      },
      {
        "id": 71,
        "question": "Опишите способы оптимизации SVG-файлов.",
        "answer": "Оптимизация SVG-файлов включает различные методы с целью уменьшения размера и повышения производительности загрузки:\n\n1. **Удаление ненужной информации**: удаление комментариев, метаданных, лишних атрибутов.\n2. **Сжатие путей**: использование инструментов для упрощения и сжатия сложных путей в SVG.\n3. **Преобразование в символы или датчики**: создание множественных элементов и ссылок на них через `<symbol>` и `<use>` для многократного использования.\n4. **Использование viewBox**: определение viewBox для оптимального масштабирования и отображения SVG-изображений на разных экранах."
      },
      {
        "id": 72,
        "question": "Как реализовать иконочный шрифт из определенного набора SVG-файлов?",
        "answer": "Для создания иконочного шрифта из набора SVG-файлов можно использовать следующие шаги:\n\n1. **Конвертация в SVG-шрифт**: использование специальных инструментов или онлайн-сервисов для объединения SVG-файлов в один шрифт.\n2. **Определение символов**: назначение символьных кодов каждому SVG-изображению в шрифте.\n3. **Использование CSS**: использование CSS для добавления иконочного шрифта к элементам страницы с помощью `@font-face` и `font-family`.\n\nПример использования иконочного шрифта:\n```css\n@font-face {\n  font-family: 'my-icon-font';\n  src: url('icons.woff2') format('woff2');\n}\n.icon {\n  font-family: 'my-icon-font';\n  /* указание символьного кода или псевдоэлемента для иконки */\n}\n```"
      },
      {
        "id": 73,
        "question": "Что такое ложное жирное или ложное курсивное (Faux) начертание шрифтов?",
        "answer": "Ложное жирное или ложное курсивное начертание шрифтов (Faux bold или Faux italic) — это эффект, при котором браузер пытается симулировать жирное или курсивное начертание для шрифта, если такие начертания не предусмотрены непосредственно шрифтом. Браузеры могут применять эти эффекты, если CSS-правила, такие как `font-weight` или `font-style`, устанавливаются на недоступные начертания шрифта."
      },
      {
        "id": 74,
        "question": "Что такое #shadow-root в инспекторе HTML-страницы?",
        "answer": "#shadow-root — это специальный элемент в инспекторе браузера, который представляет собой внутреннюю структуру Shadow DOM элемента. Shadow DOM позволяет создавать изолированные компоненты с собственной структурой и стилями, которые не влияют на внешний DOM страницы."
      },
      {
        "id": 75,
        "question": "Зачем нужны Custom Elements?",
        "answer": "Custom Elements — это механизм веб-компонентов, позволяющий создавать пользовательские HTML-элементы с пользовательской логикой и стилями. Они улучшают модульность и переиспользование кода, а также позволяют создавать собственные компоненты, которые могут быть повторно использованы в различных частях приложения."
      },
      {
        "id": 76,
        "question": "Почему удаление лишних символов пробелов / символов переноса в HTML не отражается на конечной производительности загрузки страницы?",
        "answer": "Удаление лишних символов пробелов и символов переноса (whitespace) в HTML не оказывает существенного влияния на производительность загрузки страницы, потому что браузеры игнорируют их при обработке HTML. Это означает, что удаление или добавление этих символов в HTML-код не изменит объем передаваемых данных или скорость обработки страницы браузером."
      },
      {
        "id": 77,
        "question": "Что такое контекст отображения canvas? Какие существуют типы контекста для рендеринга двумерной и трехмерной графики?",
        "answer": "Контекст отображения canvas (CanvasRenderingContext2D и WebGLRenderingContext) представляет собой интерфейс для рисования двумерной и трехмерной графики в элементе `<canvas>` в HTML5.\n\nТипы контекста:\n\n1. **CanvasRenderingContext2D**: контекст для рендеринга двумерной графики, поддерживающий рисование путей, текста, изображений и других элементов.\n2. **WebGLRenderingContext**: контекст для рендеринга трехмерной графики с использованием WebGL (Web Graphics Library), позволяющий создавать сложные 3D-сцены и эффекты, используя аппаратное ускорение."
      }
    ]
  },
  {
    "position": "middle",
    "topic": "Angular",
    "questions": [
      {
        "id": 78,
        "question": "Как работает Dependency injection? Зачем это нужно? Расскажите об использовании кастомных инжекторов.",
        "answer": "Dependency injection (DI) — это паттерн проектирования, который используется для доставки зависимостей в объекты или функции вместо того, чтобы объекты создавали свои зависимости напрямую. Это улучшает модульность, управляемость и тестируемость кода, делая его более гибким. DI особенно полезен в крупных приложениях, где управление зависимостями может быть сложной задачей. Кастомные инжекторы позволяют настроить, какие зависимости и как они должны быть предоставлены компонентам приложения, что дает большую гибкость в управлении зависимостями."
      },
      {
        "id": 79,
        "question": "Что такое zone.js? Для чего Angular использует зоны? С какой целью можно использовать NgZone-сервис?",
        "answer": "zone.js — это библиотека, используемая Angular для управления зонами выполнения в JavaScript. Зоны позволяют отслеживать и перехватывать асинхронные операции, такие как обработка событий, выполнение таймеров и HTTP-запросов. Angular использует зоны для обнаружения изменений (change detection), что позволяет автоматически обновлять представление приложения при изменениях в его состоянии. NgZone-сервис предоставляет доступ к текущей зоне и позволяет запускать или выполнять код в определенной зоне, что полезно для оптимизации производительности и управления асинхронными операциями."
      },
      {
        "id": 80,
        "question": "Как работает Change detection? Как можно оптимизировать компонент с помощью схем Change detection? Какие еще есть приемы для оптимизации рендеринга (связанные с Change detection)?",
        "answer": "Change detection — это процесс, при котором Angular определяет, какие компоненты, директивы и пайпы должны быть перерисованы на основе изменений данных и событий в приложении. Оптимизация компонентов с помощью стратегий Change detection (OnPush) позволяет уменьшить количество проверок на изменения, снизить нагрузку на процессор и улучшить производительность приложения. Другие приемы для оптимизации включают уменьшение количества обращений к DOM, использование lazy loading для модулей и оптимизацию алгоритмов обновления данных."
      },
      {
        "id": 81,
        "question": "Как выполнить конфигурацию HTTP-сервиса? Зачем она нужна? Обработка HTTP-ошибок?",
        "answer": "Конфигурация HTTP-сервиса в Angular позволяет настраивать параметры, такие как базовый URL, интерцепторы HTTP-запросов, таймауты и обработку ошибок. Это нужно для централизованного управления настройками HTTP-запросов в приложении. Обработка HTTP-ошибок включает в себя использование операторов catchError в сервисах для обработки ошибок, возвращаемых сервером, и генерации пользовательских сообщений об ошибках для пользователя приложения."
      },
      {
        "id": 82,
        "question": "Какие есть подходы к организации работы с данными?",
        "answer": "Организация работы с данными включает различные подходы, такие как использование сервисов для доступа к данным, использование глобального состояния для хранения общих данных между компонентами, применение паттерна хранилища данных (например, Redux или NgRx в Angular), и использование HTTP-запросов для получения данных с сервера. Выбор подхода зависит от требований приложения, его масштаба и архитектурных решений."
      },
      {
        "id": 83,
        "question": "Как подготовить сборник к деплою?",
        "answer": "Подготовка сборки для деплоя включает в себя минимизацию и оптимизацию JavaScript и CSS файлов, удаление неиспользуемого кода, настройку параметров сборки (например, установка базового URL для продакшн окружения), проверку наличия всех необходимых ресурсов и файлов конфигурации, тестирование сборки на локальном или staging сервере, и деплой на целевой сервер или хостинг."
      },
      {
        "id": 84,
        "question": "Что такое NgRx? Когда стоит использовать?",
        "answer": "NgRx — это библиотека для управления состоянием в Angular приложениях с использованием паттерна Redux. NgRx позволяет централизованно хранить и изменять состояние приложения, что упрощает управление данными и делает приложение предсказуемым. NgRx стоит использовать в крупных приложениях с сложным состоянием, когда требуется четкое управление данными, отслеживание изменений и масштабируемость."
      },
      {
        "id": 85,
        "question": "В каких случаях лучше использовать Renderer-сервис вместо нативных методов? И наоборот?",
        "answer": "Renderer-сервис в Angular используется для безопасного манипулирования DOM элементами в обход Angular's зоны выполнения и предотвращения проблем с производительностью при изменении DOM. Он также предоставляет интерфейс для выполнения манипуляций DOM, которые будут работать вне зоны Angular. Нативные методы манипуляции DOM применяются в случаях, когда не требуется обход зоны и когда нужна прямая манипуляция с DOM элементами без дополнительных оберток и абстракций."
      },
      {
        "id": 86,
        "question": "Как работают и для чего нужны резолверы? Как получить данные, загруженные резолверами?",
        "answer": "Резолверы в Angular предназначены для предварительной загрузки данных перед активацией маршрута. Они позволяют выполнить асинхронные операции (например, загрузку данных с сервера) до того, как компонент маршрута будет активирован. Для получения данных, загруженных резолверами, компонент маршрута может использовать ActivatedRouteSnapshot.data или ActivatedRoute.data для доступа к предварительно загруженным данным."
      },
      {
        "id": 87,
        "question": "Как работают и зачем нужны динамические компоненты? Приведите примеры их целесообразного использования.",
        "answer": "Динамические компоненты в Angular позволяют динамически создавать и управлять компонентами во время выполнения. Они полезны в случаях, когда структура компонентов или их поведение зависят от условий или данных, полученных во время выполнения приложения. Примеры использования включают модальные окна, динамические формы, условную загрузку компонентов на основе прав доступа или пользовательских действий."
      },
      {
        "id": 88,
        "question": "Какая разница между @ViewChild и @ContentChild?",
        "answer": "@ViewChild используется для доступа к первому экземпляру дочернего компонента, найденного в представлении текущего компонента. @ContentChild используется для доступа к первому экземпляру дочернего компонента или элемента, найденного в контенте (projected content) текущего компонента. Разница в том, что @ViewChild работает с дочерними компонентами в текущем представлении, в то время как @ContentChild работает с контентом, который был проекционно добавлен в текущий компонент."
      },
      {
        "id": 89,
        "question": "Что делает код и как иначе можно связать класс компонента с переменной? @HostBinding ( 'class.valid') isValid;",
        "answer": "Декоратор @HostBinding используется для привязки значения свойства хост-элемента (element) к свойству класса компонента. В данном случае, класс компонента будет иметь класс 'valid', если значение переменной isValid равно true. Альтернативный способ связи класса компонента с переменной может включать использование ngClass директивы или прямого управления классами элемента с помощью Renderer2 сервиса."
      },
      {
        "id": 90,
        "question": "Как можно кэшировать данные, используя сервисы или RxJS?",
        "answer": "Для кэширования данных в Angular приложении можно использовать сервисы для хранения данных в памяти или локальном хранилище браузера, таком как LocalStorage или SessionStorage. RxJS предоставляет возможности для кэширования данных с использованием операторов like shareReplay или publishReplay, которые позволяют повторно использовать последнее значение Observable."
      },
      {
        "id": 91,
        "question": "Что такое асинхронная валидация форм? Когда применяется и как реализуется?",
        "answer": "Асинхронная валидация форм в Angular позволяет выполнять валидацию данных асинхронно, например, проверять уникальность поля на сервере или загружать дополнительные данные для проверки. Она применяется там, где валидация требует обращения к внешним источникам данных, которые могут быть загружены асинхронно. Реализуется с помощью асинхронных валидаторов, возвращающих Observable или Promise с результатом валидации."
      },
      {
        "id": 92,
        "question": "Зачем нужна forRoot-функция модуля?",
        "answer": "Функция forRoot в модуле используется для регистрации провайдеров сервисов и настройки модуля с использованием глобальных настроек. Она вызывается только в корневом модуле приложения (обычно AppModule) и позволяет передать параметры или настройки для всех экземпляров сервисов, предоставляемых этим модулем. Это позволяет избежать дублирования сервисов и обеспечить единство настроек для всего приложения."
      },
      {
        "id": 93,
        "question": "Какая разница между декларированием и экспортом компонента из модуля?",
        "answer": "Декларирование компонента в NgModule делается с помощью декоратора @Component или @Directive и позволяет Angular узнать о наличии компонента в текущем модуле. Экспорт компонента позволяет использовать компонент в других модулях, импортируя текущий модуль, который содержит этот компонент. Декларация компонента в NgModule обязательна для его использования в текущем модуле, в то время как экспорт делает его доступным для использования в других модулях."
      },
      {
        "id": 94,
        "question": "Почему плохо «провайдить» сервис с shared-модуля в lazy-loaded модуль? (Вопрос о scope модулей.)",
        "answer": "При «провайдинге» сервиса с shared-модуля в lazy-loaded модуль каждый раз создается новый экземпляр сервиса, что приводит к изолированности состояния сервиса между разными модулями. Это может привести к непредсказуемому поведению и потере состояния при переходах между модулями. Рекомендуется провайдить сервисы в корневом модуле (AppModule) или использовать forRoot() функцию для корректного предоставления сервисов."
      },
      {
        "id": 95,
        "question": "Что такое :: ng-deep и для чего используется?",
        "answer": "::ng-deep — это директива Angular, используемая для применения стилей к элементам вложенных компонентов, игнорируя ограничения средств Angular для стилизации вложенных компонентов. Это позволяет переопределить стили вложенных компонентов из родительского компонента без необходимости использовать /deep/ или >>> (deprecated). Однако использование ::ng-deep может привести к проблемам с поддержкой в будущих версиях Angular и рекомендуется применять осторожно."
      },
      {
        "id": 96,
        "question": "Какие тесты можно запустить для Angular-программы? Какие инструменты используют для тестирования Angular-программы?",
        "answer": "Для тестирования Angular-программы можно запустить unit-тесты, интеграционные тесты и end-to-end (e2e) тесты. Unit-тесты проверяют отдельные компоненты или сервисы без зависимостей, интеграционные тесты проверяют взаимодействие между компонентами или модулями, а e2e тесты проверяют работу приложения от начала до конца, как пользователь. Для тестирования Angular-программ используют такие инструменты, как Karma, Jasmine, Protractor, TestBed и другие."
      },
      {
        "id": 97,
        "question": "Как протестировать API-сервис?",
        "answer": "Для тестирования API-сервисов в Angular можно использовать mock-сервисы или HttpClientTestingModule для создания тестового окружения, изолированного от реального API. Mock-сервисы предоставляют заглушки для HTTP-запросов и ответов, что позволяет эмулировать поведение реального API. Также можно использовать HttpClientTestingModule для тестирования взаимодействия с HTTP-запросами без фактического вызова реального API."
      }
    ]
  },
  {
    "position": "middle",
    "topic": "React",
    "questions": [
      {
        "id": 98,
        "question": "Что такое JSX? Что лежит в его основе?",
        "answer": "JSX (JavaScript XML) — это расширение синтаксиса JavaScript, которое позволяет писать HTML-подобные структуры в коде React. Основа JSX — это возможность JavaScript генерировать HTML структуры через специальный синтаксис, который затем компилируется в обычные JavaScript вызовы функций."
      },
      {
        "id": 99,
        "question": "Как работает алгоритм Virtual DOM?",
        "answer": "Алгоритм Virtual DOM в React работает следующим образом: при изменении данных React строит новое дерево Virtual DOM, сравнивает его с предыдущим (diffing), определяет минимальное количество мутаций для обновления реального DOM и применяет эти изменения с минимальными затратами."
      },
      {
        "id": 100,
        "question": "Для чего нужно свойство key во время рендеринга списков?",
        "answer": "Свойство key в React используется для оптимизации производительности при рендеринге списков. Оно помогает React идентифицировать, какие элементы были изменены, добавлены или удалены. Это позволяет React переиспользовать существующие элементы DOM, минимизируя количество манипуляций с DOM и повышая производительность."
      },
      {
        "id": 101,
        "question": "В чем разница между функциональными и классовыми компонентами?",
        "answer": "Функциональные компоненты в React представляют собой чистые функции, которые получают props и возвращают React элементы. Они обычно более просты в написании и понимании. Классовые компоненты используют классы ES6 и имеют состояние (state) и жизненные циклы. Однако с появлением хуков (hooks) функциональные компоненты получили возможность использовать состояние и другие возможности, ранее доступные только классовым компонентам."
      },
      {
        "id": 102,
        "question": "Зачем и когда нужно передавать props в super() при использовании классовых компонентов?",
        "answer": "super(props) вызывается в конструкторе класса при расширении компонента от React.Component для передачи props в конструктор родительского класса. Это необходимо, если в конструкторе компонента нужно использовать props до вызова super(), например, при доступе к props в конструкторе."
      },
      {
        "id": 103,
        "question": "Почему нужно использовать setState() для обновления внутреннего состояния компонента?",
        "answer": "setState() в React используется для обновления состояния компонента. Это позволяет React узнать о необходимости обновления UI. Прямое изменение this.state в React не гарантирует перерисовку компонента, поэтому следует использовать setState(), чтобы уведомить React об изменениях и запустить процесс обновления UI."
      },
      {
        "id": 104,
        "question": "В чем заключается принцип «подъема состояния»?",
        "answer": "Принцип подъема состояния (lifting state up) в React заключается в перемещении состояния из дочерних компонентов в родительский компонент, когда несколько компонентов нужно иметь доступ к одному и тому же состоянию. Это позволяет обеспечить согласованность данных между компонентами и упростить управление состоянием приложения."
      },
      {
        "id": 105,
        "question": "Какие библиотеки менеджмента состояния React-приложения вы знаете? Зачем они нужны?",
        "answer": "В React для управления состоянием приложения используются такие библиотеки, как Redux, MobX, Recoil и другие. Они позволяют централизованно хранить и управлять состоянием приложения, делая его более предсказуемым и управляемым, особенно в случае сложных приложений с большим количеством компонентов."
      },
      {
        "id": 106,
        "question": "Когда следует использовать Redux? Какие есть альтернативы?",
        "answer": "Redux следует использовать, когда в приложении есть сложное состояние, которое требует централизованного управления. Альтернативами Redux являются MobX, Context API (с использованием хуков useContext) и другие менее распространенные библиотеки."
      },
      {
        "id": 107,
        "question": "Redux vs Mobx?",
        "answer": "Redux и MobX — два популярных инструмента для управления состоянием в React. Redux использует однонаправленный поток данных и имеет более строгие правила и большую предсказуемость. MobX предлагает более гибкий подход, где обновления состояния происходят автоматически при изменении данных. Выбор между ними зависит от конкретных потребностей проекта и предпочтений команды."
      },
      {
        "id": 108,
        "question": "Расскажите о базовом принципе работы React Hooks.",
        "answer": "React Hooks — это функции, которые позволяют вам использовать состояние и другие возможности React без написания классов. Основной принцип работы заключается в использовании хуков, таких как useState, useEffect, useContext и других, для добавления состояния и поведения в функциональные компоненты."
      },
      {
        "id": 109,
        "question": "В чем разница между createRef и useRef?",
        "answer": "createRef используется в классовых компонентах для создания ссылки на DOM элемент, а useRef — в функциональных компонентах для создания мутабельной переменной, которая сохраняет свое значение между рендерами."
      },
      {
        "id": 110,
        "question": "Когда следует использовать React refs? Когда не стоит?",
        "answer": "React refs следует использовать, когда нужен доступ к DOM элементу или компоненту для управления фокусом, измерениями или другими манипуляциями, которые невозможно сделать через props. Не следует использовать refs для решения задач, которые можно решить с использованием состояния или props компонентов."
      },
      {
        "id": 111,
        "question": "Какие недостатки библиотеки React видите?",
        "answer": "Среди недостатков React можно выделить изучение и поддержку большого количества хуков и их правильное использование, необходимость внимательного управления состоянием и жизненными циклами компонентов, а также сложность интеграции с некоторыми библиотеками, особенно теми, которые не используют функциональный подход."
      },
      {
        "id": 112,
        "question": "Какие паттерны используете вместе с React?",
        "answer": "Среди популярных паттернов использования в React можно выделить Container/Presentational, Render Props, Higher-Order Components (HOC), Compound Components и другие. Они помогают улучшить структуру кода, делая его более модульным и поддерживаемым."
      },
      {
        "id": 113,
        "question": "Как относитесь к типизации вместе с React?",
        "answer": "Типизация вместе с React (например, с использованием TypeScript или Flow) может значительно улучшить структуру и надежность кода, особенно в больших проектах. Она помогает предотвратить ошибки на этапе разработки и улучшить автодокументирование кода."
      },
      {
        "id": 114,
        "question": "Как построить хорошую архитектуру React-проекта?",
        "answer": "Хорошая архитектура React-проекта включает разделение на компоненты с единой ответственностью, использование контейнерных компонентов для управления состоянием, применение паттернов проектирования (например, MVC, Flux), оптимизацию производительности, правильную организацию файловой структуры и строгий учет правил разметки."
      },
      {
        "id": 115,
        "question": "Оптимизация React-приложений? Как измерить производительность программы?",
        "answer": "Оптимизация React-приложений включает в себя использование мемоизации с помощью useMemo и useCallback, оптимизацию рендеринга с помощью React.memo, асинхронную загрузку данных, разделение на ленивые загрузки, использование ключей для списков и многое другое. Производительность можно измерить с помощью инструментов разработчика браузера (например, Chrome DevTools) и профилировщиков производительности."
      },
      {
        "id": 116,
        "question": "Можно ли приложение на React встроить в другое приложение на React?",
        "answer": "Да, приложение на React можно встроить в другое приложение на React. Это достигается путем рендеринга одного приложения React как части другого приложения, используя контейнерные компоненты или специальные интеграционные библиотеки."
      }
    ]
  },
  {
    "position": "middle",
    "topic": "Back-end",
    "questions": [
      {
        "id": 117,
        "question": "Почему Node.js однопоточный, а не многопоточный?",
        "answer": "Node.js использует однопоточную модель событийного цикла (event loop), которая позволяет эффективно обрабатывать множество одновременных соединений. Это достигается благодаря асинхронным операциям ввода-вывода (IO), которые не блокируют основной поток выполнения. Такой подход позволяет использовать меньше ресурсов на управление потоками и более эффективно использовать вычислительные ресурсы системы."
      },
      {
        "id": 118,
        "question": "Что такое event driven development?",
        "answer": "Event-driven development (разработка, ориентированная на события) - это подход к разработке программного обеспечения, где основное внимание уделяется обработке событий. Программа реагирует на различные события, такие как клики пользователя, приход данных по сети и другие, вместо того чтобы последовательно выполнять инструкции в программе. Это позволяет создавать реактивные и отзывчивые приложения, которые могут адаптироваться к изменяющемуся окружению и вводу от пользователя."
      },
      {
        "id": 119,
        "question": "Сравните fork() и spawn() методы.",
        "answer": "В Node.js fork() и spawn() - это два метода для создания новых процессов. Метод fork() создает новый процесс, который копирует текущее состояние приложения, включая обработчики событий и память. Это особенно полезно для создания многопроцессорных приложений или при использовании кластеризации. С другой стороны, spawn() создает новый процесс, запуская указанную программу в новом процессе. Это можно использовать для запуска внешних программ или скриптов, которые необходимы для работы приложения."
      },
      {
        "id": 120,
        "question": "Расскажите о Node.js фреймворках, которые использовали. Какая между ними разница?",
        "answer": "Я использовал несколько фреймворков для Node.js, таких как Express.js, Koa.js и Nest.js. Express.js - это минималистичный и гибкий фреймворк для создания веб-приложений и API. Koa.js основан на промисах и предоставляет более современный подход к middleware и обработке запросов. Nest.js - это фреймворк, который стремится предоставить структурированный и расширяемый способ для создания серверных приложений на Node.js, используя TypeScript и объектно-ориентированные принципы."
      },
      {
        "id": 121,
        "question": "Опишите словами код ендпоинта, который должен сохранить с клиента файл размером 4 гигабайта и положить его на S3 или другой CDN.",
        "answer": "Код ендпоинта может выглядеть следующим образом:\n\n```javascript\nconst express = require('express');\nconst multer = require('multer'); // для обработки файлов\nconst AWS = require('aws-sdk'); // для работы с S3\n\nconst app = express();\nconst upload = multer({ dest: 'uploads/' });\n\nconst s3 = new AWS.S3({ /* конфигурация AWS */ });\n\napp.post('/upload', upload.single('file'), async (req, res) => {\n  const file = req.file;\n  const params = {\n    Bucket: 'bucket-name',\n    Key: file.originalname,\n    Body: file.buffer,\n  };\n\n  try {\n    const data = await s3.upload(params).promise();\n    res.json({ success: true, location: data.Location });\n  } catch (err) {\n    console.error('Error uploading file to S3:', err);\n    res.status(500).json({ error: 'Failed to upload file to S3' });\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});\n```\n\nЭтот код использует Express.js для создания сервера, Multer для обработки файлов и AWS SDK для работы с S3. Файл, полученный через POST запрос, загружается в S3 с помощью метода upload()."
      },
      {
        "id": 122,
        "question": "Что такое микросервисы, зачем их используют?",
        "answer": "Микросервисы - это подход к разработке программного обеспечения, где приложение разбивается на небольшие, автономные сервисы, каждый из которых выполняет определенную функцию. Эти сервисы взаимодействуют друг с другом через сетевые вызовы. Микросервисы используются для улучшения масштабируемости, гибкости и поддержки в разработке приложений. Они позволяют независимо разрабатывать, тестировать, развертывать и масштабировать отдельные части приложения."
      },
      {
        "id": 123,
        "question": "В каких случаях вы бы выбрали монолит, а в каких - микросервисы?",
        "answer": "Монолит следует выбирать, когда приложение маленькое, требует минимальной инфраструктуры и поддержки, а также когда скорость разработки имеет большее значение, чем масштабируемость. Микросервисы стоит выбирать в случаях, когда приложение большое и сложное, требует высокой гибкости и масштабируемости, а также когда различные части приложения могут разрабатываться, тестироваться и разворачиваться независимо друг от друга."
      },
      {
        "id": 124,
        "question": "Как понять, что приложение в определенный момент работает исправно?",
        "answer": "Для этого можно использовать мониторинг состояния приложения, системы логирования и метрики производительности. Основные показатели включают доступность приложения, время отклика на запросы, отсутствие ошибок и предупреждений в журналах логов."
      },
      {
        "id": 125,
        "question": "Как понять, что приложение за последние три дня работало исправно?",
        "answer": "Для анализа работы приложения за последние три дня можно использовать системы мониторинга и анализа логов. Важно отслеживать количество ошибок, время ответа на запросы, количество пользовательских сессий и другие метрики производительности."
      },
      {
        "id": 126,
        "question": "Как происходит проверка правильности пароля при использовании bcrypt?",
        "answer": "Bcrypt - это алгоритм хэширования паролей, который использует соль и медленные вычисления для защиты от атак перебора паролей. При проверке правильности пароля происходит следующее: хэш пароля, хранящийся в базе данных, сравнивается с хэшем введенного пользователем пароля. Bcrypt автоматически извлекает соль из хэша, что делает атаки перебора сложными и затратными в вычислительных ресурсах."
      },
      {
        "id": 127,
        "question": "Что такое JWT?",
        "answer": "JWT (JSON Web Token) - это стандарт для создания токенов доступа, которые могут содержать информацию в формате JSON и подписываться цифровой подписью. Токены JWT используются для аутентификации и обмена информацией между сторонами. Они могут быть подписаны ключом, что обеспечивает проверку подлинности данных и защиту от подмены."
      },
      {
        "id": 128,
        "question": "Джуниор прислал код на ревью. Что здесь не так? Как исправить?",
        "answer": "Проблема в том, что переменная `users` не определена в контексте данного обработчика. Для исправления нужно вернуть `user`, который был создан в базе данных, вместо неопределенной переменной `users`. Вот исправленный код:\n\n```javascript\nrouter.post('/users', async (req, res, next) => {\n  try {\n    const user = await db.createUser(req);\n    if (user) {\n      return res.json(user);\n    }\n    res.json({ error: 'cannot create user' });\n  } catch (err) {\n    console.error('Error creating user:', err);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n```\n\nТеперь код корректно возвращает созданного пользователя или сообщение об ошибке при неудачной попытке создания."
      }
    ]
  },
  {
    "position": "middle",
    "topic": "Базы данных",
    "questions": [
      {
        "id": 129,
        "question": "Что такое Redis и для чего его используют?",
        "answer": "Redis - это высокопроизводительная система управления данными, которая использует структуры данных в памяти для хранения информации. Его часто используют для кэширования данных, сеансового хранения, работы с очередями сообщений, реализации ленты активности и других задач, где необходима высокая производительность и быстродействие."
      },
      {
        "id": 130,
        "question": "Какие базы данных использовали? Какая разница между SQL и NoSQL?",
        "answer": "Я использовал различные базы данных, включая MySQL, PostgreSQL, MongoDB и Redis. Основная разница между SQL и NoSQL базами данных заключается в структуре данных и способе их хранения. SQL базы данных используют реляционную модель, где данные организованы в таблицы с жесткой схемой. NoSQL базы данных, такие как MongoDB, используют гибкую структуру данных без жесткой схемы, что облегчает масштабирование и работу с неструктурированными данными."
      },
      {
        "id": 131,
        "question": "Для двух таблиц - комментарии и пользователи - напишите запрос, который выбирает последние три комментария для каждого пользователя.",
        "answer": "SELECT * FROM (\n  SELECT *, ROW_NUMBER() OVER(PARTITION BY user_id ORDER BY created_at DESC) AS row_num\n  FROM comments\n) AS ranked\nWHERE row_num <= 3;"
      },
      {
        "id": 132,
        "question": "Я как заказчик прошу выбрать вас базу данных для нового проекта. Ваши действия?",
        "answer": "При выборе базы данных для нового проекта я бы учитывал следующие аспекты:\n\n1. **Требования проекта:** Важно понять, какие типы данных необходимо хранить, скорость доступа к данным, требования к масштабируемости и доступности.\n\n2. **Опыт команды:** Если команда имеет опыт работы с определенной базой данных, это может повлиять на выбор в пользу технологии, с которой разработчики знакомы лучше всего.\n\n3. **Сообщество и поддержка:** Важно учитывать активность сообщества вокруг выбранной базы данных, наличие документации и инструментов поддержки.\n\n4. **Производительность и масштабируемость:** Если проект требует высокой производительности и масштабируемости, то выбор может быть оправдан использованием NoSQL решений или баз данных, поддерживающих горизонтальное масштабирование.\n\nПосле анализа этих аспектов я бы предложил наилучший вариант базы данных для конкретных потребностей проекта заказчику."
      }
    ]
  },
  {
    "position": "middle",
    "topic": "Инструменты и другое",
    "questions": [
      {
        "id": 133,
        "question": "Для чего нужен package-lock.json?",
        "answer": "Файл package-lock.json используется npm для фиксации версий установленных пакетов в проекте. Он гарантирует, что все участники проекта будут использовать одни и те же версии зависимостей, что предотвращает несовместимости и обеспечивает повторяемость установки пакетов на разных системах."
      },
      {
        "id": 134,
        "question": "В чем разница между npm install и npm ci?",
        "answer": "npm install устанавливает зависимости, указанные в файле package.json, учитывая файл package-lock.json для версионирования пакетов. npm ci же используется для строгой установки зависимостей по файлу package-lock.json, игнорируя package.json. Это делает npm ci более предсказуемым и быстрым на этапе сборки проекта."
      },
      {
        "id": 135,
        "question": "Для чего нужны бандлеры?",
        "answer": "Бандлеры используются для объединения различных модулей JavaScript и их зависимостей в один или несколько бандлов (файлов). Это позволяет управлять зависимостями, улучшает производительность загрузки приложения, позволяет использовать новейшие возможности JavaScript и оптимизирует его для продакшн среды."
      },
      {
        "id": 136,
        "question": "Расскажите о модульном подключении скриптов. Приведите пример использования загрузчиков / бандлеров модулей.",
        "answer": "Модульное подключение скриптов позволяет организовать код на JavaScript в небольшие, независимые модули, которые затем могут быть подключены к странице при помощи модульных загрузчиков или бандлеров. Например, с использованием Webpack можно создать конфигурацию, которая позволяет импортировать модули и автоматически собирать их в один или несколько бандлов для размещения на веб-странице."
      },
      {
        "id": 137,
        "question": "Чем различаются git merge и git rebase?",
        "answer": "git merge объединяет изменения из одной ветки в другую, создавая новый коммит, который содержит слияние всех изменений. git rebase же перебазирует текущую ветку на другую ветку, перенося все коммиты текущей ветки поверх последнего коммита целевой ветки. Результат использования rebase - история коммитов становится линейной, что упрощает чтение истории проекта."
      },
      {
        "id": 138,
        "question": "Что такое staging area в git?",
        "answer": "Staging area (или индекс) в Git - это промежуточная область, где размещаются изменения файлов, которые будут включены в следующий коммит. Перед коммитом пользователь добавляет изменения в staging area с помощью команды git add, после чего они готовы к фиксации в репозитории с помощью git commit."
      },
      {
        "id": 139,
        "question": "Опишите процесс code review. Назовите основные правила, способы разрешения конфликтов и споров во время его проведения.",
        "answer": "Code review - это процесс проверки кода, написанного одним разработчиком, другим или группой разработчиков. Основные правила включают проверку стиля кода, архитектуры, безопасности и эффективности. Для разрешения конфликтов и споров полезно следовать принципам конструктивной критики, уважения мнения других участников и фокусироваться на улучшении кода. Полезным инструментом является использование систем для код-ревью, таких как GitHub Pull Requests или GitLab Merge Requests, которые позволяют обсуждать и комментировать изменения прямо в коде."
      }
    ]
  },
  {
    "position": "middle",
    "topic": "Практические задания",
    "questions": [
      {
        "id": 140,
        "question": "Напишите функцию Sleep (ms), которая останавливает выполнение async-функции на заданный промежуток времени.",
        "answer": "async function sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}"
      },
      {
        "id": 141,
        "question": "Реализуйте один из методов массива (например, splice).",
        "answer": "Array.prototype.customSplice = function(start, deleteCount, ...items) {\n  const deleted = this.slice(start, start + deleteCount);\n  const afterDelete = this.slice(start + deleteCount);\n  this.length = start;\n  this.push(...items, ...afterDelete);\n  return deleted;\n};"
      },
      {
        "id": 142,
        "question": "Напишите функцию с RegExp для нахождения всех HTML-ссылок в строке.",
        "answer": "function findLinks(text) {\n  const regex = /<a\\s+(?:[^>]*?\\s+)?href=([\"'])(.*?)\\1/g;\n  const links = [];\n  let match;\n  while ((match = regex.exec(text)) !== null) {\n    links.push(match[2]);\n  }\n  return links;\n}"
      },
      {
        "id": 143,
        "question": "Реализуйте функцию, которая исполнит callback для всех элементов определенной ветви DOM-дерева.",
        "answer": "function traverseDOM(node, callback) {\n  callback(node);\n  node = node.firstElementChild;\n  while (node) {\n    traverseDOM(node, callback);\n    node = node.nextElementSibling;\n  }\n}"
      },
      {
        "id": 144,
        "question": "Реализуйте таблицу с виртуальным скролом.",
        "answer": "К сожалению, для полного ответа требуется больше информации о требованиях и окружении проекта."
      },
      {
        "id": 145,
        "question": "Реализуйте функцию преобразования URL query строки в JSON.",
        "answer": "function parseQueryString(url) {\n  const params = new URLSearchParams(url);\n  const obj = {};\n  for (const [key, value] of params) {\n    obj[key] = value;\n  }\n  return obj;\n}"
      },
      {
        "id": 146,
        "question": "Если есть проект с ограниченными сроками и некритичной производительностью, чем будете руководствоваться при выборе библиотек, подходов? Или все же будете обращать внимание на производительность? Или наоборот: сроки нелимитированные, производительность важна. Ваши действия?",
        "answer": "В проектах с ограниченными сроками и некритичной производительностью предпочтение отдается инструментам и подходам, которые обеспечивают быстрый старт разработки и простоту поддержки. Однако даже в таких проектах важно избегать явных узких мест и выбирать проверенные библиотеки с умеренным потреблением ресурсов."
      }
    ]
  },
  {
    "position": "senior",
    "topic": "Общие",
    "questions": [
      {
        "id": 1,
        "question": "Расскажите о функциональном программировании.",
        "answer": "Функциональное программирование (ФП) — это парадигма программирования, основанная на использовании функций как основных строительных блоков и ограничении изменяемого состояния и мутабельных данных. Основные концепции ФП включают чистые функции (pure functions), неизменяемость данных, рекурсию, функции высших порядков и использование функциональных комбинаторов. ФП способствует написанию более декларативного и чистого кода, облегчает тестирование и повышает параллелизм. Основные языки функционального программирования включают Haskell, Clojure, Erlang, Scala и другие."
      },
      {
        "id": 2,
        "question": "Что такое TDD (Test Driven Development) / BDD (Behavior Driven Development)?",
        "answer": "TDD (Test Driven Development) — методология разработки программного обеспечения, основанная на написании тестов перед написанием самого кода. Цель TDD заключается в создании четко определенных тестов, которые проверяют функциональность кода, до того как код будет написан. BDD (Behavior Driven Development) — это дальнейшее развитие TDD, с акцентом на описании поведения системы на естественном языке (например, на языке Gherkin), который легко читать и понимать стейкхолдерам. BDD специализируется на тестировании поведения и взаимодействия компонентов системы."
      },
      {
        "id": 3,
        "question": "Расскажите подробно о работе HTTPS.",
        "answer": "HTTPS (HyperText Transfer Protocol Secure) — это защищенная версия HTTP, использующая протокол TLS (Transport Layer Security) или его предшественника SSL (Secure Sockets Layer) для обеспечения безопасности передачи данных между клиентом и сервером. Работа HTTPS начинается с установления защищенного соединения между клиентом и сервером с использованием SSL/TLS протоколов. Этот процесс включает в себя шифрование данных, аутентификацию сторон, целостность данных и защиту от повторной передачи (replay protection). HTTPS обеспечивает конфиденциальность, целостность и аутентичность данных, передаваемых через интернет."
      },
      {
        "id": 4,
        "question": "Какой стек технологий можно выбрать для реализации клона какого-нибудь известного проекта и почему?",
        "answer": "Выбор стека технологий для клона известного проекта зависит от множества факторов, включая требования проекта, сроки, опыт команды разработчиков и цели проекта. Например, для создания клона Twitter можно выбрать Node.js для серверной части, React для фронтенда, MongoDB для хранения данных (например, твитов и пользователей), и Redis для кэширования и обработки в реальном времени. Этот стек технологий выбран из-за своей популярности, производительности и гибкости."
      },
      {
        "id": 5,
        "question": "Имеется проект на старых технологиях, необходимо в него вносить изменения. Как это сделать лучше всего?",
        "answer": "При внесении изменений в проект на старых технологиях лучше всего следовать принципу gradual upgrade — постепенного обновления. Это означает постепенное внедрение новых технологий, без полного переписывания проекта с нуля. Важно начать с анализа текущей архитектуры проекта и определения узких мест или устаревших компонентов. Затем выбрать части проекта, которые наиболее подходят для обновления, и начать с них. Постепенное обновление позволяет минимизировать риски и обеспечивает более плавный переход к современным технологиям."
      },
      {
        "id": 6,
        "question": "Если у кандидата есть опыт работы с несколькими фреймворками: какой будете использовать для следующего проекта? Какие факторы будут влиять на выбор?",
        "answer": "Выбор фреймворка для следующего проекта зависит от конкретных требований проекта, опыта команды разработчиков, экосистемы фреймворка, его поддержки и стабильности. Например, для проекта, требующего высокой производительности и масштабируемости, можно выбрать фреймворк Express.js для Node.js. Если требуется создание интерактивного пользовательского интерфейса, React может быть хорошим выбором благодаря своей гибкости и большому сообществу разработчиков."
      },
      {
        "id": 7,
        "question": "Что такое V8 Engine?",
        "answer": "V8 Engine — это открытая реализация JavaScript движка, разработанная компанией Google для использования в своих продуктах, включая браузер Chrome и серверную среду Node.js. V8 обеспечивает интерпретацию и компиляцию JavaScript в машинный код, оптимизацию производительности, управление памятью и другие функции. Он известен своей скоростью выполнения JavaScript кода и активно развивается для поддержки новых стандартов ECMAScript и оптимизации производительности."
      }
    ]
  },
  {
    "position": "senior",
    "topic": "JS Core",
    "questions": [
      {
        "id": 8,
        "question": "Реализация паттерна Class Free OOP (HTTPs://observablehq.com/@bratter/class-free-oop).",
        "answer": "Паттерн Class Free OOP представляет собой способ организации объектно-ориентированного программирования (ООП), в котором избегается использование классов в пользу функций и объектов. Основная идея заключается в том, чтобы использовать функции для создания объектов и оперировать данными как состоянием функций. Вместо классов используются функциональные конструкции, замыкания и прототипы для организации кода. Этот подход позволяет создавать более гибкие и легко тестируемые программы, а также упрощает кодирование в функциональном стиле."
      },
      {
        "id": 9,
        "question": "Паттерн async disposer (HTTPs://advancedweb.hu/what-is-the-async-disposer-pattern-in-javascript).",
        "answer": "Паттерн async disposer — это паттерн проектирования, который помогает управлять ресурсами или выполнением асинхронных операций с помощью специального объекта-диспозера. Основная идея заключается в том, чтобы асинхронно освобождать ресурсы после завершения выполнения определенных операций. Это особенно полезно в асинхронном JavaScript, где нужно корректно обрабатывать завершение операций и очистку ресурсов. Паттерн async disposer способствует улучшению управления памятью и ресурсами, предотвращает утечки ресурсов и делает код более надежным."
      },
      {
        "id": 10,
        "question": "Использование регулярных выражений. Когда приемлемо / неприемлемо? Как они работают? Как можно сделать читабельный код?",
        "answer": "Регулярные выражения (RegExp) используются для поиска и манипуляций текстовыми данными в строках. Они могут быть полезны при необходимости выполнения сложных операций поиска, замены и проверки шаблонов в строках. Однако использование регулярных выражений не всегда приемлемо из-за их сложности и трудности в понимании. Регулярные выражения обрабатывают текст, сопоставляя его с заданным шаблоном, что может привести к неожиданным результатам при неправильном использовании или плохо спроектированных шаблонах. Для улучшения читабельности кода с использованием регулярных выражений следует следовать следующим рекомендациям: документируйте регулярное выражение, используйте именованные группы для ясности, разделяйте сложные выражения на более простые части и добавляйте комментарии, если это необходимо."
      }
    ]
  },
  {
    "position": "senior",
    "topic": "Front-end",
    "questions": [
      {
        "id": 11,
        "question": "Как браузер определяет, можем ли мы общаться между вкладками?",
        "answer": "Браузер определяет возможность общения между вкладками на основе политики безопасности Same-Origin Policy (SOP). Эта политика ограничивает доступ к данным между веб-страницами, загруженными из разных источников. Для взаимодействия между вкладками используются механизмы, такие как Local Storage, Session Storage, Cookies, PostMessage API и Broadcast Channel API, которые позволяют передавать данные между различными источниками или вкладками в пределах одного источника."
      },
      {
        "id": 12,
        "question": "Что такое Content Security Policy?",
        "answer": "Content Security Policy (CSP) — это механизм безопасности веб-приложений, который позволяет контролировать и ограничивать ресурсы, которые браузер может загружать и выполнить на веб-странице. CSP позволяет указать список источников ресурсов, с которыми страница может взаимодействовать (например, скрипты, стили, изображения, шрифты), что помогает предотвратить атаки XSS (межсайтовый скриптинг) и снизить риски утечек данных."
      },
      {
        "id": 13,
        "question": "Как избежать загрузки кэшированных файлов скриптов и стилей?",
        "answer": "Для избежания загрузки кэшированных файлов скриптов и стилей можно использовать различные методы: изменение URL ресурсов (например, добавление версионного номера к URL), установка заголовков Cache-Control или Expires для указания браузеру на необходимость перезагрузки ресурсов при каждом запросе, использование механизмов контроля кэша на сервере (например, настройка nginx или Apache), а также использование специфических HTTP заголовков (например, Cache-Control: no-cache) при загрузке ресурсов."
      },
      {
        "id": 14,
        "question": "Что такое requestAnimationFrame?",
        "answer": "requestAnimationFrame (RAF) — это API браузера, предназначенное для планирования анимаций и других задач, требующих обновления экрана в определенные моменты времени, с учетом частоты обновления экрана устройства пользователя. RAF предлагает браузеру анимационный цикл, который синхронизируется с обновлением экрана и позволяет создавать плавные и эффективные анимации на веб-странице."
      },
      {
        "id": 15,
        "question": "Расскажите о микросервисной архитектуре Front-end App.",
        "answer": "Микросервисная архитектура Front-end App подразумевает разделение фронтенд-приложения на отдельные модули или сервисы, каждый из которых отвечает за определенную функциональность или компонент приложения. Эти микросервисы могут быть развернуты независимо друг от друга, использовать различные технологии и иметь свою собственную базу кода. Такой подход упрощает масштабирование, разработку и тестирование приложения, а также позволяет лучше организовать командную работу и управление проектом."
      },
      {
        "id": 16,
        "question": "Что такое Shadow DOM?",
        "answer": "Shadow DOM (DOM с тенью) — это механизм веб-стандартов, позволяющий создавать изолированные DOM-деревья и скрывать внутренние реализации компонентов от внешнего DOM-дерева страницы. Shadow DOM позволяет инкапсулировать стили и функциональность компонентов, что предотвращает конфликты стилей и имен и обеспечивает изоляцию от внешних стилей и скриптов страницы."
      },
      {
        "id": 17,
        "question": "Сравните nextElementSibling и nextSibling.",
        "answer": "nextElementSibling и nextSibling — это свойства DOM-элемента, которые позволяют получить следующий элемент на том же уровне иерархии DOM. Основное различие между ними заключается в том, что nextElementSibling возвращает следующий элемент-узел, который является элементом (HTMLElement), в то время как nextSibling может вернуть любой следующий узел (не обязательно элемент). Поэтому при работе с DOM стоит учитывать тип возвращаемого элемента при использовании этих свойств."
      },
      {
        "id": 18,
        "question": "Какие знаете метрики веб-сайта?",
        "answer": "Существует множество метрик для оценки производительности и пользовательского опыта веб-сайта. Некоторые из них включают: Time to First Byte (TTFB), First Contentful Paint (FCP), Largest Contentful Paint (LCP), First Input Delay (FID), Cumulative Layout Shift (CLS), Total Blocking Time (TBT), Time to Interactive (TTI), Page Load Time, Page Size, и другие. Эти метрики помогают разработчикам и владельцам веб-сайтов оценить производительность, скорость загрузки страницы и пользовательский опыт, что важно для улучшения работы сайта и удовлетворения пользовательских потребностей."
      }
    ]
  },
  {
    "position": "senior",
    "topic": "Angular",
    "questions": [
      {
        "id": 19,
        "question": "Как проводится конфигурация NgZone-модуля? Когда это необходимо?",
        "answer": "Конфигурация NgZone в Angular обычно проводится через опции при создании приложения или компонента. Необходимость конфигурации может возникнуть, когда требуется управление зоной выполнения Angular, например, для оптимизации производительности приложения. Это может включать создание кастомного NgZone или настройку опций NgZone для управления поведением обновления представления."
      },
      {
        "id": 20,
        "question": "Что раздражает в фреймворке? Что бы вы изменили?",
        "answer": "В разных фреймворках могут раздражать разные аспекты, такие как сложность настройки, избыточность API, неинтуитивные сообщения об ошибках и другие. Для улучшения фреймворка можно было бы упростить процесс настройки, предоставить более понятные и дружественные сообщения об ошибках, улучшить поддержку инструментов для разработчиков и документацию."
      },
      {
        "id": 21,
        "question": "Если бы вы решали, что добавить в следующем релизе фреймворка, какая фича это была бы?",
        "answer": "В следующем релизе фреймворка полезно было бы добавить поддержку динамической загрузки компонентов. Эта фича позволила бы загружать компоненты по требованию, улучшая производительность и масштабируемость приложений, особенно больших и сложных."
      },
      {
        "id": 22,
        "question": "Писали ли вы кастомные декораторы? Если да, то зачем?",
        "answer": "Да, кастомные декораторы часто используются для добавления дополнительной функциональности к классам, методам или свойствам в JavaScript и TypeScript. Они позволяют улучшить читаемость и модульность кода, а также добавить различные аспекты поведения, такие как логирование, кэширование, аутентификация и авторизация, метаданные и другие аспекты приложения."
      }
    ]
  },
  {
    "position": "senior",
    "topic": "Back-end",
    "questions": [
      {
        "id": 25,
        "question": "Сравните Common.js с AMD Modules и ES6 Imports.",
        "answer": "Common.js, AMD Modules и ES6 Imports - это различные спецификации для организации модульной системы в JavaScript.\n\n1. **Common.js**: Это формат модулей, используемый в Node.js. Модули Common.js загружаются синхронно и подходят для серверной разработки. Они используют `require()` для импорта и `module.exports` для экспорта.\n\n2. **AMD (Asynchronous Module Definition)**: AMD разработан для браузерной среды и поддерживает асинхронную загрузку модулей. Он использует функции `define()` для определения модулей и `require()` для их загрузки. AMD полезен для модульной системы с динамической загрузкой.\n\n3. **ES6 Imports (ES Modules)**: Это стандартная модульная система ECMAScript 6, поддерживаемая браузерами и Node.js. Она предоставляет синтаксис `import` для импорта модулей и `export` для их экспорта. ES6 Imports поддерживает статический анализ и декларативную зависимость, что улучшает производительность и обеспечивает надежность приложений."
      },
      {
        "id": 26,
        "question": "Какой фреймворк выбрали бы для бэкенда, почему?",
        "answer": "Выбор фреймворка для бэкенда зависит от требований проекта, команды разработчиков, опыта использования и других факторов. В качестве примера:\n\n- **Express.js**: Легкий и гибкий, подходит для небольших и средних проектов.\n- **Koa.js**: Более современный и использующий асинхронный подход с промисами.\n- **Spring Boot**: Для Java-разработки, предоставляющий множество интеграций и удобств в разработке.\n- **Django**: Используется в Python для быстрой разработки и мощных функций.\n\nВыбор фреймворка зависит также от экосистемы, сообщества поддержки, производительности, безопасности и специфических требований проекта."
      },
      {
        "id": 27,
        "question": "Опишите своими словами, как работает OAuth v2.",
        "answer": "OAuth 2.0 - это протокол авторизации, используемый для предоставления доступа к защищенным ресурсам от имени пользователя без необходимости передачи его учетных данных.\n\n1. **Авторизация**: Пользователь перенаправляется на сервер авторизации (Identity Provider) с запросом на доступ к ресурсу.\n\n2. **Подтверждение доступа**: Пользователь входит на сайте, указывает свое согласие на предоставление доступа требуемому приложению.\n\n3. **Выдача токена**: Авторизационный сервер генерирует токен доступа (Access Token) и, если необходимо, обновляет токен обновления (Refresh Token).\n\n4. **Доступ к ресурсу**: Приложение использует Access Token для доступа к защищенным ресурсам от имени пользователя.\n\nOAuth 2.0 обеспечивает гибкость и безопасность при работе с API и разделении доступа."
      },
      {
        "id": 28,
        "question": "Есть проект с источниками памяти, как их обнаружить, устранить и предотвратить это в будущем?",
        "answer": "Источники утечек памяти могут включать утечки обработчиков событий, утечки DOM-элементов, утечки замыканий или циклические ссылки на объекты. Для обнаружения и устранения утечек памяти:\n\n1. **Использование инструментов разработчика**: Профилирование кода с помощью инструментов, таких как Chrome DevTools, для анализа памяти и обнаружения утечек.\n\n2. **Очистка ресурсов**: Вручную освобождать ресурсы, такие как обработчики событий, подписки на события, ненужные DOM-элементы.\n\n3. **Использование слабых ссылок**: В JS можно использовать слабые ссылки для предотвращения циклических ссылок, что может привести к утечкам.\n\n4. **Тестирование и мониторинг**: Регулярное тестирование производительности и мониторинг работы приложения на предмет утечек памяти.\n\nДля предотвращения утечек памяти в будущем, важно следить за жизненным циклом объектов, минимизировать использование глобальных переменных и правильно управлять ресурсами."
      },
      {
        "id": 29,
        "question": "Есть проект с performance issues, как их обнаружить, устранить и предотвратить в будущем?",
        "answer": "Для обнаружения и устранения проблем с производительностью в проекте:\n\n1. **Профилирование кода**: Использование инструментов профилирования, таких как Chrome DevTools или специализированные инструменты, для идентификации узких мест в коде.\n\n2. **Оптимизация алгоритмов и структур данных**: Пересмотр алгоритмов на предмет оптимизации времени выполнения и использование эффективных структур данных.\n\n3. **Кэширование и оптимизация сетевых запросов**: Использование кэширования, минимизация запросов, оптимизация передачи данных.\n\n4. **Оптимизация загрузки ресурсов**: Минимизация и объединение файлов, использование сжатия и CDN для улучшения скорости загрузки.\n\n5. **Мониторинг и тестирование производительности**: Регулярное мониторинг производительности, создание профилей производительности и тестирование на масштабируемость.\n\nПредотвращение будущих проблем с производительностью включает в себя улучшение процесса разработки, регулярные аудиты производительности и внедрение мониторинга производительности в процесс разработки."
      }
    ]
  },
  {
    "position": "senior",
    "topic": "Базы данных",
    "questions": [
      {
        "id": 30,
        "question": "Какие альтернативные виды баз данных используете?",
        "answer": "В качестве альтернативных видов баз данных можно использовать:\n\n- **NoSQL базы данных** (например, MongoDB, Cassandra, Redis): Предназначены для работы с большими объемами неструктурированных данных и обеспечивают гибкость и масштабируемость.\n\n- **Графовые базы данных** (например, Neo4j, Amazon Neptune): Оптимизированы для работы с сильно связанными данными, такими как социальные сети или графы зависимостей.\n\n- **In-Memory базы данных** (например, Redis, Memcached): Хранят данные в оперативной памяти для быстрого доступа и обработки.\n\n- **Time-Series базы данных** (например, InfluxDB, Prometheus): Предназначены для хранения и анализа временных рядов данных, таких как метрики и логи времени выполнения.\n\n- **Wide-Column базы данных** (например, Apache Cassandra, ScyllaDB): Подходят для хранения и обработки больших объемов структурированных данных с высокой доступностью и масштабируемостью."
      },
      {
        "id": 31,
        "question": "Что такое RDS и почему он иногда не подходит?",
        "answer": "Amazon Relational Database Service (RDS) - это управляемый сервис баз данных от Amazon Web Services (AWS), который облегчает настройку, управление и масштабирование реляционных баз данных в облаке.\n\nОднако RDS может не подходить в следующих случаях:\n\n- **Высокие требования к масштабируемости**: RDS имеет ограничения по масштабируемости, особенно если требуется горизонтальное масштабирование или управление большими объемами данных.\n\n- **Сложные запросы и операции**: В некоторых случаях, особенно при сложных SQL-запросах или требованиях к производительности, может потребоваться более гибкий подход, чем предоставляемый RDS.\n\n- **Высокие затраты**: Использование RDS может быть дорогим в случае больших объемов данных или необходимости постоянного масштабирования и высокой доступности.\n\nВ таких ситуациях разработчики могут рассматривать альтернативные решения, такие как использование собственных серверов баз данных или переход к другим управляемым сервисам с большей гибкостью."
      },
      {
        "id": 32,
        "question": "Что такое SQL Injections и как их избежать?",
        "answer": "SQL Injection (SQLI) - это атака на безопасность, при которой злоумышленник вводит вредоносный SQL-код через входные данные приложения, что может привести к выполнению нежелательных SQL-запросов на сервере базы данных.\n\nДля предотвращения SQL Injections можно использовать следующие методы:\n\n- **Использование параметризованных запросов (Prepared Statements)**: Используйте параметры в SQL-запросах, которые передаются отдельно от запроса, а не включаются непосредственно в SQL-код.\n\n- **Использование ORM (Object-Relational Mapping)**: ORM фреймворки, такие как Sequelize для Node.js или Hibernate для Java, автоматически параметризируют SQL-запросы, что помогает избежать SQL Injections.\n\n- **Валидация и фильтрация входных данных**: Проверяйте и фильтруйте входные данные, чтобы исключить нежелательные символы и конструкции SQL.\n\n- **Минимизация прав доступа**: Ограничьте права доступа к базе данных на минимально необходимый уровень для предотвращения возможности выполнения вредоносных операций."
      },
      {
        "id": 33,
        "question": "Почему для запросов в БД надо использовать плейсхолдеры?",
        "answer": "Использование плейсхолдеров (placeholders) в SQL-запросах важно для безопасности и предотвращения SQL Injections. Плейсхолдеры позволяют отделить данные от кода SQL-запроса, что делает невозможным внедрение вредоносного SQL-кода через входные данные приложения.\n\nПреимущества использования плейсхолдеров:\n\n- **Безопасность**: Плейсхолдеры защищают от SQL Injections, поскольку данные передаются отдельно от SQL-кода и не интерпретируются как часть запроса.\n\n- **Производительность**: Некоторые СУБД могут кэшировать параметризованные запросы, что улучшает производительность за счет меньшей нагрузки на компиляцию и оптимизацию запросов.\n\n- **Читаемость и поддержка кода**: Параметризованные запросы обычно более читаемы и легче поддерживаются, так как они отделяют данные от логики запроса и делают код более ясным."
      },
      {
        "id": 34,
        "question": "Как спроектировать кластер на MongoDB?",
        "answer": "Проектирование кластера на MongoDB зависит от требований к производительности, доступности и масштабируемости приложения. Вот основные шаги по проектированию кластера:\n\n1. **Определение ролей узлов**: Выберите типы узлов (Primary, Secondary, Arbiters) в зависимости от требований к доступности и нагрузке.\n\n2. **Конфигурация репликационных наборов (Replica Sets)**: Создайте репликационные наборы для обеспечения отказоустойчивости и репликации данных.\n\n3. **Шардинг (Sharding)**: Разделите данные на шарды для равномерного распределения нагрузки и увеличения производительности. Учитывайте ключи шардирования и особенности доступа к данным.\n\n4. **Настройка мониторинга и бэкапов**: Установите системы мониторинга для отслеживания состояния кластера и настройте регулярные бэкапы для обеспечения безопасности данных.\n\n5. **Оптимизация запросов и индексов**: Создайте необходимые индексы для оптимизации запросов и обеспечения быстрого доступа к данным.\n\nПроектирование кластера MongoDB требует глубокого понимания архитектуры приложения и требований к его работе."
      },
      {
        "id": 35,
        "question": "Для чего используют MongoDB Aggregation framework?",
        "answer": "MongoDB Aggregation Framework предоставляет мощные инструменты для анализа, обработки и агрегации данных в MongoDB. Основные цели использования Aggregation Framework включают:\n\n- **Агрегация данных**: Выполнение сложных операций агрегации, таких как группировка, фильтрация, сортировка и вычисление статистических данных на основе множества документов.\n\n- **Преобразование данных**: Трансформация и обработка данных в MongoDB, включая добавление новых полей, преобразование типов данных и вычисление выражений.\n\n- **Вычисление выражений и функций**: Использование встроенных и пользовательских функций для выполнения сложных вычислений и операций над данными.\n\n- **Аналитика и отчетность**: Подготовка данных для аналитики, отчетности и представления информации в удобном формате.\n\nMongoDB Aggregation Framework позволяет эффективно обрабатывать данные на стороне базы данных, что способствует улучшению производительности и производительности приложений."
      },
      {
        "id": 36,
        "question": "Расскажите о GraphQL.",
        "answer": "GraphQL - это язык запросов для API, разработанный Facebook для работы с клиентскими приложениями. Основные особенности GraphQL:\n\n- **Гибкость запросов**: Клиенты могут запрашивать только необходимые данные с помощью одного запроса, что уменьшает количество обращений к серверу и улучшает производительность.\n\n- **Типизированная система**: GraphQL определяет схему данных с типами и возможными запросами, что облегчает разработку и документирование API.\n\n- **Разрешение запросов (Resolvers)**: GraphQL использует разрешители для определения логики получения данных из различных источников, таких как базы данных или внешние API.\n\n- **Оптимизация сетевого трафика**: Поскольку GraphQL позволяет клиентам выбирать поля в запросах, это минимизирует передачу лишних данных по сети.\n\n- **Инструменты разработчика**: GraphQL предоставляет инструменты для анализа запросов, проверки схемы и управления версиями API.\n\nGraphQL стал популярным инструментом для разработки API благодаря его гибкости и возможности точно задавать данные, необходимые клиентским приложениям."
      }
    ]
  },
  {
    "position": "senior",
    "topic": "Инструменты",
    "questions": [
      {
        "id": 37,
        "question": "Можете ли вы описать суть методологии git flow в двух словах?",
        "answer": "Git flow - это методология ветвления для работы с Git, которая предлагает строгие правила использования веток для разработки, релизов и исправлений."
      },
      {
        "id": 38,
        "question": "Что означает требование делать squash commits во время rebase?",
        "answer": "Squash commits во время rebase означает объединение нескольких коммитов в один для улучшения читаемости истории коммитов. Это помогает сохранять чистоту истории перед интеграцией изменений в основную ветку."
      },
      {
        "id": 39,
        "question": "Каково ваше мнение об альтернативных системы контроля версий (Version Control System)?",
        "answer": "Альтернативные системы контроля версий, такие как Mercurial, SVN (Subversion), Perforce, имеют свои особенности и применение в различных сценариях разработки. Выбор между ними зависит от требований проекта, командных предпочтений и интеграции с другими инструментами."
      },
      {
        "id": 40,
        "question": "Какие конвенции знаете и используете для git?",
        "answer": "Для работы с Git используются различные конвенции, такие как:\n\n- **Комментарии к коммитам**: Использование осмысленных и информативных сообщений коммитов в формате, понятном всей команде.\n\n- **Именование веток**: Использование понятных имен веток, соответствующих их назначению (например, feature/my-feature, bugfix/issue-123).\n\n- **Использование тегов**: Добавление аннотированных тегов к релизным коммитам для обозначения версий приложения.\n\n- **Управление ветвлением**: Соблюдение методологий ветвления, таких как Git Flow или GitHub Flow, для эффективного управления разработкой и релизами."
      },
      {
        "id": 41,
        "question": "Расскажите о своем опыте использования / внедрения CI / CD.",
        "answer": "Мой опыт включает использование и внедрение CI/CD для автоматизации процессов разработки и доставки программного обеспечения. Это включает настройку средств непрерывной интеграции (CI), таких как Jenkins, GitLab CI, GitHub Actions, и настройку непрерывной доставки (CD) для автоматической поставки изменений в продакшн или тестовые среды."
      },
      {
        "id": 42,
        "question": "Необходимо настроить деплой проекту на несколько сред. Расскажите, как бы вы построили процесс? Какие инструменты использовали бы?",
        "answer": "Для настройки деплоя проекта на несколько сред (например, разработка, тестирование, продакшн) я бы построил следующий процесс:\n\n1. **Выбор инструментов CI/CD**: Использование платформы для непрерывной интеграции и доставки, такой как Jenkins, GitLab CI/CD, или GitHub Actions, в зависимости от требований проекта.\n\n2. **Настройка пайплайнов CI/CD**: Создание пайплайнов для автоматизации сборки, тестирования и деплоя приложения на различные среды.\n\n3. **Конфигурация окружений**: Настройка окружений (development, staging, production) с учетом специфики каждой среды, включая параметры конфигурации и доступа к ресурсам.\n\n4. **Управление версиями и релизами**: Использование инструментов для управления версиями и релизами приложения, таких как Git тегирование или специализированные системы управления версиями.\n\n5. **Мониторинг и отчетность**: Настройка системы мониторинга для отслеживания состояния приложения после каждого деплоя и создание отчетов о процессах CI/CD.\n\nЭтот процесс позволит автоматизировать доставку изменений в различные среды, ускорить развертывание и улучшить качество разработки."
      }
    ]
  },
  {
    "position": "senior",
    "topic": "Практические задания",
    "questions": [
      {
        "id": 43,
        "question": "Реализуйте асинхронный метод filter для Array (должны работать await).",
        "answer": "Для реализации асинхронного метода filter для Array можно воспользоваться функцией, которая будет фильтровать элементы массива асинхронно. Вот пример реализации:\n\n```javascript\nArray.prototype.asyncFilter = async function(callback) {\n  const filtered = [];\n  for (let i = 0; i < this.length; i++) {\n    const result = await callback(this[i], i, this);\n    if (result) {\n      filtered.push(this[i]);\n    }\n  }\n  return filtered;\n};\n\n// Пример использования\nconst filteredArray = await [1, 2, 3, 4].asyncFilter(async (item) => {\n  // Асинхронная проверка условия\n  return item % 2 === 0;\n});\nconsole.log(filteredArray); // Выведет [2, 4]\n```\n\nЭтот метод позволяет асинхронно фильтровать массив, используя await для ожидания выполнения каждой асинхронной операции."
      },
      {
        "id": 44,
        "question": "Реализуйте функцию reduce при помощи рекурсии.",
        "answer": "Функция reduce, реализованная с помощью рекурсии, может выглядеть следующим образом:\n\n```javascript\nfunction recursiveReduce(arr, callback, initialValue) {\n  function reduceHelper(arr, callback, accumulator, currentIndex) {\n    if (currentIndex >= arr.length) {\n      return accumulator;\n    }\n    const currentValue = arr[currentIndex];\n    accumulator = callback(accumulator, currentValue, currentIndex, arr);\n    return reduceHelper(arr, callback, accumulator, currentIndex + 1);\n  }\n  return reduceHelper(arr, callback, initialValue, 0);\n}\n\n// Пример использования\nconst sum = recursiveReduce([1, 2, 3, 4], (acc, curr) => acc + curr, 0);\nconsole.log(sum); // Выведет 10\n```\n\nЭта функция реализует рекурсивный подход к методу reduce, который последовательно применяет функцию callback к элементам массива, начиная с initialValue."
      },
      {
        "id": 45,
        "question": "Как можно было бы сделать toggle-компонент, как в iPhone, без использования JS?",
        "answer": "Для создания toggle-компонента, как в iPhone, без использования JavaScript, можно воспользоваться HTML и CSS. Вот пример такого компонента:\n\n```html\n<input type=\"checkbox\" id=\"toggle\" />\n<label for=\"toggle\"></label>\n```\n\n```css\ninput[type=\"checkbox\"] {\n  display: none;\n}\n\nlabel {\n  display: block;\n  width: 50px;\n  height: 30px;\n  background-color: gray;\n  border-radius: 15px;\n  position: relative;\n  cursor: pointer;\n}\n\ninput[type=\"checkbox\"]:checked + label {\n  background-color: blue;\n}\n\nlabel::before {\n  content: '';\n  position: absolute;\n  top: 3px;\n  left: 3px;\n  width: 24px;\n  height: 24px;\n  background-color: white;\n  border-radius: 50%;\n  transition: transform 0.3s ease;\n}\n\ninput[type=\"checkbox\"]:checked + label::before {\n  transform: translateX(20px);\n}\n```\n\nЭтот код создает toggle-компонент с использованием чекбокса и метки, стилизованный CSS. При клике на метку чекбокс переключается, что позволяет изменять визуальное состояние компонента без использования JavaScript."
      }
    ]
  }
]
